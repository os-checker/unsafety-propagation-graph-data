{
  "name": "sys::fs::unix::File::try_lock",
  "safe": true,
  "callees": {
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "libc::flock": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "io::error::Error::kind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the corresponding [`ErrorKind`] for this error.\n\n This may be a value set by Rust code constructing custom `io::Error`s,\n or if this `io::Error` was sourced from the operating system,\n it will be a value inferred from the system's error encoding.\n See [`last_os_error`] for more details.\n\n [`last_os_error`]: Error::last_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_error(err: Error) {\n     println!(\"{:?}\", err.kind());\n }\n\n fn main() {\n     // As no error has (visibly) occurred, this may print anything!\n     // It likely prints a placeholder for unidentified (non-)errors.\n     print_error(Error::last_os_error());\n     // Will print \"AddrInUse\".\n     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "io::error::Error": "ImmutableAsArgument",
        "io::error::ErrorKind": "Constructor"
      }
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::fs::unix::File": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "io::error::Error": [
      "Plain",
      "Ref"
    ],
    "io::error::ErrorKind": [
      "Plain",
      "Ref"
    ],
    "fs::TryLockError": [
      "Plain"
    ]
  },
  "path": 3537,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1384:5: 1395:6",
  "src": "pub fn try_lock(&self) -> Result<(), TryLockError> {\n        let result = cvt(unsafe { libc::flock(self.as_raw_fd(), libc::LOCK_EX | libc::LOCK_NB) });\n        if let Err(err) = result {\n            if err.kind() == io::ErrorKind::WouldBlock {\n                Err(TryLockError::WouldBlock)\n            } else {\n                Err(TryLockError::Error(err))\n            }\n        } else {\n            Ok(())\n        }\n    }",
  "mir": "fn sys::fs::unix::File::try_lock(_1: &sys::fs::unix::File) -> core::result::Result<(), fs::TryLockError> {\n    let mut _0: core::result::Result<(), fs::TryLockError>;\n    let  _2: core::result::Result<i32, io::error::Error>;\n    let mut _3: i32;\n    let mut _4: i32;\n    let mut _5: i32;\n    let mut _6: isize;\n    let  _7: io::error::Error;\n    let mut _8: bool;\n    let mut _9: &io::error::ErrorKind;\n    let  _10: io::error::ErrorKind;\n    let mut _11: &io::error::Error;\n    let mut _12: &io::error::ErrorKind;\n    let mut _13: fs::TryLockError;\n    let mut _14: fs::TryLockError;\n    let mut _15: io::error::Error;\n    let mut _16: bool;\n    debug self => _1;\n    debug result => _2;\n    debug err => _7;\n    bb0: {\n        _16 = false;\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = <sys::fs::unix::File as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = BitOr(libc::LOCK_EX, libc::LOCK_NB);\n        _3 = libc::flock(move _4, move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _2 = sys::pal::unix::cvt::<i32>(move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        _6 = discriminant(_2);\n        switchInt(move _6) -> [1: bb4, 0: bb10, otherwise: bb14];\n    }\n    bb4: {\n        StorageLive(_7);\n        _16 = true;\n        _7 = move ((_2 as variant#1).0: io::error::Error);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_7;\n        _10 = io::error::Error::kind(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = &_10;\n        StorageDead(_11);\n        StorageLive(_12);\n        _12 = sys::fs::unix::File::try_lock::promoted[0];\n        _8 = <io::error::ErrorKind as core::cmp::PartialEq>::eq(move _9, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_13);\n        _13 = fs::TryLockError::WouldBlock;\n        _0 = core::result::Result::Err(move _13);\n        StorageDead(_13);\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_14);\n        StorageLive(_15);\n        _16 = false;\n        _15 = move _7;\n        _14 = fs::TryLockError::Error(move _15);\n        StorageDead(_15);\n        _0 = core::result::Result::Err(move _14);\n        StorageDead(_14);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_8);\n        switchInt(_16) -> [0: bb11, otherwise: bb12];\n    }\n    bb10: {\n        _0 = core::result::Result::Ok(());\n        goto -> bb13;\n    }\n    bb11: {\n        _16 = false;\n        StorageDead(_7);\n        goto -> bb13;\n    }\n    bb12: {\n        drop(_7) -> [return: bb11, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_2);\n        return;\n    }\n    bb14: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}