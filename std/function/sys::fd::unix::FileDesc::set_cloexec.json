{
  "name": "sys::fd::unix::FileDesc::set_cloexec",
  "safe": true,
  "callees": {
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "libc::fcntl": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::fd::unix::FileDesc": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::fd::unix::FileDesc::set_cloexec"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fd/unix.rs:587:5: 596:6",
  "src": "pub fn set_cloexec(&self) -> io::Result<()> {\n        unsafe {\n            let previous = cvt(libc::fcntl(self.as_raw_fd(), libc::F_GETFD))?;\n            let new = previous | libc::FD_CLOEXEC;\n            if new != previous {\n                cvt(libc::fcntl(self.as_raw_fd(), libc::F_SETFD, new))?;\n            }\n            Ok(())\n        }\n    }",
  "mir": "fn sys::fd::unix::FileDesc::set_cloexec(_1: &sys::fd::unix::FileDesc) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _2: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _3: core::result::Result<i32, io::error::Error>;\n    let mut _4: i32;\n    let mut _5: i32;\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _8: i32;\n    let  _9: i32;\n    let mut _10: bool;\n    let mut _11: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _12: core::result::Result<i32, io::error::Error>;\n    let mut _13: i32;\n    let mut _14: i32;\n    let mut _15: isize;\n    let  _16: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _17: i32;\n    debug self => _1;\n    debug previous => _8;\n    debug residual => _7;\n    debug val => _8;\n    debug new => _9;\n    debug residual => _16;\n    debug val => _17;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = <sys::fd::unix::FileDesc as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = libc::fcntl(move _5, libc::F_GETFD) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = sys::pal::unix::cvt::<i32>(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _2 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        _6 = discriminant(_2);\n        switchInt(move _6) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _8 = ((_2 as variant#0).0: i32);\n        StorageDead(_2);\n        _9 = BitOr(_8, libc::FD_CLOEXEC);\n        StorageLive(_10);\n        _10 = Ne(_9, _8);\n        switchInt(move _10) -> [0: bb17, otherwise: bb9];\n    }\n    bb7: {\n        _7 = move ((_2 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_7) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_2);\n        goto -> bb19;\n    }\n    bb9: {\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = <sys::fd::unix::FileDesc as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _13 = libc::fcntl(move _14, libc::F_SETFD, _9) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_14);\n        _12 = sys::pal::unix::cvt::<i32>(move _13) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_13);\n        _11 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _12) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_12);\n        _15 = discriminant(_11);\n        switchInt(move _15) -> [0: bb14, 1: bb15, otherwise: bb5];\n    }\n    bb14: {\n        StorageLive(_17);\n        _17 = ((_11 as variant#0).0: i32);\n        StorageDead(_17);\n        StorageDead(_11);\n        goto -> bb18;\n    }\n    bb15: {\n        _16 = move ((_11 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_16) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb19;\n    }\n    bb17: {\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_10);\n        _0 = core::result::Result::Ok(());\n        goto -> bb20;\n    }\n    bb19: {\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}