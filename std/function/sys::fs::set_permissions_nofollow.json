{
  "name": "sys::fs::set_permissions_nofollow",
  "safe": true,
  "callees": {
    "fs::OpenOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a blank new set of options ready for configuration.\n\n All options are initially set to `false`.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let mut options = OpenOptions::new();\n let file = options.read(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "Constructor"
      }
    },
    "os::unix::fs::OpenOptionsExt::custom_flags": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Pass custom flags to the `flags` argument of `open`.\n\n The bits that define the access mode are masked out with `O_ACCMODE`, to\n ensure they do not interfere with the access mode set by Rust's options.\n\n Custom flags can only set flags, not remove flags set by Rust's options.\n This function overwrites any previously-set custom flags.\n\n # Examples\n\n ```no_run\n # mod libc { pub const O_NOFOLLOW: i32 = 0; }\n use std::fs::OpenOptions;\n use std::os::unix::fs::OpenOptionsExt;\n\n # fn main() {\n let mut options = OpenOptions::new();\n options.write(true);\n options.custom_flags(libc::O_NOFOLLOW);\n let file = options.open(\"foo.txt\");\n # }\n ```\n",
      "adt": {}
    },
    "fs::OpenOptions::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Opens a file at `path` with the options specified by `self`.\n\n # Errors\n\n This function will return an error under a number of different\n circumstances. Some of these error conditions are listed here, together\n with their [`io::ErrorKind`]. The mapping to [`io::ErrorKind`]s is not\n part of the compatibility contract of the function.\n\n * [`NotFound`]: The specified file does not exist and neither `create`\n   or `create_new` is set.\n * [`NotFound`]: One of the directory components of the file path does\n   not exist.\n * [`PermissionDenied`]: The user lacks permission to get the specified\n   access rights for the file.\n * [`PermissionDenied`]: The user lacks permission to open one of the\n   directory components of the specified path.\n * [`AlreadyExists`]: `create_new` was specified and the file already\n   exists.\n * [`InvalidInput`]: Invalid combinations of open options (truncate\n   without write access, create without write or append access,\n   no access mode set, etc.).\n\n The following errors don't match any existing [`io::ErrorKind`] at the moment:\n * One of the directory components of the specified file path\n   was not, in fact, a directory.\n * Filesystem-level errors: full disk, write permission\n   requested on a read-only file system, exceeded disk quota, too many\n   open files, too long filename, too many symbolic links in the\n   specified path (Unix-like systems only), etc.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().read(true).open(\"foo.txt\");\n ```\n\n [`AlreadyExists`]: io::ErrorKind::AlreadyExists\n [`InvalidInput`]: io::ErrorKind::InvalidInput\n [`NotFound`]: io::ErrorKind::NotFound\n [`PermissionDenied`]: io::ErrorKind::PermissionDenied\n",
      "adt": {
        "fs::OpenOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fs::File::set_permissions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Changes the permissions on the underlying file.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `fchmod` function on Unix and\n the `SetFileInformationByHandle` function on Windows. Note that, this\n [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n\n # Errors\n\n This function will return an error if the user lacks permission change\n attributes on the underlying file. It may also return an error in other\n os-specific unspecified cases.\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs::File;\n\n     let file = File::open(\"foo.txt\")?;\n     let mut perms = file.metadata()?.permissions();\n     perms.set_readonly(true);\n     file.set_permissions(perms)?;\n     Ok(())\n }\n ```\n\n Note that this method alters the permissions of the underlying file,\n even though it takes `&self` rather than `&mut self`.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "ImmutableAsArgument"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fs::OpenOptions": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "fs::File": [
      "Plain",
      "Ref"
    ],
    "fs::Permissions": [
      "Plain"
    ]
  },
  "path": 3618,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/mod.rs:126:1: 140:2",
  "src": "pub fn set_permissions_nofollow(path: &Path, perm: crate::fs::Permissions) -> io::Result<()> {\n    use crate::fs::OpenOptions;\n\n    let mut options = OpenOptions::new();\n\n    // ESP-IDF and Horizon do not support O_NOFOLLOW, so we skip setting it.\n    // Their filesystems do not have symbolic links, so no special handling is required.\n    #[cfg(not(any(target_os = \"espidf\", target_os = \"horizon\")))]\n    {\n        use crate::os::unix::fs::OpenOptionsExt;\n        options.custom_flags(libc::O_NOFOLLOW);\n    }\n\n    options.open(path)?.set_permissions(perm)\n}",
  "mir": "fn sys::fs::set_permissions_nofollow(_1: &path::Path, _2: fs::Permissions) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: fs::OpenOptions;\n    let  _4: &mut fs::OpenOptions;\n    let mut _5: &mut fs::OpenOptions;\n    let mut _6: &fs::File;\n    let  _7: fs::File;\n    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::File>;\n    let mut _9: core::result::Result<fs::File, io::error::Error>;\n    let mut _10: &fs::OpenOptions;\n    let mut _11: isize;\n    let  _12: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _13: fs::File;\n    debug path => _1;\n    debug perm => _2;\n    debug options => _3;\n    debug residual => _12;\n    debug val => _13;\n    bb0: {\n        StorageLive(_3);\n        _3 = fs::OpenOptions::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _3;\n        _4 = <fs::OpenOptions as os::unix::fs::OpenOptionsExt>::custom_flags(move _5, libc::O_NOFOLLOW) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_3;\n        _9 = fs::OpenOptions::open::<&path::Path>(move _10, _1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_10);\n        _8 = <core::result::Result<fs::File, io::error::Error> as core::ops::Try>::branch(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _11 = discriminant(_8);\n        switchInt(move _11) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_13);\n        _13 = move ((_8 as variant#0).0: fs::File);\n        _7 = move _13;\n        StorageDead(_13);\n        _6 = &_7;\n        _0 = fs::File::set_permissions(move _6, _2) -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _12 = move ((_8 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb10;\n    }\n    bb9: {\n        drop(_7) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        return;\n    }\n    bb11: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb10;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}