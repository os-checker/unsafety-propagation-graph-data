{
  "name": "<io::buffered::bufreader::BufReader<R> as io::Read>::read_to_string",
  "safe": true,
  "callees": {
    "alloc_crate::string::String::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if this `String` has a length of zero, and `false` otherwise.\n\n # Examples\n\n ```\n let mut v = String::new();\n assert!(v.is_empty());\n\n v.push('a');\n assert!(!v.is_empty());\n ```\n",
      "adt": {}
    },
    "io::append_to_string": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "alloc_crate::string::String": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "alloc_crate::vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {}
    },
    "io::Read::read_to_end": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes until EOF in this source, placing them into `buf`.\n\n All bytes read from this source will be appended to the specified buffer\n `buf`. This function will continuously call [`read()`] to append more data to\n `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n non-[`ErrorKind::Interrupted`] kind.\n\n If successful, this function will return the total number of bytes read.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If any other read error is encountered then this function immediately\n returns. Any bytes which have already been read will be appended to\n `buf`.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read()`]: Read::read\n [`Ok(0)`]: Ok\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = Vec::new();\n\n     // read the whole file\n     f.read_to_end(&mut buffer)?;\n     Ok(())\n }\n ```\n\n (See also the [`std::fs::read`] convenience function for reading from a\n file.)\n\n [`std::fs::read`]: crate::fs::read\n\n ## Implementing `read_to_end`\n\n When implementing the `io::Read` trait, it is recommended to allocate\n memory using [`Vec::try_reserve`]. However, this behavior is not guaranteed\n by all implementations, and `read_to_end` may not handle out-of-memory\n situations gracefully.\n\n ```no_run\n # use std::io::{self, BufRead};\n # struct Example { example_datasource: io::Empty } impl Example {\n # fn get_some_data_for_the_example(&self) -> &'static [u8] { &[] }\n fn read_to_end(&mut self, dest_vec: &mut Vec<u8>) -> io::Result<usize> {\n     let initial_vec_len = dest_vec.len();\n     loop {\n         let src_buf = self.example_datasource.fill_buf()?;\n         if src_buf.is_empty() {\n             break;\n         }\n         dest_vec.try_reserve(src_buf.len())?;\n         dest_vec.extend_from_slice(src_buf);\n\n         // Any irreversible side effects should happen after `try_reserve` succeeds,\n         // to avoid losing data on allocation error.\n         let read = src_buf.len();\n         self.example_datasource.consume(read);\n     }\n     Ok(dest_vec.len() - initial_vec_len)\n }\n # }\n ```\n\n # Usage Notes\n\n `read_to_end` attempts to read a source until EOF, but many sources are continuous streams\n that do not send EOF. In these cases, `read_to_end` will block indefinitely. Standard input\n is one such stream which may be finite if piped, but is typically continuous. For example,\n `cat file | my-rust-program` will correctly terminate with an `EOF` upon closure of cat.\n Reading user input or running programs that remain open indefinitely will never terminate\n the stream with `EOF` (e.g. `yes | my-rust-program`).\n\n Using `.lines()` with a [`BufReader`] or using [`read`] can provide a better solution\n\n[`read`]: Read::read\n\n [`Vec::try_reserve`]: crate::vec::Vec::try_reserve\n",
      "adt": {
        "core::result::Result": "Constructor",
        "alloc_crate::vec::Vec": "MutableAsArgument"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::str::from_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string slice.\n\n This is an alias to [`str::from_utf8`].\n\n A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n the two. Not all byte slices are valid string slices, however: [`&str`] requires\n that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n UTF-8, and then does the conversion.\n\n [`&str`]: str\n [byteslice]: slice\n\n If you are sure that the byte slice is valid UTF-8, and you don't want to\n incur the overhead of the validity check, there is an unsafe version of\n this function, [`from_utf8_unchecked`], which has the same\n behavior but skips the check.\n\n If you need a `String` instead of a `&str`, consider\n [`String::from_utf8`][string].\n\n [string]: ../../std/string/struct.String.html#method.from_utf8\n\n Because you can stack-allocate a `[u8; N]`, and you can take a\n [`&[u8]`][byteslice] of it, this function is one way to have a\n stack-allocated string. There is an example of this in the\n examples section below.\n\n [byteslice]: slice\n\n # Errors\n\n Returns `Err` if the slice is not UTF-8 with a description as to why the\n provided slice is not UTF-8.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n // We can use the ? (try) operator to check if the bytes are valid\n let sparkle_heart = str::from_utf8(&sparkle_heart)?;\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n # Ok::<_, str::Utf8Error>(())\n ```\n\n Incorrect bytes:\n\n ```\n use std::str;\n\n // some invalid bytes, in a vector\n let sparkle_heart = vec![0, 159, 146, 150];\n\n assert!(str::from_utf8(&sparkle_heart).is_err());\n ```\n\n See the docs for [`Utf8Error`] for more details on the kinds of\n errors that can be returned.\n\n A \"stack allocated string\":\n\n ```\n use std::str;\n\n // some bytes, in a stack-allocated array\n let sparkle_heart = [240, 159, 146, 150];\n\n // We know these bytes are valid, so just use `unwrap()`.\n let sparkle_heart: &str = str::from_utf8(&sparkle_heart).unwrap();\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    },
    "core::ops::AddAssign::add_assign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `+=` operation.\n\n # Example\n\n ```\n let mut x: u32 = 12;\n x += 1;\n assert_eq!(x, 13);\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"Æ’oo\".len(), 4); // fancy f!\n assert_eq!(\"Æ’oo\".chars().count(), 3);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::string::String": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "io::buffered::bufreader::BufReader": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::buffered::bufreader::BufReader<R> as io::Read>::read_to_string"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:412:5: 439:6",
  "src": "fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        // In the general `else` case below we must read bytes into a side buffer, check\n        // that they are valid UTF-8, and then append them to `buf`. This requires a\n        // potentially large memcpy.\n        //\n        // If `buf` is empty--the most common case--we can leverage `append_to_string`\n        // to read directly into `buf`'s internal byte buffer, saving an allocation and\n        // a memcpy.\n        if buf.is_empty() {\n            // `append_to_string`'s safety relies on the buffer only being appended to since\n            // it only checks the UTF-8 validity of new data. If there were existing content in\n            // `buf` then an untrustworthy reader (i.e. `self.inner`) could not only append\n            // bytes but also modify existing bytes and render them invalid. On the other hand,\n            // if `buf` is empty then by definition any writes must be appends and\n            // `append_to_string` will validate all of the new bytes.\n            unsafe { crate::io::append_to_string(buf, |b| self.read_to_end(b)) }\n        } else {\n            // We cannot append our byte buffer directly onto the `buf` String as there could\n            // be an incomplete UTF-8 sequence that has only been partially read. We must read\n            // everything into a side buffer first and then call `from_utf8` on the complete\n            // buffer.\n            let mut bytes = Vec::new();\n            self.read_to_end(&mut bytes)?;\n            let string = crate::str::from_utf8(&bytes).map_err(|_| io::Error::INVALID_UTF8)?;\n            *buf += string;\n            Ok(string.len())\n        }\n    }",
  "mir": "fn <io::buffered::bufreader::BufReader<R> as io::Read>::read_to_string(_1: &mut io::buffered::bufreader::BufReader<R>, _2: &mut alloc_crate::string::String) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _3: bool;\n    let mut _4: &alloc_crate::string::String;\n    let mut _5: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:427:55: 427:58};\n    let mut _6: alloc_crate::vec::Vec<u8>;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, usize>;\n    let mut _8: core::result::Result<usize, io::error::Error>;\n    let mut _9: &mut alloc_crate::vec::Vec<u8>;\n    let mut _10: isize;\n    let  _11: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _12: usize;\n    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, &str>;\n    let mut _14: core::result::Result<&str, io::error::Error>;\n    let mut _15: core::result::Result<&str, core::str::Utf8Error>;\n    let  _16: &[u8];\n    let  _17: &alloc_crate::vec::Vec<u8>;\n    let mut _18: isize;\n    let  _19: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _20: &str;\n    let  _21: ();\n    let mut _22: usize;\n    debug self => _1;\n    debug buf => _2;\n    debug bytes => _6;\n    debug residual => _11;\n    debug val => _12;\n    debug string => _20;\n    debug residual => _19;\n    debug val => _20;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &(*_2);\n        _3 = alloc_crate::string::String::is_empty(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:427:55: 427:58}(_1);\n        _0 = io::append_to_string::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:427:55: 427:58}>(_2, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        goto -> bb22;\n    }\n    bb4: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = alloc_crate::vec::Vec::<u8>::new() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _9 = &mut _6;\n        _8 = <io::buffered::bufreader::BufReader<R> as io::Read>::read_to_end(_1, _9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _7 = <core::result::Result<usize, io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        _10 = discriminant(_7);\n        switchInt(move _10) -> [0: bb9, 1: bb10, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        StorageLive(_12);\n        _12 = ((_7 as variant#0).0: usize);\n        StorageDead(_12);\n        StorageDead(_7);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _17 = &_6;\n        _16 = <alloc_crate::vec::Vec<u8> as core::ops::Deref>::deref(_17) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _11 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_11) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_7);\n        goto -> bb23;\n    }\n    bb12: {\n        _15 = core::str::from_utf8(_16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _14 = core::result::Result::<&str, core::str::Utf8Error>::map_err::<io::error::Error, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:435:64: 435:67}>(move _15, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:435:64: 435:67}) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_15);\n        _13 = <core::result::Result<&str, io::error::Error> as core::ops::Try>::branch(move _14) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_14);\n        _18 = discriminant(_13);\n        switchInt(move _18) -> [0: bb16, 1: bb17, otherwise: bb8];\n    }\n    bb16: {\n        _20 = ((_13 as variant#0).0: &str);\n        StorageDead(_13);\n        _21 = <alloc_crate::string::String as core::ops::AddAssign<&str>>::add_assign(_2, _20) -> [return: bb19, unwind unreachable];\n    }\n    bb17: {\n        _19 = move ((_13 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_19) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_13);\n        goto -> bb23;\n    }\n    bb19: {\n        StorageLive(_22);\n        _22 = core::str::<impl str>::len(_20) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _0 = core::result::Result::Ok(move _22);\n        StorageDead(_22);\n        drop(_6) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_6);\n        goto -> bb22;\n    }\n    bb22: {\n        StorageDead(_3);\n        goto -> bb25;\n    }\n    bb23: {\n        drop(_6) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb25;\n    }\n    bb25: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}