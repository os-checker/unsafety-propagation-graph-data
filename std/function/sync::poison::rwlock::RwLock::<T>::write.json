{
  "name": "sync::poison::rwlock::RwLock::<T>::write",
  "safe": true,
  "callees": {
    "sys::sync::rwlock::futex::RwLock::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::sync::rwlock::futex::RwLock": "ImmutableAsArgument"
      }
    },
    "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new instance of `RwLockWriteGuard<T>` from a `RwLock<T>`.\n\n # Safety\n\n This function is safe if and only if the same thread has successfully and safely called\n `lock.inner.write()`, `lock.inner.try_write()`, or `lock.inner.try_upgrade` before\n instantiating this object.\n",
      "adt": {
        "sync::poison::rwlock::RwLock": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::sync::rwlock::futex::RwLock": [
      "Ref"
    ],
    "sync::poison::rwlock::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 3267,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/rwlock.rs:487:5: 492:6",
  "src": "pub fn write(&self) -> LockResult<RwLockWriteGuard<'_, T>> {\n        unsafe {\n            self.inner.write();\n            RwLockWriteGuard::new(self)\n        }\n    }",
  "mir": "fn sync::poison::rwlock::RwLock::<T>::write(_1: &sync::poison::rwlock::RwLock<T>) -> core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>> {\n    let mut _0: core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>;\n    let  _2: ();\n    let mut _3: &sys::sync::rwlock::futex::RwLock;\n    debug self => _1;\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::sync::rwlock::futex::RwLock);\n        _2 = sys::sync::rwlock::futex::RwLock::write(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = sync::poison::rwlock::RwLockWriteGuard::<'_, T>::new(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Locks this `RwLock` with exclusive write access, blocking the current\n thread until it can be acquired.\n\n This function will not return while other writers or other readers\n currently have access to the lock.\n\n Returns an RAII guard which will drop the write access of this `RwLock`\n when dropped.\n\n # Errors\n\n This function will return an error if the `RwLock` is poisoned. An\n `RwLock` is poisoned whenever a writer panics while holding an exclusive\n lock. An error will be returned when the lock is acquired. The acquired\n lock guard will be contained in the returned error.\n\n # Panics\n\n This function might panic when called if the lock is already held by the current thread.\n\n # Examples\n\n ```\n use std::sync::RwLock;\n\n let lock = RwLock::new(1);\n\n let mut n = lock.write().unwrap();\n *n = 2;\n\n assert!(lock.try_read().is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}