{
  "name": "<sys::fs::unix::File as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::debug_struct": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.\n\n [`fmt::Debug`]: self::Debug\n\n # Examples\n\n ```rust\n use std::fmt;\n use std::net::Ipv4Addr;\n\n struct Foo {\n     bar: i32,\n     baz: String,\n     addr: Ipv4Addr,\n }\n\n impl fmt::Debug for Foo {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Foo\")\n             .field(\"bar\", &self.bar)\n             .field(\"baz\", &self.baz)\n             .field(\"addr\", &format_args!(\"{}\", self.addr))\n             .finish()\n     }\n }\n\n assert_eq!(\n     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n     format!(\"{:?}\", Foo {\n         bar: 10,\n         baz: \"Hello World\".to_string(),\n         addr: Ipv4Addr::new(127, 0, 0, 1),\n     })\n );\n ```\n",
      "adt": {}
    },
    "core::fmt::DebugStruct::<'a, 'b>::field": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new field to the generated struct output.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     another: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar) // We add `bar` field.\n            .field(\"another\", &self.another) // We add `another` field.\n            // We even add a field which doesn't exist (because why not?).\n            .field(\"nonexistent_field\", &1)\n            .finish() // We're good to go!\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, another: \"Hello World\", nonexistent_field: 1 }\"#,\n );\n ```\n",
      "adt": {}
    },
    "<sys::fs::unix::File as core::fmt::Debug>::fmt::get_path": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "path::PathBuf": "Constructor"
      }
    },
    "<sys::fs::unix::File as core::fmt::Debug>::fmt::get_mode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::finish": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finishes output and returns any error encountered.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     baz: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar)\n            .field(\"baz\", &self.baz)\n            .finish() // You need to call it to \"finish\" the\n                      // struct formatting.\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, baz: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, baz: \"Hello World\" }\"#,\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::fs::unix::File": [
      "Ref"
    ],
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::fmt::DebugStruct": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1226, kind: RigidTy(Adt(AdtDef(DefId { id: 5561, name: \"path::PathBuf\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15681, kind: RigidTy(Tuple([Ty { id: 128, kind: RigidTy(Bool) }, Ty { id: 128, kind: RigidTy(Bool) }])) }), Field(0, Ty { id: 128, kind: RigidTy(Bool) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15681, kind: RigidTy(Tuple([Ty { id: 128, kind: RigidTy(Bool) }, Ty { id: 128, kind: RigidTy(Bool) }])) }), Field(1, Ty { id: 128, kind: RigidTy(Bool) })])"
    ],
    "path::PathBuf": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<sys::fs::unix::File as core::fmt::Debug>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1837:5: 1935:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        #[cfg(any(target_os = \"linux\", target_os = \"illumos\", target_os = \"solaris\"))]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut p = PathBuf::from(\"/proc/self/fd\");\n            p.push(&fd.to_string());\n            run_path_with_cstr(&p, &readlink).ok()\n        }\n\n        #[cfg(any(target_vendor = \"apple\", target_os = \"netbsd\"))]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n            // is inevitable in this case because Apple targets and NetBSD define `fcntl`\n            // with `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n            // alternatives. If a better method is invented, it should be used\n            // instead.\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n            if n == -1 {\n                cfg_select! {\n                    target_os = \"netbsd\" => {\n                        // fallback to procfs as last resort\n                        let mut p = PathBuf::from(\"/proc/self/fd\");\n                        p.push(&fd.to_string());\n                        return run_path_with_cstr(&p, &readlink).ok()\n                    }\n                    _ => {\n                        return None;\n                    }\n                }\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            buf.shrink_to_fit();\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(target_os = \"freebsd\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let info = Box::<libc::kinfo_file>::new_zeroed();\n            let mut info = unsafe { info.assume_init() };\n            info.kf_structsize = size_of::<libc::kinfo_file>() as libc::c_int;\n            let n = unsafe { libc::fcntl(fd, libc::F_KINFO, &mut *info) };\n            if n == -1 {\n                return None;\n            }\n            let buf = unsafe { CStr::from_ptr(info.kf_path.as_mut_ptr()).to_bytes().to_vec() };\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(target_os = \"vxworks\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n            if n == -1 {\n                return None;\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(not(any(\n            target_os = \"linux\",\n            target_os = \"vxworks\",\n            target_os = \"freebsd\",\n            target_os = \"netbsd\",\n            target_os = \"illumos\",\n            target_os = \"solaris\",\n            target_vendor = \"apple\",\n        )))]\n        fn get_path(_fd: c_int) -> Option<PathBuf> {\n            // FIXME(#24570): implement this for other Unix platforms\n            None\n        }\n\n        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n            if mode == -1 {\n                return None;\n            }\n            match mode & libc::O_ACCMODE {\n                libc::O_RDONLY => Some((true, false)),\n                libc::O_RDWR => Some((true, true)),\n                libc::O_WRONLY => Some((false, true)),\n                _ => None,\n            }\n        }\n\n        let fd = self.as_raw_fd();\n        let mut b = f.debug_struct(\"File\");\n        b.field(\"fd\", &fd);\n        if let Some(path) = get_path(fd) {\n            b.field(\"path\", &path);\n        }\n        if let Some((read, write)) = get_mode(fd) {\n            b.field(\"read\", &read).field(\"write\", &write);\n        }\n        b.finish()\n    }",
  "mir": "fn <sys::fs::unix::File as core::fmt::Debug>::fmt(_1: &sys::fs::unix::File, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let  _3: i32;\n    let mut _4: core::fmt::DebugStruct<'_, '_>;\n    let mut _5: &str;\n    let  _6: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _7: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _8: &str;\n    let mut _9: &dyn core::fmt::Debug;\n    let  _10: &i32;\n    let mut _11: core::option::Option<path::PathBuf>;\n    let mut _12: isize;\n    let  _13: path::PathBuf;\n    let  _14: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _15: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _16: &str;\n    let mut _17: &dyn core::fmt::Debug;\n    let  _18: &path::PathBuf;\n    let mut _19: core::option::Option<(bool, bool)>;\n    let mut _20: isize;\n    let  _21: bool;\n    let  _22: bool;\n    let  _23: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _24: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _25: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _26: &str;\n    let mut _27: &dyn core::fmt::Debug;\n    let  _28: &bool;\n    let mut _29: &str;\n    let mut _30: &dyn core::fmt::Debug;\n    let  _31: &bool;\n    let mut _32: &mut core::fmt::DebugStruct<'_, '_>;\n    debug self => _1;\n    debug f => _2;\n    debug fd => _3;\n    debug b => _4;\n    debug path => _13;\n    debug read => _21;\n    debug write => _22;\n    bb0: {\n        _3 = <sys::fs::unix::File as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = \"File\";\n        _4 = core::fmt::Formatter::<'_>::debug_struct(_2, move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut _4;\n        StorageLive(_8);\n        _8 = \"fd\";\n        StorageLive(_9);\n        _10 = &_3;\n        _9 = _10 as &dyn core::fmt::Debug;\n        _6 = core::fmt::DebugStruct::<'_, '_>::field(move _7, move _8, move _9) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_11);\n        _11 = <sys::fs::unix::File as core::fmt::Debug>::fmt::get_path(_3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _12 = discriminant(_11);\n        switchInt(move _12) -> [1: bb5, 0: bb16, otherwise: bb17];\n    }\n    bb5: {\n        StorageLive(_13);\n        _13 = move ((_11 as variant#1).0: path::PathBuf);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _4;\n        StorageLive(_16);\n        _16 = \"path\";\n        StorageLive(_17);\n        _18 = &_13;\n        _17 = _18 as &dyn core::fmt::Debug;\n        _14 = core::fmt::DebugStruct::<'_, '_>::field(move _15, move _16, move _17) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        drop(_13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_11);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_19);\n        _19 = <sys::fs::unix::File as core::fmt::Debug>::fmt::get_mode(_3) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _20 = discriminant(_19);\n        switchInt(move _20) -> [1: bb10, 0: bb13, otherwise: bb17];\n    }\n    bb10: {\n        StorageLive(_21);\n        _21 = (((_19 as variant#1).0: (bool, bool)).0: bool);\n        StorageLive(_22);\n        _22 = (((_19 as variant#1).0: (bool, bool)).1: bool);\n        StorageLive(_23);\n        StorageLive(_25);\n        _25 = &mut _4;\n        StorageLive(_26);\n        _26 = \"read\";\n        StorageLive(_27);\n        _28 = &_21;\n        _27 = _28 as &dyn core::fmt::Debug;\n        _24 = core::fmt::DebugStruct::<'_, '_>::field(move _25, move _26, move _27) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_29);\n        _29 = \"write\";\n        StorageLive(_30);\n        _31 = &_22;\n        _30 = _31 as &dyn core::fmt::Debug;\n        _23 = core::fmt::DebugStruct::<'_, '_>::field(_24, move _29, move _30) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_19);\n        goto -> bb14;\n    }\n    bb13: {\n        StorageDead(_19);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_32);\n        _32 = &mut _4;\n        _0 = core::fmt::DebugStruct::<'_, '_>::finish(move _32) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_32);\n        StorageDead(_4);\n        return;\n    }\n    bb16: {\n        StorageDead(_11);\n        goto -> bb8;\n    }\n    bb17: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}