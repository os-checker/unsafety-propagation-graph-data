{
  "name": "sync::poison::condvar::Condvar::wait_timeout",
  "safe": true,
  "callees": {
    "sync::poison::mutex::guard_lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " For use in [`nonpoison::condvar`](super::condvar).\n",
      "adt": {
        "sync::poison::mutex::MutexGuard": "ImmutableAsArgument"
      }
    },
    "sys::sync::condvar::futex::Condvar::wait_timeout": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::sync::mutex::futex::Mutex": "ImmutableAsArgument",
        "sys::sync::condvar::futex::Condvar": "ImmutableAsArgument"
      }
    },
    "sync::poison::mutex::guard_poison": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " For use in [`nonpoison::condvar`](super::condvar).\n",
      "adt": {
        "sync::poison::mutex::MutexGuard": "ImmutableAsArgument"
      }
    },
    "sync::poison::Flag::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::poison::Flag": "ImmutableAsArgument"
      }
    },
    "sync::poison::PoisonError::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a `PoisonError`.\n\n This is generally created by methods like [`Mutex::lock`](crate::sync::Mutex::lock)\n or [`RwLock::read`](crate::sync::RwLock::read).\n\n This method may panic if std was built with `panic=\"abort\"`.\n",
      "adt": {
        "sync::poison::PoisonError": "Constructor"
      }
    }
  },
  "adts": {
    "sync::poison::mutex::MutexGuard": [
      "Ref",
      "Plain"
    ],
    "sys::sync::mutex::futex::Mutex": [
      "Ref"
    ],
    "sys::sync::condvar::futex::Condvar": [
      "Ref"
    ],
    "sync::poison::condvar::Condvar": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::time::Duration": [
      "Plain"
    ],
    "sync::poison::Flag": [
      "Ref"
    ],
    "sync::WaitTimeoutResult": [
      "Plain",
      "Unknown([Field(0, Ty { id: 128, kind: RigidTy(Bool) })])",
      "Unknown([Field(1, Ty { id: 11761, kind: RigidTy(Adt(AdtDef(DefId { id: 9778, name: \"sync::WaitTimeoutResult\" }), GenericArgs([]))) })])"
    ],
    "sync::poison::PoisonError": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 3196,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/condvar.rs:323:5: 334:6",
  "src": "pub fn wait_timeout<'a, T>(\n        &self,\n        guard: MutexGuard<'a, T>,\n        dur: Duration,\n    ) -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n        let (poisoned, result) = unsafe {\n            let lock = mutex::guard_lock(&guard);\n            let success = self.inner.wait_timeout(lock, dur);\n            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n        };\n        if poisoned { Err(PoisonError::new((guard, result))) } else { Ok((guard, result)) }\n    }",
  "mir": "fn sync::poison::condvar::Condvar::wait_timeout(_1: &sync::poison::condvar::Condvar, _2: sync::poison::mutex::MutexGuard<'_, T>, _3: core::time::Duration) -> core::result::Result<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult), sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>> {\n    let mut _0: core::result::Result<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult), sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>>;\n    let  _4: bool;\n    let  _5: sync::WaitTimeoutResult;\n    let mut _6: (bool, sync::WaitTimeoutResult);\n    let  _7: &sys::sync::mutex::futex::Mutex;\n    let  _8: &sync::poison::mutex::MutexGuard<'_, T>;\n    let  _9: bool;\n    let mut _10: &sys::sync::condvar::futex::Condvar;\n    let mut _11: bool;\n    let  _12: &sync::poison::Flag;\n    let  _13: &sync::poison::mutex::MutexGuard<'_, T>;\n    let mut _14: sync::WaitTimeoutResult;\n    let mut _15: bool;\n    let mut _16: sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>;\n    let mut _17: (sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult);\n    let mut _18: (sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult);\n    debug self => _1;\n    debug guard => _2;\n    debug dur => _3;\n    debug poisoned => _4;\n    debug result => _5;\n    debug lock => _7;\n    debug success => _9;\n    bb0: {\n        StorageLive(_6);\n        _8 = &_2;\n        _7 = sync::poison::mutex::guard_lock::<T>(_8) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_10);\n        _10 = &((*_1).0: sys::sync::condvar::futex::Condvar);\n        _9 = sys::sync::condvar::futex::Condvar::wait_timeout(move _10, _7, _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _13 = &_2;\n        _12 = sync::poison::mutex::guard_poison::<T>(_13) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _11 = sync::poison::Flag::get(_12) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = Not(_9);\n        _14 = WaitTimeoutResult(move _15);\n        StorageDead(_15);\n        _6 = (move _11, move _14);\n        StorageDead(_14);\n        StorageDead(_11);\n        _4 = (_6.0: bool);\n        _5 = (_6.1: sync::WaitTimeoutResult);\n        StorageDead(_6);\n        switchInt(_4) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (_2, _5);\n        _16 = sync::poison::PoisonError::<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>::new(move _17) -> unwind unreachable;\n    }\n    bb6: {\n        StorageLive(_18);\n        _18 = (_2, _5);\n        _0 = core::result::Result::Ok(move _18);\n        StorageDead(_18);\n        return;\n    }\n}\n",
  "doc": " Waits on this condition variable for a notification, timing out after a\n specified duration.\n\n The semantics of this function are equivalent to [`wait`] except that\n the thread will be blocked for roughly no longer than `dur`. This\n method should not be used for precise timing due to anomalies such as\n preemption or platform differences that might not cause the maximum\n amount of time waited to be precisely `dur`.\n\n Note that the best effort is made to ensure that the time waited is\n measured with a monotonic clock, and not affected by the changes made to\n the system time. This function is susceptible to spurious wakeups.\n Condition variables normally have a boolean predicate associated with\n them, and the predicate must always be checked each time this function\n returns to protect against spurious wakeups. Furthermore, since the timeout\n is given relative to the moment this function is called, it needs to be adjusted\n when this function is called in a loop. The [`wait_timeout_while`] method\n lets you wait with a timeout while a predicate is true, taking care of all these concerns.\n\n The returned [`WaitTimeoutResult`] value indicates if the timeout is\n known to have elapsed.\n\n Like [`wait`], the lock specified will be re-acquired when this function\n returns, regardless of whether the timeout elapsed or not.\n\n [`wait`]: Self::wait\n [`wait_timeout_while`]: Self::wait_timeout_while\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex, Condvar};\n use std::thread;\n use std::time::Duration;\n\n let pair = Arc::new((Mutex::new(false), Condvar::new()));\n let pair2 = Arc::clone(&pair);\n\n thread::spawn(move || {\n     let (lock, cvar) = &*pair2;\n     let mut started = lock.lock().unwrap();\n     *started = true;\n     // We notify the condvar that the value has changed.\n     cvar.notify_one();\n });\n\n // wait for the thread to start up\n let (lock, cvar) = &*pair;\n let mut started = lock.lock().unwrap();\n // as long as the value inside the `Mutex<bool>` is `false`, we wait\n loop {\n     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n     // 10 milliseconds have passed, or maybe the value changed!\n     started = result.0;\n     if *started == true {\n         // We received the notification and the value has been updated, we can leave.\n         break\n     }\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}