{
  "name": "backtrace_rs::symbolize::gimli::elf::locate_build_id",
  "safe": true,
  "callees": {
    "backtrace_rs::symbolize::gimli::elf::debug_path_exists": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String` with at least the specified capacity.\n\n `String`s have an internal buffer to hold their data. The capacity is\n the length of that buffer, and can be queried with the [`capacity`]\n method. This method creates an empty `String`, but one with an initial\n buffer that can hold at least `capacity` bytes. This is useful when you\n may be appending a bunch of data to the `String`, reducing the number of\n reallocations it needs to do.\n\n [`capacity`]: String::capacity\n\n If the given capacity is `0`, no allocation will occur, and this method\n is identical to the [`new`] method.\n\n [`new`]: String::new\n\n # Panics\n\n Panics if the capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::with_capacity(10);\n\n // The String contains no chars, even though it has capacity for more\n assert_eq!(s.len(), 0);\n\n // These are all done without reallocating...\n let cap = s.capacity();\n for _ in 0..10 {\n     s.push('a');\n }\n\n assert_eq!(s.capacity(), cap);\n\n // ...but this may make the string reallocate\n s.push('a');\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::push_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends a given string slice onto the end of this `String`.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::from(\"foo\");\n\n s.push_str(\"bar\");\n\n assert_eq!(\"foobar\", s);\n ```\n",
      "adt": {}
    },
    "core::char::methods::<impl char>::from_digit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a digit in the given radix to a `char`.\n\n A 'radix' here is sometimes also called a 'base'. A radix of two\n indicates a binary number, a radix of ten, decimal, and a radix of\n sixteen, hexadecimal, to give some common values. Arbitrary\n radices are supported.\n\n `from_digit()` will return `None` if the input is not a digit in\n the given radix.\n\n # Panics\n\n Panics if given a radix larger than 36.\n\n # Examples\n\n Basic usage:\n\n ```\n let c = char::from_digit(4, 10);\n\n assert_eq!(Some('4'), c);\n\n // Decimal 11 is a single digit in base 16\n let c = char::from_digit(11, 16);\n\n assert_eq!(Some('b'), c);\n ```\n\n Returning `None` when the input is not a digit:\n\n ```\n let c = char::from_digit(20, 10);\n\n assert_eq!(None, c);\n ```\n\n Passing a large radix, causing a panic:\n\n ```should_panic\n // this panics\n let _c = char::from_digit(1, 37);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends the given [`char`] to the end of this `String`.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::from(\"abc\");\n\n s.push('1');\n s.push('2');\n s.push('3');\n\n assert_eq!(\"abc123\", s);\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::Shr::shr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `>>` operation.\n\n # Examples\n\n ```\n assert_eq!(5u8 >> 1, 2);\n assert_eq!(2u8 >> 1, 1);\n ```\n",
      "adt": {}
    },
    "core::ops::BitAnd::bitand": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `&` operation.\n\n # Examples\n\n ```\n assert_eq!(true & false, false);\n assert_eq!(true & true, true);\n assert_eq!(5u8 & 1u8, 1);\n assert_eq!(5u8 & 2u8, 0);\n ```\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) })])"
    ],
    "alloc_crate::string::String": [
      "Plain",
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3103, kind: RigidTy(Char) })])"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "path::PathBuf": [
      "Plain"
    ]
  },
  "path": 494,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:425:1: 449:2",
  "src": "fn locate_build_id(build_id: &[u8]) -> Option<PathBuf> {\n    const BUILD_ID_PATH: &str = \"/usr/lib/debug/.build-id/\";\n    const BUILD_ID_SUFFIX: &str = \".debug\";\n\n    if build_id.len() < 2 {\n        return None;\n    }\n\n    if !debug_path_exists() {\n        return None;\n    }\n\n    let mut path =\n        String::with_capacity(BUILD_ID_PATH.len() + BUILD_ID_SUFFIX.len() + build_id.len() * 2 + 1);\n    path.push_str(BUILD_ID_PATH);\n    path.push(char::from_digit((build_id[0] >> 4) as u32, 16)?);\n    path.push(char::from_digit((build_id[0] & 0xf) as u32, 16)?);\n    path.push('/');\n    for byte in &build_id[1..] {\n        path.push(char::from_digit((byte >> 4) as u32, 16)?);\n        path.push(char::from_digit((byte & 0xf) as u32, 16)?);\n    }\n    path.push_str(BUILD_ID_SUFFIX);\n    Some(PathBuf::from(path))\n}",
  "mir": "fn backtrace_rs::symbolize::gimli::elf::locate_build_id(_1: &[u8]) -> core::option::Option<path::PathBuf> {\n    let mut _0: core::option::Option<path::PathBuf>;\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: bool;\n    let mut _5: alloc_crate::string::String;\n    let mut _6: usize;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: usize;\n    let mut _10: &str;\n    let mut _11: usize;\n    let mut _12: &str;\n    let mut _13: (usize, bool);\n    let mut _14: usize;\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let mut _17: (usize, bool);\n    let mut _18: (usize, bool);\n    let  _19: ();\n    let mut _20: &mut alloc_crate::string::String;\n    let mut _21: &str;\n    let  _22: ();\n    let mut _23: &mut alloc_crate::string::String;\n    let mut _24: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, char>;\n    let mut _25: core::option::Option<char>;\n    let mut _26: u32;\n    let mut _27: u8;\n    let mut _28: u8;\n    let  _29: usize;\n    let mut _30: usize;\n    let mut _31: bool;\n    let mut _32: u32;\n    let mut _33: bool;\n    let mut _34: isize;\n    let  _35: char;\n    let  _36: ();\n    let mut _37: &mut alloc_crate::string::String;\n    let mut _38: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, char>;\n    let mut _39: core::option::Option<char>;\n    let mut _40: u32;\n    let mut _41: u8;\n    let mut _42: u8;\n    let  _43: usize;\n    let mut _44: usize;\n    let mut _45: bool;\n    let mut _46: isize;\n    let  _47: char;\n    let  _48: ();\n    let mut _49: &mut alloc_crate::string::String;\n    let mut _50: core::slice::Iter<'_, u8>;\n    let  _51: &[u8];\n    let mut _52: core::ops::RangeFrom<usize>;\n    let mut _53: core::slice::Iter<'_, u8>;\n    let mut _54: core::option::Option<&u8>;\n    let mut _55: &mut core::slice::Iter<'_, u8>;\n    let mut _56: isize;\n    let  _57: &u8;\n    let  _58: ();\n    let mut _59: &mut alloc_crate::string::String;\n    let mut _60: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, char>;\n    let mut _61: core::option::Option<char>;\n    let mut _62: u32;\n    let mut _63: u8;\n    let mut _64: isize;\n    let  _65: char;\n    let  _66: ();\n    let mut _67: &mut alloc_crate::string::String;\n    let mut _68: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, char>;\n    let mut _69: core::option::Option<char>;\n    let mut _70: u32;\n    let mut _71: u8;\n    let mut _72: isize;\n    let  _73: char;\n    let  _74: ();\n    let mut _75: &mut alloc_crate::string::String;\n    let mut _76: &str;\n    let mut _77: path::PathBuf;\n    let mut _78: alloc_crate::string::String;\n    debug build_id => _1;\n    debug path => _5;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _35;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _47;\n    debug iter => _53;\n    debug byte => _57;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _65;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _73;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = PtrMetadata(_1);\n        _2 = Lt(move _3, 2_usize);\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = core::option::Option::None;\n        StorageDead(_2);\n        goto -> bb56;\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_4);\n        _4 = backtrace_rs::symbolize::gimli::elf::debug_path_exists() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _4) -> [0: bb4, otherwise: bb5];\n    }\n    bb4: {\n        _0 = core::option::Option::None;\n        StorageDead(_4);\n        goto -> bb56;\n    }\n    bb5: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = backtrace_rs::symbolize::gimli::elf::locate_build_id::BUILD_ID_PATH;\n        _9 = core::str::<impl str>::len(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = backtrace_rs::symbolize::gimli::elf::locate_build_id::BUILD_ID_SUFFIX;\n        _11 = core::str::<impl str>::len(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        _13 = CheckedAdd(_9, _11);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _9, move _11) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _8 = move (_13.0: usize);\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = PtrMetadata(_1);\n        _16 = CheckedMul(_15, 2_usize);\n        assert(!move (_16.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _15, 2_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _14 = move (_16.0: usize);\n        StorageDead(_15);\n        _17 = CheckedAdd(_8, _14);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _8, move _14) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _7 = move (_17.0: usize);\n        StorageDead(_14);\n        StorageDead(_8);\n        _18 = CheckedAdd(_7, 1_usize);\n        assert(!move (_18.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _7, 1_usize) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _6 = move (_18.0: usize);\n        StorageDead(_7);\n        _5 = alloc_crate::string::String::with_capacity(move _6) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_6);\n        StorageLive(_20);\n        _20 = &mut _5;\n        StorageLive(_21);\n        _21 = backtrace_rs::symbolize::gimli::elf::locate_build_id::BUILD_ID_PATH;\n        _19 = alloc_crate::string::String::push_str(move _20, move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = &mut _5;\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = 0_usize;\n        _30 = PtrMetadata(_1);\n        _31 = Lt(_29, _30);\n        assert(move _31, \"index out of bounds: the length is {} but the index is {}\", move _30, _29) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _28 = (*_1)[_29];\n        _32 = 4_i32 as u32;\n        _33 = Lt(move _32, 8_u32);\n        assert(move _33, \"attempt to shift right by `{}`, which would overflow\", 4_i32) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _27 = Shr(move _28, 4_i32);\n        StorageDead(_28);\n        _26 = move _27 as u32;\n        StorageDead(_27);\n        _25 = core::char::methods::<impl char>::from_digit(move _26, 16_u32) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        _24 = <core::option::Option<char> as core::ops::Try>::branch(move _25) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_25);\n        _34 = discriminant(_24);\n        switchInt(move _34) -> [0: bb19, 1: bb20, otherwise: bb18];\n    }\n    bb18: {\n        unreachable;\n    }\n    bb19: {\n        _35 = ((_24 as variant#0).0: char);\n        _22 = alloc_crate::string::String::push(move _23, _35) -> [return: bb22, unwind unreachable];\n    }\n    bb20: {\n        _0 = <core::option::Option<path::PathBuf> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_23);\n        StorageDead(_29);\n        StorageDead(_24);\n        goto -> bb54;\n    }\n    bb22: {\n        StorageDead(_23);\n        StorageDead(_29);\n        StorageDead(_24);\n        StorageLive(_37);\n        _37 = &mut _5;\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = 0_usize;\n        _44 = PtrMetadata(_1);\n        _45 = Lt(_43, _44);\n        assert(move _45, \"index out of bounds: the length is {} but the index is {}\", move _44, _43) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _42 = (*_1)[_43];\n        _41 = BitAnd(move _42, 15_u8);\n        StorageDead(_42);\n        _40 = move _41 as u32;\n        StorageDead(_41);\n        _39 = core::char::methods::<impl char>::from_digit(move _40, 16_u32) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_40);\n        _38 = <core::option::Option<char> as core::ops::Try>::branch(move _39) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_39);\n        _46 = discriminant(_38);\n        switchInt(move _46) -> [0: bb26, 1: bb27, otherwise: bb18];\n    }\n    bb26: {\n        _47 = ((_38 as variant#0).0: char);\n        _36 = alloc_crate::string::String::push(move _37, _47) -> [return: bb29, unwind unreachable];\n    }\n    bb27: {\n        _0 = <core::option::Option<path::PathBuf> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_37);\n        StorageDead(_43);\n        StorageDead(_38);\n        goto -> bb54;\n    }\n    bb29: {\n        StorageDead(_37);\n        StorageDead(_43);\n        StorageDead(_38);\n        StorageLive(_49);\n        _49 = &mut _5;\n        _48 = alloc_crate::string::String::push(move _49, '/') -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_49);\n        StorageLive(_50);\n        StorageLive(_52);\n        _52 = RangeFrom(1_usize);\n        _51 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_1, move _52) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_52);\n        _50 = <&[u8] as core::iter::IntoIterator>::into_iter(_51) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageLive(_53);\n        _53 = move _50;\n        goto -> bb33;\n    }\n    bb33: {\n        StorageLive(_54);\n        _55 = &mut _53;\n        _54 = <core::slice::Iter<'_, u8> as core::iter::Iterator>::next(_55) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _56 = discriminant(_54);\n        switchInt(move _56) -> [0: bb36, 1: bb35, otherwise: bb18];\n    }\n    bb35: {\n        _57 = ((_54 as variant#1).0: &u8);\n        StorageLive(_59);\n        _59 = &mut _5;\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = <&u8 as core::ops::Shr<i32>>::shr(_57, 4_i32) -> [return: bb37, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageDead(_50);\n        StorageLive(_75);\n        _75 = &mut _5;\n        StorageLive(_76);\n        _76 = backtrace_rs::symbolize::gimli::elf::locate_build_id::BUILD_ID_SUFFIX;\n        _74 = alloc_crate::string::String::push_str(move _75, move _76) -> [return: bb51, unwind unreachable];\n    }\n    bb37: {\n        _62 = move _63 as u32;\n        StorageDead(_63);\n        _61 = core::char::methods::<impl char>::from_digit(move _62, 16_u32) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_62);\n        _60 = <core::option::Option<char> as core::ops::Try>::branch(move _61) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_61);\n        _64 = discriminant(_60);\n        switchInt(move _64) -> [0: bb40, 1: bb41, otherwise: bb18];\n    }\n    bb40: {\n        _65 = ((_60 as variant#0).0: char);\n        _58 = alloc_crate::string::String::push(move _59, _65) -> [return: bb43, unwind unreachable];\n    }\n    bb41: {\n        _0 = <core::option::Option<path::PathBuf> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_59);\n        StorageDead(_60);\n        goto -> bb53;\n    }\n    bb43: {\n        StorageDead(_59);\n        StorageDead(_60);\n        StorageLive(_67);\n        _67 = &mut _5;\n        StorageLive(_68);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = <&u8 as core::ops::BitAnd<u8>>::bitand(_57, 15_u8) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _70 = move _71 as u32;\n        StorageDead(_71);\n        _69 = core::char::methods::<impl char>::from_digit(move _70, 16_u32) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_70);\n        _68 = <core::option::Option<char> as core::ops::Try>::branch(move _69) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_69);\n        _72 = discriminant(_68);\n        switchInt(move _72) -> [0: bb47, 1: bb48, otherwise: bb18];\n    }\n    bb47: {\n        _73 = ((_68 as variant#0).0: char);\n        _66 = alloc_crate::string::String::push(move _67, _73) -> [return: bb50, unwind unreachable];\n    }\n    bb48: {\n        _0 = <core::option::Option<path::PathBuf> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_67);\n        StorageDead(_68);\n        goto -> bb53;\n    }\n    bb50: {\n        StorageDead(_67);\n        StorageDead(_68);\n        StorageDead(_54);\n        goto -> bb33;\n    }\n    bb51: {\n        StorageDead(_76);\n        StorageDead(_75);\n        StorageLive(_77);\n        StorageLive(_78);\n        _78 = move _5;\n        _77 = <path::PathBuf as core::convert::From<alloc_crate::string::String>>::from(move _78) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_78);\n        _0 = core::option::Option::Some(move _77);\n        StorageDead(_77);\n        StorageDead(_5);\n        goto -> bb56;\n    }\n    bb53: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageDead(_50);\n        goto -> bb54;\n    }\n    bb54: {\n        drop(_5) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_5);\n        goto -> bb56;\n    }\n    bb56: {\n        return;\n    }\n}\n",
  "doc": " Locate a debug file based on its build ID.\n\n The format of build id paths is documented at:\n https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}