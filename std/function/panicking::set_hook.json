{
  "name": "panicking::set_hook",
  "safe": true,
  "callees": {
    "thread::functions::panicking": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether the current thread is unwinding because of panic.\n\n A common use of this feature is to poison shared resources when writing\n unsafe code, by checking `panicking` when the `drop` is called.\n\n This is usually not needed when writing safe code, as [`Mutex`es][Mutex]\n already poison themselves when a thread panics while holding the lock.\n\n This can also be used in multithreaded applications, in order to send a\n message to other threads warning that a thread has panicked (e.g., for\n monitoring purposes).\n\n # Examples\n\n ```should_panic\n use std::thread;\n\n struct SomeStruct;\n\n impl Drop for SomeStruct {\n     fn drop(&mut self) {\n         if thread::panicking() {\n             println!(\"dropped while unwinding\");\n         } else {\n             println!(\"dropped while not unwinding\");\n         }\n     }\n }\n\n {\n     print!(\"a: \");\n     let a = SomeStruct;\n }\n\n {\n     print!(\"b: \");\n     let b = SomeStruct;\n     panic!()\n }\n ```\n\n [Mutex]: crate::sync::Mutex\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "sync::nonpoison::rwlock::RwLock::<T>::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Replaces the contained value with `value`, and returns the old contained value.\n\n # Examples\n\n ```\n #![feature(nonpoison_rwlock)]\n #![feature(lock_value_accessors)]\n\n use std::sync::nonpoison::RwLock;\n\n let mut lock = RwLock::new(7);\n\n assert_eq!(lock.replace(11), 7);\n assert_eq!(lock.get_cloned(), 11);\n ```\n",
      "adt": {
        "sync::nonpoison::rwlock::RwLock": "ImmutableAsArgument"
      }
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Arguments": [
      "Plain"
    ],
    "sync::nonpoison::rwlock::RwLock": [
      "Ref"
    ],
    "panicking::Hook": [
      "Plain"
    ],
    "alloc_crate::boxed::Box": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::panicking::set_hook"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:142:1: 150:2",
  "src": "pub fn set_hook(hook: Box<dyn Fn(&PanicHookInfo<'_>) + 'static + Sync + Send>) {\n    if thread::panicking() {\n        panic!(\"cannot modify the panic hook from a panicking thread\");\n    }\n\n    // Drop the old hook after changing the hook to avoid deadlocking if its\n    // destructor panics.\n    drop(HOOK.replace(Hook::Custom(hook)));\n}",
  "mir": "fn panicking::set_hook(_1: alloc_crate::boxed::Box<dyn for<'a, 'b> core::ops::Fn(&'a panic::PanicHookInfo<'b>) + core::marker::Send + core::marker::Sync>) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let  _3: !;\n    let mut _4: core::fmt::Arguments<'_>;\n    let  _5: ();\n    let mut _6: panicking::Hook;\n    let mut _7: &sync::nonpoison::rwlock::RwLock<panicking::Hook>;\n    let mut _8: panicking::Hook;\n    debug hook => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = thread::functions::panicking() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = core::fmt::Arguments::<'_>::from_str(\"cannot modify the panic hook from a panicking thread\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _3 = core::panicking::panic_fmt(move _4) -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_2);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = {alloc632: &sync::nonpoison::rwlock::RwLock<panicking::Hook>};\n        StorageLive(_8);\n        _8 = panicking::Hook::Custom(_1);\n        _6 = sync::nonpoison::rwlock::RwLock::<panicking::Hook>::replace(move _7, move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _5 = core::mem::drop::<panicking::Hook>(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Registers a custom panic hook, replacing the previously registered hook.\n\n The panic hook is invoked when a thread panics, but before the panic runtime\n is invoked. As such, the hook will run with both the aborting and unwinding\n runtimes.\n\n The default hook, which is registered at startup, prints a message to standard error and\n generates a backtrace if requested. This behavior can be customized using the `set_hook` function.\n The current hook can be retrieved while reinstating the default hook with the [`take_hook`]\n function.\n\n [`take_hook`]: ./fn.take_hook.html\n\n The hook is provided with a `PanicHookInfo` struct which contains information\n about the origin of the panic, including the payload passed to `panic!` and\n the source code location from which the panic originated.\n\n The panic hook is a global resource.\n\n # Panics\n\n Panics if called from a panicking thread.\n\n # Examples\n\n The following will print \"Custom panic hook\":\n\n ```should_panic\n use std::panic;\n\n panic::set_hook(Box::new(|_| {\n     println!(\"Custom panic hook\");\n }));\n\n panic!(\"Normal panic\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}