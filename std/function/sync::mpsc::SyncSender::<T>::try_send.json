{
  "name": "sync::mpsc::SyncSender::<T>::try_send",
  "safe": true,
  "callees": {
    "sync::mpmc::Sender::<T>::try_send": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to send a message into the channel without blocking.\n\n This method will either send a message into the channel immediately or return an error if\n the channel is full or disconnected. The returned error contains the original message.\n\n If called on a zero-capacity channel, this method will send the message only if there\n happens to be a receive operation on the other side of the channel at the same time.\n\n # Examples\n\n ```rust\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc::{channel, Receiver, Sender};\n\n let (sender, _receiver): (Sender<i32>, Receiver<i32>) = channel();\n\n assert!(sender.try_send(1).is_ok());\n ```\n",
      "adt": {
        "sync::mpmc::Sender": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sync::mpmc::Sender": [
      "Ref"
    ],
    "sync::mpsc::SyncSender": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::mpsc::SyncSender::<T>::try_send"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpsc.rs:731:5: 733:6",
  "src": "pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n        self.inner.try_send(t)\n    }",
  "mir": "fn sync::mpsc::SyncSender::<T>::try_send(_1: &sync::mpsc::SyncSender<T>, _2: T) -> core::result::Result<(), sync::mpsc::TrySendError<T>> {\n    let mut _0: core::result::Result<(), sync::mpsc::TrySendError<T>>;\n    let mut _3: &sync::mpmc::Sender<T>;\n    debug self => _1;\n    debug t => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: sync::mpmc::Sender<T>);\n        _0 = sync::mpmc::Sender::<T>::try_send(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Attempts to send a value on this channel without blocking.\n\n This method differs from [`send`] by returning immediately if the\n channel's buffer is full or no receiver is waiting to acquire some\n data. Compared with [`send`], this function has two failure cases\n instead of one (one for disconnection, one for a full buffer).\n\n See [`send`] for notes about guarantees of whether the\n receiver has received the data or not if this function is successful.\n\n [`send`]: Self::send\n\n # Examples\n\n ```rust\n use std::sync::mpsc::sync_channel;\n use std::thread;\n\n // Create a sync_channel with buffer size 1\n let (sync_sender, receiver) = sync_channel(1);\n let sync_sender2 = sync_sender.clone();\n\n // First thread owns sync_sender\n let handle1 = thread::spawn(move || {\n     sync_sender.send(1).unwrap();\n     sync_sender.send(2).unwrap();\n     // Thread blocked\n });\n\n // Second thread owns sync_sender2\n let handle2 = thread::spawn(move || {\n     // This will return an error and send\n     // no message if the buffer is full\n     let _ = sync_sender2.try_send(3);\n });\n\n let mut msg;\n msg = receiver.recv().unwrap();\n println!(\"message {msg} received\");\n\n msg = receiver.recv().unwrap();\n println!(\"message {msg} received\");\n\n // Third message may have never been sent\n match receiver.try_recv() {\n     Ok(msg) => println!(\"message {msg} received\"),\n     Err(_) => println!(\"the third message was never sent\"),\n }\n\n // Wait for threads to complete\n handle1.join().unwrap();\n handle2.join().unwrap();\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}