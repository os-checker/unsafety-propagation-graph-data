{
  "name": "sync::mpmc::utils::Backoff::spin_heavy",
  "safe": true,
  "callees": {
    "core::cell::Cell::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a copy of the contained value.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n\n let five = c.get();\n ```\n",
      "adt": {}
    },
    "core::num::<impl u32>::pow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Raises self to the power of `exp`, using exponentiation by squaring.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::hint::spin_loop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Emits a machine instruction to signal the processor that it is running in\n a busy-wait spin-loop (\"spin lock\").\n\n Upon receiving the spin-loop signal the processor can optimize its behavior by,\n for example, saving power or switching hyper-threads.\n\n This function is different from [`thread::yield_now`] which directly\n yields to the system's scheduler, whereas `spin_loop` does not interact\n with the operating system.\n\n A common use case for `spin_loop` is implementing bounded optimistic\n spinning in a CAS loop in synchronization primitives. To avoid problems\n like priority inversion, it is strongly recommended that the spin loop is\n terminated after a finite amount of iterations and an appropriate blocking\n syscall is made.\n\n **Note**: On platforms that do not support receiving spin-loop hints this\n function does not do anything at all.\n\n # Examples\n\n ```ignore-wasm\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::Arc;\n use std::{hint, thread};\n\n // A shared atomic value that threads will use to coordinate\n let live = Arc::new(AtomicBool::new(false));\n\n // In a background thread we'll eventually set the value\n let bg_work = {\n     let live = live.clone();\n     thread::spawn(move || {\n         // Do some work, then make the value live\n         do_some_work();\n         live.store(true, Ordering::Release);\n     })\n };\n\n // Back on our current thread, we wait for the value to be set\n while !live.load(Ordering::Acquire) {\n     // The spin loop is a hint to the CPU that we're waiting, but probably\n     // not for very long\n     hint::spin_loop();\n }\n\n // The value is now set\n # fn do_some_work() {}\n do_some_work();\n bg_work.join()?;\n # Ok::<(), Box<dyn core::any::Any + Send + 'static>>(())\n ```\n\n [`thread::yield_now`]: ../../std/thread/fn.yield_now.html\n",
      "adt": {}
    },
    "thread::functions::yield_now": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Cooperatively gives up a timeslice to the OS scheduler.\n\n This calls the underlying OS scheduler's yield primitive, signaling\n that the calling thread is willing to give up its remaining timeslice\n so that the OS may schedule other threads on the CPU.\n\n A drawback of yielding in a loop is that if the OS does not have any\n other ready threads to run on the current CPU, the thread will effectively\n busy-wait, which wastes CPU time and energy.\n\n Therefore, when waiting for events of interest, a programmer's first\n choice should be to use synchronization devices such as [`channel`]s,\n [`Condvar`]s, [`Mutex`]es or [`join`] since these primitives are\n implemented in a blocking manner, giving up the CPU until the event\n of interest has occurred which avoids repeated yielding.\n\n `yield_now` should thus be used only rarely, mostly in situations where\n repeated polling is required because there is no other suitable way to\n learn when an event of interest has occurred.\n\n # Examples\n\n ```\n use std::thread;\n\n thread::yield_now();\n ```\n\n [`channel`]: crate::sync::mpsc\n [`join`]: JoinHandle::join\n [`Condvar`]: crate::sync::Condvar\n [`Mutex`]: crate::sync::Mutex\n",
      "adt": {}
    },
    "core::cell::Cell::<T>::set": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the contained value.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n\n c.set(10);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::cell::Cell": [
      "Ref"
    ],
    "sync::mpmc::utils::Backoff": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2890,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/utils.rs:126:5: 136:6",
  "src": "pub fn spin_heavy(&self) {\n        if self.step.get() <= SPIN_LIMIT {\n            for _ in 0..self.step.get().pow(2) {\n                crate::hint::spin_loop()\n            }\n        } else {\n            crate::thread::yield_now();\n        }\n\n        self.step.set(self.step.get() + 1);\n    }",
  "mir": "fn sync::mpmc::utils::Backoff::spin_heavy(_1: &sync::mpmc::utils::Backoff) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: u32;\n    let mut _4: &core::cell::Cell<u32>;\n    let mut _5: core::ops::Range<u32>;\n    let mut _6: core::ops::Range<u32>;\n    let mut _7: u32;\n    let mut _8: u32;\n    let mut _9: &core::cell::Cell<u32>;\n    let mut _10: core::ops::Range<u32>;\n    let  _11: ();\n    let mut _12: core::option::Option<u32>;\n    let mut _13: &mut core::ops::Range<u32>;\n    let mut _14: isize;\n    let  _15: ();\n    let  _16: ();\n    let mut _17: &core::cell::Cell<u32>;\n    let mut _18: u32;\n    let mut _19: u32;\n    let mut _20: &core::cell::Cell<u32>;\n    let mut _21: (u32, bool);\n    debug self => _1;\n    debug iter => _10;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: core::cell::Cell<u32>);\n        _3 = core::cell::Cell::<u32>::get(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = Le(move _3, sync::mpmc::utils::SPIN_LIMIT);\n        switchInt(move _2) -> [0: bb12, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &((*_1).0: core::cell::Cell<u32>);\n        _8 = core::cell::Cell::<u32>::get(move _9) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        _7 = core::num::<impl u32>::pow(move _8, 2_u32) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _6 = Range(0_u32, move _7);\n        StorageDead(_7);\n        _5 = <core::ops::Range<u32> as core::iter::IntoIterator>::into_iter(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = move _5;\n        goto -> bb6;\n    }\n    bb6: {\n        StorageLive(_12);\n        _13 = &mut _10;\n        _12 = <core::ops::Range<u32> as core::iter::Iterator>::next(_13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = discriminant(_12);\n        switchInt(move _14) -> [0: bb10, 1: bb9, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        _11 = core::hint::spin_loop() -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_12);\n        StorageDead(_10);\n        StorageDead(_5);\n        goto -> bb13;\n    }\n    bb11: {\n        StorageDead(_12);\n        goto -> bb6;\n    }\n    bb12: {\n        StorageDead(_3);\n        _15 = thread::functions::yield_now() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_2);\n        StorageLive(_17);\n        _17 = &((*_1).0: core::cell::Cell<u32>);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &((*_1).0: core::cell::Cell<u32>);\n        _19 = core::cell::Cell::<u32>::get(move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        _21 = CheckedAdd(_19, 1_u32);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _19, 1_u32) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _18 = move (_21.0: u32);\n        StorageDead(_19);\n        _16 = core::cell::Cell::<u32>::set(move _17, move _18) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_18);\n        StorageDead(_17);\n        return;\n    }\n}\n",
  "doc": " Backs off using heavyweight spinning.\n\n This method should be used in blocking loops where parking the thread is not an option.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}