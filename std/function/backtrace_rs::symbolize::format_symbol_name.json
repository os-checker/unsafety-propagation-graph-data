{
  "name": "backtrace_rs::symbolize::format_symbol_name",
  "safe": true,
  "callees": {
    "core::str::from_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string slice.\n\n This is an alias to [`str::from_utf8`].\n\n A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n the two. Not all byte slices are valid string slices, however: [`&str`] requires\n that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n UTF-8, and then does the conversion.\n\n [`&str`]: str\n [byteslice]: slice\n\n If you are sure that the byte slice is valid UTF-8, and you don't want to\n incur the overhead of the validity check, there is an unsafe version of\n this function, [`from_utf8_unchecked`], which has the same\n behavior but skips the check.\n\n If you need a `String` instead of a `&str`, consider\n [`String::from_utf8`][string].\n\n [string]: ../../std/string/struct.String.html#method.from_utf8\n\n Because you can stack-allocate a `[u8; N]`, and you can take a\n [`&[u8]`][byteslice] of it, this function is one way to have a\n stack-allocated string. There is an example of this in the\n examples section below.\n\n [byteslice]: slice\n\n # Errors\n\n Returns `Err` if the slice is not UTF-8 with a description as to why the\n provided slice is not UTF-8.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n // We can use the ? (try) operator to check if the bytes are valid\n let sparkle_heart = str::from_utf8(&sparkle_heart)?;\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n # Ok::<_, str::Utf8Error>(())\n ```\n\n Incorrect bytes:\n\n ```\n use std::str;\n\n // some invalid bytes, in a vector\n let sparkle_heart = vec![0, 159, 146, 150];\n\n assert!(str::from_utf8(&sparkle_heart).is_err());\n ```\n\n See the docs for [`Utf8Error`] for more details on the kinds of\n errors that can be returned.\n\n A \"stack allocated string\":\n\n ```\n use std::str;\n\n // some bytes, in a stack-allocated array\n let sparkle_heart = [240, 159, 146, 150];\n\n // We know these bytes are valid, so just use `unwrap()`.\n let sparkle_heart: &str = str::from_utf8(&sparkle_heart).unwrap();\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::str::Utf8Error::error_len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Provides more information about the failure:\n\n * `None`: the end of the input was reached unexpectedly.\n   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n\n * `Some(len)`: an unexpected byte was encountered.\n   The length provided is that of the invalid byte sequence\n   that starts at the index given by `valid_up_to()`.\n   Decoding should resume after that sequence\n   (after inserting a [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD]) in case of\n   lossy decoding.\n\n [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n",
      "adt": {}
    },
    "core::str::Utf8Error::valid_up_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the index in the given string up to which valid UTF-8 was\n verified.\n\n It is the maximum index such that `from_utf8(&input[..index])`\n would return `Ok(_)`.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some invalid bytes, in a vector\n let sparkle_heart = vec![0, 159, 146, 150];\n\n // std::str::from_utf8 returns a Utf8Error\n let error = str::from_utf8(&sparkle_heart).unwrap_err();\n\n // the second byte is invalid here\n assert_eq!(1, error.valid_up_to());\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3370, kind: RigidTy(Adt(AdtDef(DefId { id: 5900, name: \"core::str::Utf8Error\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })])"
    ],
    "core::str::Utf8Error": [
      "Plain",
      "Ref"
    ],
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::format_symbol_name"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/mod.rs:344:1: 366:2",
  "src": "fn format_symbol_name(\n    fmt: fn(&str, &mut fmt::Formatter<'_>) -> fmt::Result,\n    mut bytes: &[u8],\n    f: &mut fmt::Formatter<'_>,\n) -> fmt::Result {\n    while bytes.len() > 0 {\n        match str::from_utf8(bytes) {\n            Ok(name) => {\n                fmt(name, f)?;\n                break;\n            }\n            Err(err) => {\n                fmt(\"\\u{FFFD}\", f)?;\n\n                match err.error_len() {\n                    Some(len) => bytes = &bytes[err.valid_up_to() + len..],\n                    None => break,\n                }\n            }\n        }\n    }\n    Ok(())\n}",
  "mir": "fn backtrace_rs::symbolize::format_symbol_name(_1: for<'a, 'b, 'c> fn(&'a str, &'b mut core::fmt::Formatter<'c>) -> core::result::Result<(), core::fmt::Error>, _2: &[u8], _3: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: &[u8];\n    let mut _7: core::result::Result<&str, core::str::Utf8Error>;\n    let mut _8: &[u8];\n    let mut _9: isize;\n    let  _10: &str;\n    let mut _11: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _12: core::result::Result<(), core::fmt::Error>;\n    let mut _13: isize;\n    let  _14: core::str::Utf8Error;\n    let mut _15: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _16: core::result::Result<(), core::fmt::Error>;\n    let mut _17: &str;\n    let mut _18: isize;\n    let mut _19: core::option::Option<usize>;\n    let mut _20: &core::str::Utf8Error;\n    let mut _21: isize;\n    let  _22: usize;\n    let  _23: &[u8];\n    let mut _24: &[u8];\n    let mut _25: core::ops::RangeFrom<usize>;\n    let mut _26: usize;\n    let mut _27: usize;\n    let mut _28: &core::str::Utf8Error;\n    let mut _29: (usize, bool);\n    debug fmt => _1;\n    debug bytes => _2;\n    debug f => _3;\n    debug name => _10;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug err => _14;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug len => _22;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = _2;\n        _5 = PtrMetadata(move _6);\n        StorageDead(_6);\n        _4 = Gt(move _5, 0_usize);\n        switchInt(move _4) -> [0: bb23, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = _2;\n        _7 = core::str::from_utf8(move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [0: bb6, 1: bb5, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        StorageLive(_14);\n        _14 = ((_7 as variant#1).0: core::str::Utf8Error);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = \"ï¿½\";\n        _16 = _1(move _17, _3) -> [return: bb12, unwind unreachable];\n    }\n    bb6: {\n        _10 = ((_7 as variant#0).0: &str);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _1(_10, _3) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        _13 = discriminant(_11);\n        switchInt(move _13) -> [0: bb9, 1: bb10, otherwise: bb4];\n    }\n    bb9: {\n        StorageDead(_11);\n        goto -> bb24;\n    }\n    bb10: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_11);\n        goto -> bb26;\n    }\n    bb12: {\n        StorageDead(_17);\n        _15 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        _18 = discriminant(_15);\n        switchInt(move _18) -> [0: bb14, 1: bb15, otherwise: bb4];\n    }\n    bb14: {\n        StorageDead(_15);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_14;\n        _19 = core::str::Utf8Error::error_len(move _20) -> [return: bb17, unwind unreachable];\n    }\n    bb15: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb26;\n    }\n    bb17: {\n        StorageDead(_20);\n        _21 = discriminant(_19);\n        switchInt(move _21) -> [0: bb18, 1: bb19, otherwise: bb4];\n    }\n    bb18: {\n        StorageDead(_19);\n        StorageDead(_14);\n        goto -> bb24;\n    }\n    bb19: {\n        _22 = ((_19 as variant#1).0: usize);\n        StorageLive(_24);\n        _24 = _2;\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = &_14;\n        _27 = core::str::Utf8Error::valid_up_to(move _28) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_28);\n        _29 = CheckedAdd(_27, _22);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _27, _22) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _26 = move (_29.0: usize);\n        StorageDead(_27);\n        _25 = RangeFrom(move _26);\n        StorageDead(_26);\n        _23 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(move _24, move _25) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_25);\n        StorageDead(_24);\n        _2 = _23;\n        StorageDead(_19);\n        StorageDead(_14);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb1;\n    }\n    bb23: {\n        StorageDead(_5);\n        goto -> bb25;\n    }\n    bb24: {\n        StorageDead(_7);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageDead(_4);\n        _0 = core::result::Result::Ok(());\n        goto -> bb27;\n    }\n    bb26: {\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb27;\n    }\n    bb27: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}