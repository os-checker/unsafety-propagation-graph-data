{
  "name": "backtrace_rs::symbolize::gimli::elf::handle_split_dwarf",
  "safe": true,
  "callees": {
    "core::option::Option::<T>::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&Option<T>` to `Option<&T>`.\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>\n without moving the [`String`]. The [`map`] method takes the `self` argument by value,\n consuming the original, so this technique uses `as_ref` to first take an `Option` to a\n reference to the value inside the original.\n\n [`map`]: Option::map\n [String]: ../../std/string/struct.String.html \"String\"\n [`String`]: ../../std/string/struct.String.html \"String\"\n\n ```\n let text: Option<String> = Some(\"Hello, world!\".to_string());\n // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n // then consume *that* with `map`, leaving `text` on the stack.\n let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n println!(\"still can print text: {text:?}\");\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "addr2line::gimli::DwarfPackage::<R>::find_cu": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Find the compilation unit with the given DWO identifier and return its section\n contributions.\n\n ## Example Usage\n\n ```rust,no_run\n # fn example<R: gimli::Reader>(\n #        dwarf: &gimli::Dwarf<R>,\n #        dwp: &gimli::DwarfPackage<R>,\n #        dwo_id: gimli::DwoId,\n # ) -> Result<(), gimli::Error> {\n if let Some(dwo) = dwp.find_cu(dwo_id, dwarf)? {\n    let dwo_header = dwo.units().next()?.expect(\"DWO should have one unit\");\n    let dwo_unit = dwo.unit(dwo_header)?;\n    // Do something with `dwo_unit`.\n }\n # unreachable!()\n # }\n",
      "adt": {}
    },
    "alloc_crate::sync::Arc::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Arc<T>`.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n ```\n",
      "adt": {}
    },
    "path::PathBuf::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates an empty `PathBuf`.\n\n # Examples\n\n ```\n use std::path::PathBuf;\n\n let path = PathBuf::new();\n ```\n",
      "adt": {
        "path::PathBuf": "Constructor"
      }
    },
    "os::unix::ffi::os_str::OsStrExt::from_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an [`OsStr`] from a byte slice.\n\n See the module documentation for an example.\n",
      "adt": {}
    },
    "path::PathBuf::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends `self` with `path`.\n\n If `path` is absolute, it replaces the current path.\n\n On Windows:\n\n * if `path` has a root but no prefix (e.g., `\\windows`), it\n   replaces everything except for the prefix (if any) of `self`.\n * if `path` has a prefix but no root, it replaces `self`.\n * if `self` has a verbatim prefix (e.g. `\\\\?\\C:\\windows`)\n   and `path` is not empty, the new path is normalized: all references\n   to `.` and `..` are removed.\n\n Consider using [`Path::join`] if you need a new `PathBuf` instead of\n using this function on a cloned `PathBuf`.\n\n # Examples\n\n Pushing a relative path extends the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"file.bk\");\n assert_eq!(path, PathBuf::from(\"/tmp/file.bk\"));\n ```\n\n Pushing an absolute path replaces the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"/etc\");\n assert_eq!(path, PathBuf::from(\"/etc\"));\n ```\n",
      "adt": {
        "path::PathBuf": "MutableAsArgument"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "backtrace_rs::symbolize::gimli::mmap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "path::Path": "ImmutableAsArgument",
        "backtrace_rs::symbolize::gimli::mmap::Mmap": "Constructor"
      }
    },
    "backtrace_rs::symbolize::gimli::stash::Stash::cache_mmap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a `Mmap` for the lifetime of this `Stash`, returning a pointer\n which is scoped to just this lifetime.\n",
      "adt": {
        "backtrace_rs::symbolize::gimli::mmap::Mmap": "ImmutableAsArgument",
        "backtrace_rs::symbolize::gimli::stash::Stash": "ImmutableAsArgument"
      }
    },
    "backtrace_rs::symbolize::gimli::elf::Object::<'a>::parse": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "backtrace_rs::symbolize::gimli::elf::Object": "Constructor"
      }
    },
    "addr2line::gimli::Dwarf::<T>::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Try to load the DWARF sections using the given loader function.\n\n `section` loads a DWARF section from the object file.\n It should return an empty section if the section does not exist.\n\n After loading, the user should set the `file_type` field and\n call `load_sup` if required.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Ref",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 18442, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17911, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17854, kind: RigidTy(Adt(AdtDef(DefId { id: 12589, name: \"addr2line::gimli::DwarfPackage\" }), GenericArgs([Type(Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) })]))) }, Not)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 18449, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17791, kind: RigidTy(Adt(AdtDef(DefId { id: 12560, name: \"backtrace_rs::symbolize::gimli::mmap::Mmap\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17848, kind: RigidTy(Adt(AdtDef(DefId { id: 12582, name: \"backtrace_rs::symbolize::gimli::elf::Object\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])"
    ],
    "addr2line::gimli::DwarfPackage": [
      "Ref"
    ],
    "addr2line::gimli::DwoId": [
      "Plain"
    ],
    "addr2line::SplitDwarfLoad": [
      "Unknown([Field(0, Ty { id: 18443, kind: RigidTy(Adt(AdtDef(DefId { id: 12913, name: \"addr2line::gimli::DwoId\" }), GenericArgs([]))) })])",
      "Unknown([Field(3, Ty { id: 17910, kind: RigidTy(Adt(AdtDef(DefId { id: 4653, name: \"alloc_crate::sync::Arc\" }), GenericArgs([Type(Ty { id: 17845, kind: RigidTy(Adt(AdtDef(DefId { id: 12581, name: \"addr2line::gimli::Dwarf\" }), GenericArgs([Type(Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) })]))) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 18447, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 18447, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) })]))) })])",
      "Plain"
    ],
    "alloc_crate::sync::Arc": [
      "Ref",
      "Plain"
    ],
    "addr2line::gimli::Dwarf": [
      "Ref",
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 17864, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 17845, kind: RigidTy(Adt(AdtDef(DefId { id: 12581, name: \"addr2line::gimli::Dwarf\" }), GenericArgs([Type(Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 17864, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 17845, kind: RigidTy(Adt(AdtDef(DefId { id: 12581, name: \"addr2line::gimli::Dwarf\" }), GenericArgs([Type(Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) })]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17845, kind: RigidTy(Adt(AdtDef(DefId { id: 12581, name: \"addr2line::gimli::Dwarf\" }), GenericArgs([Type(Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) })]))) })])"
    ],
    "path::PathBuf": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "addr2line::gimli::EndianSlice": [
      "Ref"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18449, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17878, kind: RigidTy(Adt(AdtDef(DefId { id: 12590, name: \"addr2line::gimli::EndianSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 17856, kind: RigidTy(Adt(AdtDef(DefId { id: 12587, name: \"addr2line::gimli::LittleEndian\" }), GenericArgs([]))) })]))) }, Not)) })])"
    ],
    "path::Path": [
      "Ref"
    ],
    "backtrace_rs::symbolize::gimli::mmap::Mmap": [
      "Plain"
    ],
    "backtrace_rs::symbolize::gimli::stash::Stash": [
      "Ref"
    ],
    "backtrace_rs::symbolize::gimli::elf::Object": [
      "Plain",
      "Ref"
    ]
  },
  "path": 493,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:530:1: 567:2",
  "src": "pub(super) fn handle_split_dwarf<'data>(\n    package: Option<&gimli::DwarfPackage<EndianSlice<'data, Endian>>>,\n    stash: &'data Stash,\n    load: addr2line::SplitDwarfLoad<EndianSlice<'data, Endian>>,\n) -> Option<Arc<gimli::Dwarf<EndianSlice<'data, Endian>>>> {\n    if let Some(dwp) = package.as_ref() {\n        if let Ok(Some(cu)) = dwp.find_cu(load.dwo_id, &load.parent) {\n            return Some(Arc::new(cu));\n        }\n    }\n\n    let mut path = PathBuf::new();\n    if let Some(p) = load.comp_dir.as_ref() {\n        path.push(OsStr::from_bytes(&p));\n    }\n\n    path.push(OsStr::from_bytes(&load.path.as_ref()?));\n\n    if let Some(map_dwo) = super::mmap(&path) {\n        let map_dwo = stash.cache_mmap(map_dwo);\n        if let Some(dwo) = Object::parse(map_dwo) {\n            return gimli::Dwarf::load(|id| -> Result<_, ()> {\n                let data = id\n                    .dwo_name()\n                    .and_then(|name| dwo.section(stash, name))\n                    .unwrap_or(&[]);\n                Ok(EndianSlice::new(data, Endian))\n            })\n            .ok()\n            .map(|mut dwo_dwarf| {\n                dwo_dwarf.make_dwo(&load.parent);\n                Arc::new(dwo_dwarf)\n            });\n        }\n    }\n\n    None\n}",
  "mir": "fn backtrace_rs::symbolize::gimli::elf::handle_split_dwarf(_1: core::option::Option<&addr2line::gimli::DwarfPackage<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>, _2: &backtrace_rs::symbolize::gimli::stash::Stash, _3: addr2line::SplitDwarfLoad<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>) -> core::option::Option<alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>> {\n    let mut _0: core::option::Option<alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>>;\n    let mut _4: core::option::Option<&&addr2line::gimli::DwarfPackage<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>;\n    let mut _5: &core::option::Option<&addr2line::gimli::DwarfPackage<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>;\n    let mut _6: isize;\n    let  _7: &&addr2line::gimli::DwarfPackage<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _8: core::result::Result<core::option::Option<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>, addr2line::gimli::Error>;\n    let mut _9: addr2line::gimli::DwoId;\n    let  _10: &addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let  _11: &alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>;\n    let mut _12: isize;\n    let mut _13: isize;\n    let  _14: addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _15: alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>;\n    let mut _16: path::PathBuf;\n    let mut _17: core::option::Option<&addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _18: &core::option::Option<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _19: isize;\n    let  _20: &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>;\n    let  _21: ();\n    let mut _22: &mut path::PathBuf;\n    let mut _23: &ffi::os_str::OsStr;\n    let  _24: &[u8];\n    let  _25: &&addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>;\n    let  _26: ();\n    let mut _27: &mut path::PathBuf;\n    let mut _28: &ffi::os_str::OsStr;\n    let  _29: &[u8];\n    let  _30: &&addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>;\n    let  _31: &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>;\n    let mut _32: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _33: core::option::Option<&addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _34: &core::option::Option<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _35: isize;\n    let  _36: &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>;\n    let mut _37: core::option::Option<backtrace_rs::symbolize::gimli::mmap::Mmap>;\n    let  _38: &path::Path;\n    let  _39: &path::PathBuf;\n    let mut _40: isize;\n    let  _41: backtrace_rs::symbolize::gimli::mmap::Mmap;\n    let  _42: &[u8];\n    let mut _43: core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>>;\n    let mut _44: isize;\n    let  _45: backtrace_rs::symbolize::gimli::elf::Object<'_>;\n    let mut _46: core::option::Option<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>;\n    let mut _47: core::result::Result<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>, ()>;\n    let mut _48: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:551:39: 551:60};\n    let mut _49: &backtrace_rs::symbolize::gimli::elf::Object<'_>;\n    let mut _50: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:559:18: 559:33};\n    let mut _51: &alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>;\n    let mut _52: &addr2line::gimli::DwarfPackage<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>;\n    let mut _53: &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>;\n    let mut _54: &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>;\n    let mut _55: isize;\n    let mut _56: isize;\n    debug package => _1;\n    debug stash => _2;\n    debug load => _3;\n    debug dwp => _7;\n    debug cu => _14;\n    debug path => _16;\n    debug p => _20;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _36;\n    debug map_dwo => _41;\n    debug map_dwo => _42;\n    debug dwo => _45;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_1;\n        _4 = core::option::Option::<&addr2line::gimli::DwarfPackage<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>::as_ref(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [1: bb2, 0: bb8, otherwise: bb20];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = ((_4 as variant#1).0: &&addr2line::gimli::DwarfPackage<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>);\n        StorageLive(_8);\n        _52 = (*_7);\n        StorageLive(_9);\n        _9 = (_3.0: addr2line::gimli::DwoId);\n        _11 = &(_3.3: alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>);\n        _10 = <alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>> as core::ops::Deref>::deref(_11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = addr2line::gimli::DwarfPackage::<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>::find_cu(_52, move _9, _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _13 = discriminant(_8);\n        switchInt(move _13) -> [0: bb5, 1: bb45, otherwise: bb20];\n    }\n    bb5: {\n        _12 = discriminant(((_8 as variant#0).0: core::option::Option<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>));\n        switchInt(move _12) -> [1: bb6, 0: bb45, otherwise: bb20];\n    }\n    bb6: {\n        _14 = move ((((_8 as variant#0).0: core::option::Option<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>) as variant#1).0: addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>);\n        StorageLive(_15);\n        _15 = alloc_crate::sync::Arc::<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>::new(_14) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _0 = core::option::Option::Some(move _15);\n        StorageDead(_15);\n        _56 = discriminant(_8);\n        switchInt(move _56) -> [0: bb49, 1: bb48, otherwise: bb20];\n    }\n    bb8: {\n        StorageDead(_4);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_16);\n        _16 = path::PathBuf::new() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &(_3.1: core::option::Option<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>);\n        _17 = core::option::Option::<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>::as_ref(move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_18);\n        _19 = discriminant(_17);\n        switchInt(move _19) -> [1: bb12, 0: bb16, otherwise: bb20];\n    }\n    bb12: {\n        StorageLive(_20);\n        _20 = ((_17 as variant#1).0: &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>);\n        StorageLive(_22);\n        _22 = &mut _16;\n        StorageLive(_23);\n        StorageLive(_25);\n        _25 = &_20;\n        _53 = (*_25);\n        _24 = <addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian> as core::ops::Deref>::deref(_53) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _23 = <ffi::os_str::OsStr as os::unix::ffi::os_str::OsStrExt>::from_bytes(_24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _21 = path::PathBuf::push::<&ffi::os_str::OsStr>(move _22, move _23) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_25);\n        StorageDead(_20);\n        StorageDead(_17);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_17);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_27);\n        _27 = &mut _16;\n        StorageLive(_28);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &(_3.2: core::option::Option<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>);\n        _33 = core::option::Option::<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>::as_ref(move _34) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_34);\n        _32 = <core::option::Option<&addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>> as core::ops::Try>::branch(move _33) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_33);\n        _35 = discriminant(_32);\n        switchInt(move _35) -> [0: bb21, 1: bb22, otherwise: bb20];\n    }\n    bb20: {\n        unreachable;\n    }\n    bb21: {\n        StorageLive(_36);\n        _36 = ((_32 as variant#0).0: &addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>);\n        _31 = _36;\n        StorageDead(_36);\n        _30 = &_31;\n        _54 = (*_30);\n        _29 = <addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian> as core::ops::Deref>::deref(_54) -> [return: bb24, unwind unreachable];\n    }\n    bb22: {\n        _0 = <core::option::Option<alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_30);\n        goto -> bb39;\n    }\n    bb24: {\n        _28 = <ffi::os_str::OsStr as os::unix::ffi::os_str::OsStrExt>::from_bytes(_29) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        _26 = path::PathBuf::push::<&ffi::os_str::OsStr>(move _27, move _28) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_37);\n        _39 = &_16;\n        _38 = <path::PathBuf as core::ops::Deref>::deref(_39) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _37 = backtrace_rs::symbolize::gimli::mmap(_38) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _40 = discriminant(_37);\n        switchInt(move _40) -> [1: bb29, 0: bb47, otherwise: bb20];\n    }\n    bb29: {\n        _41 = move ((_37 as variant#1).0: backtrace_rs::symbolize::gimli::mmap::Mmap);\n        _42 = backtrace_rs::symbolize::gimli::stash::Stash::cache_mmap(_2, _41) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageLive(_43);\n        _43 = backtrace_rs::symbolize::gimli::elf::Object::<'_>::parse(_42) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _44 = discriminant(_43);\n        switchInt(move _44) -> [1: bb32, 0: bb46, otherwise: bb20];\n    }\n    bb32: {\n        StorageLive(_45);\n        _45 = move ((_43 as variant#1).0: backtrace_rs::symbolize::gimli::elf::Object<'_>);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &_45;\n        _48 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:551:39: 551:60}(move _49, _2);\n        StorageDead(_49);\n        _47 = addr2line::gimli::Dwarf::<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>::load::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:551:39: 551:60}, ()>(move _48) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_48);\n        _46 = core::result::Result::<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>, ()>::ok(move _47) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_47);\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = &(_3.3: alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>);\n        _50 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:559:18: 559:33}(move _51);\n        StorageDead(_51);\n        _0 = core::option::Option::<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>::map::<alloc_crate::sync::Arc<addr2line::gimli::Dwarf<addr2line::gimli::EndianSlice<'_, addr2line::gimli::LittleEndian>>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:559:18: 559:33}>(move _46, move _50) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_50);\n        StorageDead(_46);\n        drop(_45) -> [return: bb38, unwind unreachable];\n    }\n    bb36: {\n        _0 = core::option::Option::None;\n        drop(_16) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_16);\n        drop(_3) -> [return: bb42, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_45);\n        StorageDead(_43);\n        StorageDead(_37);\n        goto -> bb39;\n    }\n    bb39: {\n        drop(_16) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_16);\n        goto -> bb41;\n    }\n    bb41: {\n        drop(_3) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        return;\n    }\n    bb43: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb9;\n    }\n    bb44: {\n        goto -> bb43;\n    }\n    bb45: {\n        _55 = discriminant(_8);\n        switchInt(move _55) -> [0: bb44, 1: bb43, otherwise: bb20];\n    }\n    bb46: {\n        StorageDead(_43);\n        StorageDead(_37);\n        goto -> bb36;\n    }\n    bb47: {\n        StorageDead(_37);\n        goto -> bb36;\n    }\n    bb48: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb41;\n    }\n    bb49: {\n        goto -> bb48;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}