{
  "name": "thread::spawnhook::add_spawn_hook",
  "safe": true,
  "callees": {
    "thread::local::LocalKey::<T>::with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a reference to the value in this TLS key.\n\n This will lazily initialize the value if this thread has not referenced\n this key yet.\n\n # Panics\n\n This function will `panic!()` if the key currently has its\n destructor running, and it **may** panic if the destructor has\n previously been run for this thread.\n\n # Examples\n\n ```\n thread_local! {\n     pub static STATIC: String = String::from(\"I am\");\n }\n\n assert_eq!(\n     STATIC.with(|original_value| format!(\"{original_value} initialized\")),\n     \"I am initialized\",\n );\n ```\n",
      "adt": {
        "thread::local::LocalKey": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "thread::local::LocalKey": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::thread::spawnhook::add_spawn_hook"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/spawnhook.rs:92:1: 106:2",
  "src": "pub fn add_spawn_hook<F, G>(hook: F)\nwhere\n    F: 'static + Send + Sync + Fn(&Thread) -> G,\n    G: 'static + Send + FnOnce(),\n{\n    SPAWN_HOOKS.with(|h| {\n        let mut hooks = h.take();\n        let next = hooks.first.take();\n        hooks.first = Some(Arc::new(SpawnHook {\n            hook: Box::new(move |thread| Box::new(hook(thread))),\n            next,\n        }));\n        h.set(hooks);\n    });\n}",
  "mir": "fn thread::spawnhook::add_spawn_hook(_1: F) -> () {\n    let mut _0: ();\n    let  _2: ();\n    let mut _3: &thread::local::LocalKey<core::cell::Cell<thread::spawnhook::SpawnHooks>>;\n    let mut _4: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/spawnhook.rs:97:22: 97:25};\n    debug hook => _1;\n    bb0: {\n        StorageLive(_3);\n        _3 = thread::spawnhook::add_spawn_hook::<F, G>::promoted[0];\n        StorageLive(_4);\n        _4 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/spawnhook.rs:97:22: 97:25}(move _1);\n        _2 = thread::local::LocalKey::<core::cell::Cell<thread::spawnhook::SpawnHooks>>::with::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/spawnhook.rs:97:22: 97:25}, ()>(move _3, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Registers a function to run for every newly thread spawned.\n\n The hook is executed in the parent thread, and returns a function\n that will be executed in the new thread.\n\n The hook is called with the `Thread` handle for the new thread.\n\n The hook will only be added for the current thread and is inherited by the threads it spawns.\n In other words, adding a hook has no effect on already running threads (other than the current\n thread) and the threads they might spawn in the future.\n\n Hooks can only be added, not removed.\n\n The hooks will run in reverse order, starting with the most recently added.\n\n # Usage\n\n ```\n #![feature(thread_spawn_hook)]\n\n std::thread::add_spawn_hook(|_| {\n     ..; // This will run in the parent (spawning) thread.\n     move || {\n         ..; // This will run it the child (spawned) thread.\n     }\n });\n ```\n\n # Example\n\n A spawn hook can be used to \"inherit\" a thread local from the parent thread:\n\n ```\n #![feature(thread_spawn_hook)]\n\n use std::cell::Cell;\n\n thread_local! {\n     static X: Cell<u32> = Cell::new(0);\n }\n\n // This needs to be done once in the main thread before spawning any threads.\n std::thread::add_spawn_hook(|_| {\n     // Get the value of X in the spawning thread.\n     let value = X.get();\n     // Set the value of X in the newly spawned thread.\n     move || X.set(value)\n });\n\n X.set(123);\n\n std::thread::spawn(|| {\n     assert_eq!(X.get(), 123);\n }).join().unwrap();\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}