{
  "name": "sys::net::hostname::unix::hostname",
  "safe": true,
  "callees": {
    "libc::sysconf": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T>::try_with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n # Errors\n\n Returns an error if the capacity exceeds `isize::MAX` _bytes_,\n or if the allocator reports allocation failure.\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total number of elements the vector can hold without\n reallocating.\n\n # Examples\n\n ```\n let mut vec: Vec<i32> = Vec::with_capacity(10);\n vec.push(42);\n assert!(vec.capacity() >= 10);\n ```\n\n A vector with zero-sized elements will always have a capacity of usize::MAX:\n\n ```\n #[derive(Clone)]\n struct ZeroSized;\n\n fn main() {\n     assert_eq!(std::mem::size_of::<ZeroSized>(), 0);\n     let v = vec![ZeroSized; 0];\n     assert_eq!(v.capacity(), usize::MAX);\n }\n ```\n",
      "adt": {}
    },
    "libc::gethostname": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::bool::<impl bool>::then": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `Some(f())` if the `bool` is [`true`](../std/keyword.true.html),\n or `None` otherwise.\n\n # Examples\n\n ```\n assert_eq!(false.then(|| 0), None);\n assert_eq!(true.then(|| 0), Some(0));\n ```\n\n ```\n let mut a = 0;\n\n true.then(|| { a += 1; });\n false.then(|| { a += 1; });\n\n // `a` is incremented once because the closure is evaluated lazily by\n // `then`.\n assert_eq!(a, 1);\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::os::errno": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the platform-specific value of errno\n",
      "adt": {}
    },
    "io::error::Error::from_raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new instance of an [`Error`] from a particular OS error code.\n\n # Examples\n\n On Linux:\n\n ```\n # if cfg!(target_os = \"linux\") {\n use std::io;\n\n let error = io::Error::from_raw_os_error(22);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n\n On Windows:\n\n ```\n # if cfg!(windows) {\n use std::io;\n\n let error = io::Error::from_raw_os_error(10022);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the vector's buffer, or a dangling raw pointer\n valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize mutable references to the slice,\n or mutable references to specific elements you are planning on accessing through this pointer,\n as well as writing to those elements, may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n\n # Examples\n\n ```\n let x = vec![1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(*x_ptr.add(i), 1 << i);\n     }\n }\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0, 1, 2];\n     let ptr1 = v.as_ptr();\n     let _ = ptr1.read();\n     let ptr2 = v.as_mut_ptr().offset(2);\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`\n     // because it mutated a different element:\n     let _ = ptr1.read();\n }\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "libc::strnlen": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {}
    },
    "os::unix::ffi::os_str::OsStringExt::from_vec": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an [`OsString`] from a byte vector.\n\n See the module documentation for an example.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::try_reserve": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tries to reserve capacity for at least `additional` more elements to be inserted\n in the given `Vec<T>`. The collection may reserve more space to speculatively avoid\n frequent reallocations. After calling `try_reserve`, capacity will be\n greater than or equal to `self.len() + additional` if it returns\n `Ok(())`. Does nothing if capacity is already sufficient. This method\n preserves the contents even if an error occurs.\n\n # Errors\n\n If the capacity overflows, or the allocator reports a failure, then an error\n is returned.\n\n # Examples\n\n ```\n use std::collections::TryReserveError;\n\n fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     let mut output = Vec::new();\n\n     // Pre-reserve the memory, exiting if we can't\n     output.try_reserve(data.len())?;\n\n     // Now we know this can't OOM in the middle of our complex work\n     output.extend(data.iter().map(|&val| {\n         val * 2 + 5 // very complicated\n     }));\n\n     Ok(output)\n }\n # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3680, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 1482, kind: RigidTy(Adt(AdtDef(DefId { id: 5039, name: \"alloc_crate::collections::TryReserveError\" }), GenericArgs([]))) })]))) })])"
    ],
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ]
  },
  "path": 3827,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/net/hostname/unix.rs:6:1: 62:2",
  "src": "pub fn hostname() -> io::Result<OsString> {\n    // Query the system for the maximum host name length.\n    let host_name_max = match unsafe { libc::sysconf(libc::_SC_HOST_NAME_MAX) } {\n        // If this fails (possibly because there is no maximum length), then\n        // assume a maximum length of _POSIX_HOST_NAME_MAX (255).\n        -1 => 255,\n        max => max as usize,\n    };\n\n    // Reserve space for the nul terminator too.\n    let mut buf = Vec::<u8>::try_with_capacity(host_name_max + 1)?;\n    loop {\n        // SAFETY: `buf.capacity()` bytes of `buf` are writable.\n        let r = unsafe { libc::gethostname(buf.as_mut_ptr().cast(), buf.capacity()) };\n        match (r != 0).then(errno) {\n            None => {\n                // Unfortunately, the UNIX specification says that the name will\n                // be truncated if it does not fit in the buffer, without returning\n                // an error. As additionally, the truncated name may still be null-\n                // terminated, there is no reliable way to  detect truncation.\n                // Fortunately, most platforms ignore what the specification says\n                // and return an error (mostly ENAMETOOLONG). Should that not be\n                // the case, the following detects truncation if the null-terminator\n                // was omitted. Note that this check does not impact performance at\n                // all as we need to find the length of the string anyways.\n                //\n                // Use `strnlen` as it does not place an initialization requirement\n                // on the bytes after the nul terminator.\n                //\n                // SAFETY: `buf.capacity()` bytes of `buf` are accessible, and are\n                // initialized up to and including a possible nul terminator.\n                let len = unsafe { libc::strnlen(buf.as_ptr().cast(), buf.capacity()) };\n                if len < buf.capacity() {\n                    // If the string is nul-terminated, we assume that is has not\n                    // been truncated, as the capacity *should be* enough to hold\n                    // `HOST_NAME_MAX` bytes.\n                    // SAFETY: `len + 1` bytes have been initialized (we exclude\n                    // the nul terminator from the string).\n                    unsafe { buf.set_len(len) };\n                    return Ok(OsString::from_vec(buf));\n                }\n            }\n            // As `buf.capacity()` is always less than or equal to `isize::MAX`\n            // (Rust allocations cannot exceed that limit), the only way `EINVAL`\n            // can be returned is if the system uses `EINVAL` to report that the\n            // name does not fit in the provided buffer. In that case (or in the\n            // case of `ENAMETOOLONG`), resize the buffer and try again.\n            Some(libc::EINVAL | libc::ENAMETOOLONG) => {}\n            // Other error codes (e.g. EPERM) have nothing to do with the buffer\n            // size and should be returned to the user.\n            Some(err) => return Err(io::Error::from_raw_os_error(err)),\n        }\n\n        // Resize the buffer (according to `Vec`'s resizing rules) and try again.\n        buf.try_reserve(buf.capacity() + 1)?;\n    }\n}",
  "mir": "fn sys::net::hostname::unix::hostname() -> core::result::Result<ffi::os_str::OsString, io::error::Error> {\n    let mut _0: core::result::Result<ffi::os_str::OsString, io::error::Error>;\n    let  _1: usize;\n    let mut _2: i64;\n    let mut _3: alloc_crate::vec::Vec<u8>;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>, alloc_crate::vec::Vec<u8>>;\n    let mut _5: core::result::Result<alloc_crate::vec::Vec<u8>, alloc_crate::collections::TryReserveError>;\n    let mut _6: usize;\n    let mut _7: usize;\n    let mut _8: (usize, bool);\n    let mut _9: isize;\n    let  _10: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>;\n    let  _11: alloc_crate::vec::Vec<u8>;\n    let  _12: i32;\n    let mut _13: *mut u8;\n    let mut _14: *mut u8;\n    let mut _15: &mut alloc_crate::vec::Vec<u8>;\n    let mut _16: usize;\n    let mut _17: &alloc_crate::vec::Vec<u8>;\n    let mut _18: core::option::Option<i32>;\n    let mut _19: bool;\n    let mut _20: isize;\n    let  _21: usize;\n    let mut _22: *const u8;\n    let mut _23: *const u8;\n    let mut _24: &alloc_crate::vec::Vec<u8>;\n    let mut _25: usize;\n    let mut _26: &alloc_crate::vec::Vec<u8>;\n    let mut _27: bool;\n    let mut _28: usize;\n    let mut _29: &alloc_crate::vec::Vec<u8>;\n    let  _30: ();\n    let mut _31: &mut alloc_crate::vec::Vec<u8>;\n    let mut _32: ffi::os_str::OsString;\n    let mut _33: alloc_crate::vec::Vec<u8>;\n    let  _34: i32;\n    let mut _35: io::error::Error;\n    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>;\n    let mut _37: core::result::Result<(), alloc_crate::collections::TryReserveError>;\n    let mut _38: &mut alloc_crate::vec::Vec<u8>;\n    let mut _39: usize;\n    let mut _40: usize;\n    let mut _41: &alloc_crate::vec::Vec<u8>;\n    let mut _42: (usize, bool);\n    let mut _43: isize;\n    let  _44: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>;\n    let mut _45: bool;\n    debug host_name_max => _1;\n    debug max => _2;\n    debug buf => _3;\n    debug residual => _10;\n    debug val => _11;\n    debug r => _12;\n    debug len => _21;\n    debug err => _34;\n    debug residual => _44;\n    debug val => ();\n    bb0: {\n        _45 = false;\n        StorageLive(_1);\n        _2 = libc::sysconf(libc::_SC_HOST_NAME_MAX) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(_2) -> [18446744073709551615: bb3, otherwise: bb2];\n    }\n    bb2: {\n        _1 = _2 as usize;\n        goto -> bb4;\n    }\n    bb3: {\n        _1 = 255_usize;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _1;\n        _8 = CheckedAdd(_7, 1_usize);\n        assert(!move (_8.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _7, 1_usize) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _6 = move (_8.0: usize);\n        StorageDead(_7);\n        _5 = alloc_crate::vec::Vec::<u8>::try_with_capacity(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        _4 = <core::result::Result<alloc_crate::vec::Vec<u8>, alloc_crate::collections::TryReserveError> as core::ops::Try>::branch(move _5) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_5);\n        _9 = discriminant(_4);\n        switchInt(move _9) -> [0: bb9, 1: bb10, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        StorageLive(_11);\n        _11 = move ((_4 as variant#0).0: alloc_crate::vec::Vec<u8>);\n        _45 = true;\n        _3 = move _11;\n        StorageDead(_11);\n        StorageDead(_4);\n        goto -> bb12;\n    }\n    bb10: {\n        _10 = move ((_4 as variant#1).0: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>);\n        _0 = <core::result::Result<ffi::os_str::OsString, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>>::from_residual(_10) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_4);\n        goto -> bb41;\n    }\n    bb12: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _3;\n        _14 = alloc_crate::vec::Vec::<u8>::as_mut_ptr(move _15) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_15);\n        _13 = core::ptr::mut_ptr::<impl *mut u8>::cast::<u8>(move _14) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_3;\n        _16 = alloc_crate::vec::Vec::<u8>::capacity(move _17) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_17);\n        _12 = libc::gethostname(move _13, move _16) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_16);\n        StorageDead(_13);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = Ne(_12, 0_i32);\n        _18 = core::bool::<impl bool>::then::<i32, fn() -> i32 {sys::pal::unix::os::errno}>(move _19, sys::pal::unix::os::errno) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_19);\n        _20 = discriminant(_18);\n        switchInt(move _20) -> [0: bb20, 1: bb18, otherwise: bb8];\n    }\n    bb18: {\n        switchInt(((_18 as variant#1).0: i32)) -> [22: bb31, 36: bb31, otherwise: bb19];\n    }\n    bb19: {\n        _34 = ((_18 as variant#1).0: i32);\n        StorageLive(_35);\n        _35 = io::error::Error::from_raw_os_error(_34) -> [return: bb30, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_3;\n        _23 = alloc_crate::vec::Vec::<u8>::as_ptr(move _24) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_24);\n        _22 = core::ptr::const_ptr::<impl *const u8>::cast::<u8>(move _23) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_3;\n        _25 = alloc_crate::vec::Vec::<u8>::capacity(move _26) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_26);\n        _21 = libc::strnlen(move _22, move _25) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_25);\n        StorageDead(_22);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &_3;\n        _28 = alloc_crate::vec::Vec::<u8>::capacity(move _29) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_29);\n        _27 = Lt(_21, move _28);\n        switchInt(move _27) -> [0: bb29, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_28);\n        StorageLive(_31);\n        _31 = &mut _3;\n        _30 = alloc_crate::vec::Vec::<u8>::set_len(move _31, _21) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _45 = false;\n        _33 = move _3;\n        _32 = <ffi::os_str::OsString as os::unix::ffi::os_str::OsStringExt>::from_vec(move _33) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_33);\n        _0 = core::result::Result::Ok(move _32);\n        StorageDead(_32);\n        StorageDead(_27);\n        goto -> bb39;\n    }\n    bb29: {\n        StorageDead(_28);\n        StorageDead(_27);\n        goto -> bb31;\n    }\n    bb30: {\n        _0 = core::result::Result::Err(move _35);\n        StorageDead(_35);\n        goto -> bb39;\n    }\n    bb31: {\n        StorageDead(_18);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &mut _3;\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &_3;\n        _40 = alloc_crate::vec::Vec::<u8>::capacity(move _41) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_41);\n        _42 = CheckedAdd(_40, 1_usize);\n        assert(!move (_42.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _40, 1_usize) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _39 = move (_42.0: usize);\n        StorageDead(_40);\n        _37 = alloc_crate::vec::Vec::<u8>::try_reserve(move _38, move _39) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_39);\n        StorageDead(_38);\n        _36 = <core::result::Result<(), alloc_crate::collections::TryReserveError> as core::ops::Try>::branch(move _37) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_37);\n        _43 = discriminant(_36);\n        switchInt(move _43) -> [0: bb36, 1: bb37, otherwise: bb8];\n    }\n    bb36: {\n        StorageDead(_36);\n        goto -> bb12;\n    }\n    bb37: {\n        _44 = move ((_36 as variant#1).0: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>);\n        _0 = <core::result::Result<ffi::os_str::OsString, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>>::from_residual(_44) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_36);\n        goto -> bb40;\n    }\n    bb39: {\n        StorageDead(_18);\n        goto -> bb40;\n    }\n    bb40: {\n        switchInt(_45) -> [0: bb41, otherwise: bb42];\n    }\n    bb41: {\n        _45 = false;\n        StorageDead(_3);\n        StorageDead(_1);\n        return;\n    }\n    bb42: {\n        drop(_3) -> [return: bb41, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}