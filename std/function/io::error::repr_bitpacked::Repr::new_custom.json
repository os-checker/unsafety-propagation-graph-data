{
  "name": "io::error::repr_bitpacked::Repr::new_custom",
  "safe": true,
  "callees": {
    "alloc_crate::boxed::Box::<T>::into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the `Box`, returning a wrapped raw pointer.\n\n The pointer will be properly aligned and non-null.\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Box`. In particular, the\n caller should properly destroy `T` and release the memory, taking\n into account the [memory layout] used by `Box`. The easiest way to\n do this is to convert the raw pointer back into a `Box` with the\n [`Box::from_raw`] function, allowing the `Box` destructor to perform\n the cleanup.\n\n Note: this is an associated function, which means that you have\n to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n is so that there is no conflict with a method on the inner type.\n\n # Examples\n Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n for automatic cleanup:\n ```\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n let x = unsafe { Box::from_raw(ptr) };\n ```\n Manual cleanup by explicitly running the destructor and deallocating\n the memory:\n ```\n use std::alloc::{dealloc, Layout};\n use std::ptr;\n\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n unsafe {\n     ptr::drop_in_place(ptr);\n     dealloc(ptr as *mut u8, Layout::new::<String>());\n }\n ```\n Note: This is equivalent to the following:\n ```\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n unsafe {\n     drop(Box::from_raw(ptr));\n }\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n [without_provenance]: without_provenance_mut\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an unsigned offset to a pointer using wrapping arithmetic.\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n This operation itself is always safe, but using the resulting pointer is not.\n\n The resulting pointer \"remembers\" the [allocation] that `self` points to; it must not\n be used to read or write other allocations.\n\n In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n `x` and `y` point into the same allocation.\n\n Compared to [`add`], this method basically delays the requirement of staying within the\n same allocation: [`add`] is immediate Undefined Behavior when crossing object\n boundaries; `wrapping_add` produces a pointer but still leads to Undefined Behavior if a\n pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`add`]\n can be optimized better and is thus preferable in performance-sensitive code.\n\n The delayed check only considers the value of the pointer that was dereferenced, not the\n intermediate values used during the computation of the final result. For example,\n `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n allocation and then re-entering it later is permitted.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n // Iterate using a raw pointer in increments of two elements\n let data = [1u8, 2, 3, 4, 5];\n let mut ptr: *const u8 = data.as_ptr();\n let step = 2;\n let end_rounded_up = ptr.wrapping_add(6);\n\n // This loop prints \"1, 3, 5, \"\n while ptr != end_rounded_up {\n     unsafe {\n         print!(\"{}, \", *ptr);\n     }\n     ptr = ptr.wrapping_add(step);\n }\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull`.\n\n # Safety\n\n `ptr` must be non-null.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = unsafe { NonNull::new_unchecked(&mut x as *mut _) };\n ```\n\n *Incorrect* usage of this function:\n\n ```rust,no_run\n use std::ptr::NonNull;\n\n // NEVER DO THAT!!! This is undefined behavior. ⚠️\n let ptr = unsafe { NonNull::<u32>::new_unchecked(std::ptr::null_mut()) };\n ```\n",
      "adt": {}
    },
    "io::error::repr_bitpacked::Repr::data": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::repr_bitpacked::Repr": "ImmutableAsArgument",
        "io::error::ErrorData": "Constructor"
      }
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::boxed::Box": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "io::error::repr_bitpacked::Repr": [
      "Plain",
      "Ref"
    ],
    "io::error::ErrorData": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 1464,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:136:5: 164:6",
  "src": "pub(super) fn new_custom(b: Box<Custom>) -> Self {\n        let p = Box::into_raw(b).cast::<u8>();\n        // Should only be possible if an allocator handed out a pointer with\n        // wrong alignment.\n        debug_assert_eq!(p.addr() & TAG_MASK, 0);\n        // Note: We know `TAG_CUSTOM <= size_of::<Custom>()` (static_assert at\n        // end of file), and both the start and end of the expression must be\n        // valid without address space wraparound due to `Box`'s semantics.\n        //\n        // This means it would be correct to implement this using `ptr::add`\n        // (rather than `ptr::wrapping_add`), but it's unclear this would give\n        // any benefit, so we just use `wrapping_add` instead.\n        let tagged = p.wrapping_add(TAG_CUSTOM).cast::<()>();\n        // Safety: `TAG_CUSTOM + p` is the same as `TAG_CUSTOM | p`,\n        // because `p`'s alignment means it isn't allowed to have any of the\n        // `TAG_BITS` set (you can verify that addition and bitwise-or are the\n        // same when the operands have no bits in common using a truth table).\n        //\n        // Then, `TAG_CUSTOM | p` is not zero, as that would require\n        // `TAG_CUSTOM` and `p` both be zero, and neither is (as `p` came from a\n        // box, and `TAG_CUSTOM` just... isn't zero -- it's `0b01`). Therefore,\n        // `TAG_CUSTOM + p` isn't zero and so `tagged` can't be, and the\n        // `new_unchecked` is safe.\n        let res = Self(unsafe { NonNull::new_unchecked(tagged) }, PhantomData);\n        // quickly smoke-check we encoded the right thing (This generally will\n        // only run in std's tests, unless the user uses -Zbuild-std)\n        debug_assert!(matches!(res.data(), ErrorData::Custom(_)), \"repr(custom) encoding failed\");\n        res\n    }",
  "mir": "fn io::error::repr_bitpacked::Repr::new_custom(_1: alloc_crate::boxed::Box<io::error::Custom>) -> io::error::repr_bitpacked::Repr {\n    let mut _0: io::error::repr_bitpacked::Repr;\n    let  _2: *mut u8;\n    let mut _3: *mut io::error::Custom;\n    let mut _4: (&usize, &usize);\n    let mut _5: &usize;\n    let  _6: usize;\n    let mut _7: usize;\n    let mut _8: &usize;\n    let  _9: &usize;\n    let  _10: &usize;\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: usize;\n    let  _14: core::panicking::AssertKind;\n    let  _15: !;\n    let mut _16: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _17: *mut ();\n    let mut _18: *mut u8;\n    let mut _19: core::ptr::NonNull<()>;\n    let mut _20: io::error::ErrorData<&io::error::Custom>;\n    let mut _21: &io::error::repr_bitpacked::Repr;\n    let mut _22: isize;\n    let  _23: !;\n    let mut _24: core::fmt::Arguments<'_>;\n    debug b => _1;\n    debug p => _2;\n    debug left_val => _9;\n    debug right_val => _10;\n    debug kind => _14;\n    debug tagged => _17;\n    debug res => _0;\n    bb0: {\n        StorageLive(_3);\n        _3 = alloc_crate::boxed::Box::<io::error::Custom>::into_raw(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::ptr::mut_ptr::<impl *mut io::error::Custom>::cast::<u8>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::ptr::mut_ptr::<impl *mut u8>::addr(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = BitAnd(move _7, io::error::repr_bitpacked::TAG_MASK);\n        StorageDead(_7);\n        _5 = &_6;\n        StorageLive(_8);\n        _8 = io::error::repr_bitpacked::Repr::new_custom::promoted[0];\n        _4 = (move _5, move _8);\n        StorageDead(_8);\n        StorageDead(_5);\n        _9 = (_4.0: &usize);\n        _10 = (_4.1: &usize);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = (*_9);\n        StorageLive(_13);\n        _13 = (*_10);\n        _11 = Eq(move _12, move _13);\n        switchInt(move _11) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageLive(_18);\n        _18 = core::ptr::mut_ptr::<impl *mut u8>::wrapping_add(_2, io::error::repr_bitpacked::TAG_CUSTOM) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _14 = core::panicking::AssertKind::Eq;\n        StorageLive(_16);\n        _16 = core::option::Option::None;\n        _15 = core::panicking::assert_failed::<usize, usize>(_14, _9, _10, move _16) -> unwind unreachable;\n    }\n    bb6: {\n        _17 = core::ptr::mut_ptr::<impl *mut u8>::cast::<()>(move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        StorageLive(_19);\n        _19 = core::ptr::NonNull::<()>::new_unchecked(_17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _0 = Repr(move _19, core::marker::PhantomData::<io::error::ErrorData<alloc_crate::boxed::Box<io::error::Custom>>>);\n        StorageDead(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_0;\n        _20 = io::error::repr_bitpacked::Repr::data(move _21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_21);\n        _22 = discriminant(_20);\n        switchInt(_22) -> [3: bb12, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_20);\n        StorageLive(_24);\n        _24 = core::fmt::Arguments::<'_>::from_str(\"repr(custom) encoding failed\") -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _23 = core::panicking::panic_fmt(move _24) -> unwind unreachable;\n    }\n    bb12: {\n        StorageDead(_20);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}