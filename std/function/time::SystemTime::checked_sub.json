{
  "name": "time::SystemTime::checked_sub",
  "safe": true,
  "callees": {
    "sys::pal::unix::time::SystemTime::checked_sub_duration": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::pal::unix::time::SystemTime": "Constructor",
        "core::time::Duration": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "time::SystemTime": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A measurement of the system clock, useful for talking to\n external entities like the file system or other processes.\n\n Distinct from the [`Instant`] type, this time measurement **is not\n monotonic**. This means that you can save a file to the file system, then\n save another file to the file system, **and the second file has a\n `SystemTime` measurement earlier than the first**. In other words, an\n operation that happens after another operation in real time may have an\n earlier `SystemTime`!\n\n Consequently, comparing two `SystemTime` instances to learn about the\n duration between them returns a [`Result`] instead of an infallible [`Duration`]\n to indicate that this sort of time drift may happen and needs to be handled.\n\n Although a `SystemTime` cannot be directly inspected, the [`UNIX_EPOCH`]\n constant is provided in this module as an anchor in time to learn\n information about a `SystemTime`. By calculating the duration from this\n fixed point in time, a `SystemTime` can be converted to a human-readable time,\n or perhaps some other string representation.\n\n The size of a `SystemTime` struct may vary depending on the target operating\n system.\n\n A `SystemTime` does not count leap seconds.\n `SystemTime::now()`'s behavior around a leap second\n is the same as the operating system's wall clock.\n The precise behavior near a leap second\n (e.g. whether the clock appears to run slow or fast, or stop, or jump)\n depends on platform and configuration,\n so should not be relied on.\n\n Example:\n\n ```no_run\n use std::time::{Duration, SystemTime};\n use std::thread::sleep;\n\n fn main() {\n    let now = SystemTime::now();\n\n    // we sleep for 2 seconds\n    sleep(Duration::new(2, 0));\n    match now.elapsed() {\n        Ok(elapsed) => {\n            // it prints '2'\n            println!(\"{}\", elapsed.as_secs());\n        }\n        Err(e) => {\n            // the system clock went backwards!\n            println!(\"Great Scott! {e:?}\");\n        }\n    }\n }\n ```\n\n # Platform-specific behavior\n\n The precision of `SystemTime` can depend on the underlying OS-specific time format.\n For example, on Windows the time is represented in 100 nanosecond intervals whereas Linux\n can represent nanosecond intervals.\n\n The following system calls are [currently] being used by `now()` to find out\n the current time:\n\n |  Platform |               System call                                            |\n |-----------|----------------------------------------------------------------------|\n | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n | UNIX      | [clock_gettime (Realtime Clock)]                                     |\n | Darwin    | [clock_gettime (Realtime Clock)]                                     |\n | VXWorks   | [clock_gettime (Realtime Clock)]                                     |\n | SOLID     | `SOLID_RTC_ReadTime`                                                 |\n | WASI      | [__wasi_clock_time_get (Realtime Clock)]                             |\n | Windows   | [GetSystemTimePreciseAsFileTime] / [GetSystemTimeAsFileTime]         |\n\n [currently]: crate::io#platform-specific-behavior\n [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time\n [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode\n [clock_gettime (Realtime Clock)]: https://linux.die.net/man/3/clock_gettime\n [__wasi_clock_time_get (Realtime Clock)]: https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#clock_time_get\n [GetSystemTimePreciseAsFileTime]: https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime\n [GetSystemTimeAsFileTime]: https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime\n\n **Disclaimer:** These system calls might change over time.\n\n > Note: mathematical operations like [`add`] may panic if the underlying\n > structure cannot represent the new point in time.\n\n [`add`]: SystemTime::add\n [`UNIX_EPOCH`]: SystemTime::UNIX_EPOCH\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::pal::unix::time::SystemTime": [
      "Ref"
    ],
    "time::SystemTime": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::time::Duration": [
      "Ref",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::time::SystemTime::checked_sub"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/time.rs:600:5: 602:6",
  "src": "pub fn checked_sub(&self, duration: Duration) -> Option<SystemTime> {\n        self.0.checked_sub_duration(&duration).map(SystemTime)\n    }",
  "mir": "fn time::SystemTime::checked_sub(_1: &time::SystemTime, _2: core::time::Duration) -> core::option::Option<time::SystemTime> {\n    let mut _0: core::option::Option<time::SystemTime>;\n    let mut _3: core::option::Option<sys::pal::unix::time::SystemTime>;\n    let mut _4: &sys::pal::unix::time::SystemTime;\n    let  _5: &core::time::Duration;\n    debug self => _1;\n    debug duration => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: sys::pal::unix::time::SystemTime);\n        _5 = &_2;\n        _3 = sys::pal::unix::time::SystemTime::checked_sub_duration(move _4, _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = core::option::Option::<sys::pal::unix::time::SystemTime>::map::<time::SystemTime, fn(sys::pal::unix::time::SystemTime) -> time::SystemTime {time::SystemTime}>(move _3, time::SystemTime) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n `SystemTime` (which means it's inside the bounds of the underlying data structure), `None`\n otherwise.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}