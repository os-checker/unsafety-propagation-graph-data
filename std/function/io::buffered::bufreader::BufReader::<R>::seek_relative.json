{
  "name": "io::buffered::bufreader::BufReader::<R>::seek_relative",
  "safe": true,
  "callees": {
    "io::buffered::bufreader::buffer::Buffer::pos": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "ImmutableAsArgument"
      }
    },
    "core::num::<impl u64>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "io::buffered::bufreader::buffer::Buffer::unconsume": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "MutableAsArgument"
      }
    },
    "core::num::<impl u64>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "io::buffered::bufreader::buffer::Buffer::filled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "ImmutableAsArgument"
      }
    },
    "io::buffered::bufreader::buffer::Buffer::consume": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "MutableAsArgument"
      }
    },
    "io::Seek::seek": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Seek to an offset, in bytes, in a stream.\n\n A seek beyond the end of a stream is allowed, but behavior is defined\n by the implementation.\n\n If the seek operation completed successfully,\n this method returns the new position from the start of the stream.\n That position can be used later with [`SeekFrom::Start`].\n\n # Errors\n\n Seeking can fail, for example because it might involve flushing a buffer.\n\n Seeking to a negative offset is considered an error.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    }
  },
  "adts": {
    "io::buffered::bufreader::buffer::Buffer": [
      "Ref",
      "MutRef"
    ],
    "io::buffered::bufreader::BufReader": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "io::SeekFrom": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::buffered::bufreader::BufReader::<R>::seek_relative"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:293:5: 308:6",
  "src": "pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n        let pos = self.buf.pos() as u64;\n        if offset < 0 {\n            if let Some(_) = pos.checked_sub((-offset) as u64) {\n                self.buf.unconsume((-offset) as usize);\n                return Ok(());\n            }\n        } else if let Some(new_pos) = pos.checked_add(offset as u64) {\n            if new_pos <= self.buf.filled() as u64 {\n                self.buf.consume(offset as usize);\n                return Ok(());\n            }\n        }\n\n        self.seek(SeekFrom::Current(offset)).map(drop)\n    }",
  "mir": "fn io::buffered::bufreader::BufReader::<R>::seek_relative(_1: &mut io::buffered::bufreader::BufReader<R>, _2: i64) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let  _3: u64;\n    let mut _4: usize;\n    let mut _5: &io::buffered::bufreader::buffer::Buffer;\n    let mut _6: bool;\n    let mut _7: core::option::Option<u64>;\n    let mut _8: u64;\n    let mut _9: i64;\n    let mut _10: bool;\n    let mut _11: isize;\n    let  _12: ();\n    let mut _13: &mut io::buffered::bufreader::buffer::Buffer;\n    let mut _14: usize;\n    let mut _15: i64;\n    let mut _16: bool;\n    let mut _17: core::option::Option<u64>;\n    let mut _18: u64;\n    let mut _19: isize;\n    let  _20: u64;\n    let mut _21: bool;\n    let mut _22: u64;\n    let mut _23: usize;\n    let mut _24: &io::buffered::bufreader::buffer::Buffer;\n    let  _25: ();\n    let mut _26: &mut io::buffered::bufreader::buffer::Buffer;\n    let mut _27: usize;\n    let mut _28: core::result::Result<u64, io::error::Error>;\n    let mut _29: io::SeekFrom;\n    debug self => _1;\n    debug offset => _2;\n    debug pos => _3;\n    debug new_pos => _20;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        _4 = io::buffered::bufreader::buffer::Buffer::pos(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = move _4 as u64;\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = Lt(_2, 0_i64);\n        switchInt(move _6) -> [0: bb9, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _10 = Eq(_2, i64::MIN);\n        assert(!move _10, \"attempt to negate `{}`, which would overflow\", _2) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = Neg(_2);\n        _8 = move _9 as u64;\n        StorageDead(_9);\n        _7 = core::num::<impl u64>::checked_sub(_3, move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _11 = discriminant(_7);\n        switchInt(move _11) -> [1: bb5, 0: bb8, otherwise: bb22];\n    }\n    bb5: {\n        StorageLive(_13);\n        _13 = &mut ((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        StorageLive(_14);\n        StorageLive(_15);\n        _16 = Eq(_2, i64::MIN);\n        assert(!move _16, \"attempt to negate `{}`, which would overflow\", _2) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _15 = Neg(_2);\n        _14 = move _15 as usize;\n        StorageDead(_15);\n        _12 = io::buffered::bufreader::buffer::Buffer::unconsume(move _13, move _14) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _0 = core::result::Result::Ok(());\n        StorageDead(_7);\n        goto -> bb20;\n    }\n    bb8: {\n        StorageDead(_7);\n        goto -> bb17;\n    }\n    bb9: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _2 as u64;\n        _17 = core::num::<impl u64>::checked_add(_3, move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        _19 = discriminant(_17);\n        switchInt(move _19) -> [1: bb11, 0: bb16, otherwise: bb22];\n    }\n    bb11: {\n        _20 = ((_17 as variant#1).0: u64);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        _23 = io::buffered::bufreader::buffer::Buffer::filled(move _24) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        _22 = move _23 as u64;\n        StorageDead(_23);\n        _21 = Le(_20, move _22);\n        switchInt(move _21) -> [0: bb15, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_22);\n        StorageLive(_26);\n        _26 = &mut ((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        StorageLive(_27);\n        _27 = _2 as usize;\n        _25 = io::buffered::bufreader::buffer::Buffer::consume(move _26, move _27) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        StorageDead(_26);\n        _0 = core::result::Result::Ok(());\n        StorageDead(_21);\n        StorageDead(_17);\n        goto -> bb20;\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_17);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_17);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_6);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = io::SeekFrom::Current(_2);\n        _28 = <io::buffered::bufreader::BufReader<R> as io::Seek>::seek(_1, move _29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_29);\n        _0 = core::result::Result::<u64, io::error::Error>::map::<(), fn(u64) {core::mem::drop::<u64>}>(move _28, core::mem::drop::<u64>) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_28);\n        goto -> bb21;\n    }\n    bb20: {\n        StorageDead(_6);\n        goto -> bb21;\n    }\n    bb21: {\n        return;\n    }\n    bb22: {\n        unreachable;\n    }\n}\n",
  "doc": " Seeks relative to the current position. If the new position lies within the buffer,\n the buffer will not be flushed, allowing for more efficient seeks.\n This method does not return the location of the underlying reader, so the caller\n must track this information themselves if it is required.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}