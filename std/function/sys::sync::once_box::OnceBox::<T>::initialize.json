{
  "name": "sys::sync::once_box::OnceBox::<T>::initialize",
  "safe": true,
  "callees": {
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::pin::Pin::<Ptr>::into_inner_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unwraps this `Pin<Ptr>`, returning the underlying `Ptr`.\n\n # Safety\n\n This function is unsafe. You must guarantee that you will continue to\n treat the pointer `Ptr` as pinned after you call this function, so that\n the invariants on the `Pin` type can be upheld. If the code using the\n resulting `Ptr` does not continue to maintain the pinning invariants that\n is a violation of the API contract and may lead to undefined behavior in\n later (safe) operations.\n\n Note that you must be able to guarantee that the data pointed to by `Ptr`\n will be treated as pinned all the way until its `drop` handler is complete!\n\n *For more information, see the [`pin` module docs][self]*\n\n If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used\n instead.\n",
      "adt": {}
    },
    "alloc_crate::boxed::Box::<T>::into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the `Box`, returning a wrapped raw pointer.\n\n The pointer will be properly aligned and non-null.\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Box`. In particular, the\n caller should properly destroy `T` and release the memory, taking\n into account the [memory layout] used by `Box`. The easiest way to\n do this is to convert the raw pointer back into a `Box` with the\n [`Box::from_raw`] function, allowing the `Box` destructor to perform\n the cleanup.\n\n Note: this is an associated function, which means that you have\n to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n is so that there is no conflict with a method on the inner type.\n\n # Examples\n Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n for automatic cleanup:\n ```\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n let x = unsafe { Box::from_raw(ptr) };\n ```\n Manual cleanup by explicitly running the destructor and deallocating\n the memory:\n ```\n use std::alloc::{dealloc, Layout};\n use std::ptr;\n\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n unsafe {\n     ptr::drop_in_place(ptr);\n     dealloc(ptr as *mut u8, Layout::new::<String>());\n }\n ```\n Note: This is equivalent to the following:\n ```\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n unsafe {\n     drop(Box::from_raw(ptr));\n }\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {}
    },
    "core::ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicPtr::<T>::compare_exchange": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the pointer if the current value is the same as the `current` value.\n\n The return value is a result indicating whether the new value was written and containing\n the previous value. On success this value is guaranteed to be equal to `current`.\n\n `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. `success` describes the required ordering for the\n read-modify-write operation that takes place if the comparison with `current` succeeds.\n `failure` describes the required ordering for the load operation that takes place when\n the comparison fails. Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n\n **Note:** This method is only available on platforms that support atomic\n operations on pointers.\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicPtr, Ordering};\n\n let ptr = &mut 5;\n let some_ptr = AtomicPtr::new(ptr);\n\n let other_ptr = &mut 10;\n\n let value = some_ptr.compare_exchange(ptr, other_ptr,\n                                       Ordering::SeqCst, Ordering::Relaxed);\n ```\n\n # Considerations\n\n `compare_exchange` is a [compare-and-swap operation] and thus exhibits the usual downsides\n of CAS operations. In particular, a load of the value followed by a successful\n `compare_exchange` with the previous load *does not ensure* that other threads have not\n changed the value in the interim. This is usually important when the *equality* check in\n the `compare_exchange` is being used to check the *identity* of a value, but equality\n does not necessarily imply identity. This is a particularly common case for pointers, as\n a pointer holding the same address does not imply that the same object exists at that\n address! In this case, `compare_exchange` can lead to the [ABA problem].\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n",
      "adt": {}
    },
    "alloc_crate::boxed::Box::<T>::from_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a box from a raw pointer.\n\n After calling this function, the raw pointer is owned by the\n resulting `Box`. Specifically, the `Box` destructor will call\n the destructor of `T` and free the allocated memory. For this\n to be safe, the memory must have been allocated in accordance\n with the [memory layout] used by `Box` .\n\n # Safety\n\n This function is unsafe because improper use may lead to\n memory problems. For example, a double-free may occur if the\n function is called twice on the same raw pointer.\n\n The raw pointer must point to a block of memory allocated by the global allocator.\n\n The safety conditions are described in the [memory layout] section.\n\n # Examples\n\n Recreate a `Box` which was previously converted to a raw pointer\n using [`Box::into_raw`]:\n ```\n let x = Box::new(5);\n let ptr = Box::into_raw(x);\n let x = unsafe { Box::from_raw(ptr) };\n ```\n Manually create a `Box` from scratch by using the global allocator:\n ```\n use std::alloc::{alloc, Layout};\n\n unsafe {\n     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n     // In general .write is required to avoid attempting to destruct\n     // the (uninitialized) previous contents of `ptr`, though for this\n     // simple example `*ptr = 5` would have worked as well.\n     ptr.write(5);\n     let x = Box::from_raw(ptr);\n }\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "core::pin::Pin::<Ptr>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Pin<Ptr>` around a reference to some data of a type that\n may or may not implement [`Unpin`].\n\n If `pointer` dereferences to an [`Unpin`] type, [`Pin::new`] should be used\n instead.\n\n # Safety\n\n This constructor is unsafe because we cannot guarantee that the data\n pointed to by `pointer` is pinned. At its core, pinning a value means making the\n guarantee that the value's data will not be moved nor have its storage invalidated until\n it gets dropped. For a more thorough explanation of pinning, see the [`pin` module docs].\n\n If the caller that is constructing this `Pin<Ptr>` does not ensure that the data `Ptr`\n points to is pinned, that is a violation of the API contract and may lead to undefined\n behavior in later (even safe) operations.\n\n By using this method, you are also making a promise about the [`Deref`],\n [`DerefMut`], and [`Drop`] implementations of `Ptr`, if they exist. Most importantly, they\n must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\n will call `DerefMut::deref_mut` and `Deref::deref` *on the pointer type `Ptr`*\n and expect these methods to uphold the pinning invariants.\n Moreover, by calling this method you promise that the reference `Ptr`\n dereferences to will not be moved out of again; in particular, it\n must not be possible to obtain a `&mut Ptr::Target` and then\n move out of that reference (using, for example [`mem::swap`]).\n\n For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\n while you are able to pin it for the given lifetime `'a`, you have no control\n over whether it is kept pinned once `'a` ends, and therefore cannot uphold the\n guarantee that a value, once pinned, remains pinned until it is dropped:\n\n ```\n use std::mem;\n use std::pin::Pin;\n\n fn move_pinned_ref<T>(mut a: T, mut b: T) {\n     unsafe {\n         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n         // This should mean the pointee `a` can never move again.\n     }\n     mem::swap(&mut a, &mut b); // Potential UB down the road ⚠️\n     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n     // though we have previously pinned it! We have violated the pinning API contract.\n }\n ```\n A value, once pinned, must remain pinned until it is dropped (unless its type implements\n `Unpin`). Because `Pin<&mut T>` does not own the value, dropping the `Pin` will not drop\n the value and will not end the pinning contract. So moving the value after dropping the\n `Pin<&mut T>` is still a violation of the API contract.\n\n Similarly, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\n aliases to the same data that are not subject to the pinning restrictions:\n ```\n use std::rc::Rc;\n use std::pin::Pin;\n\n fn move_pinned_rc<T>(mut x: Rc<T>) {\n     // This should mean the pointee can never move again.\n     let pin = unsafe { Pin::new_unchecked(Rc::clone(&x)) };\n     {\n         let p: Pin<&T> = pin.as_ref();\n         // ...\n     }\n     drop(pin);\n\n     let content = Rc::get_mut(&mut x).unwrap(); // Potential UB down the road ⚠️\n     // Now, if `x` was the only reference, we have a mutable reference to\n     // data that we pinned above, which we could use to move it as we have\n     // seen in the previous example. We have violated the pinning API contract.\n }\n ```\n\n ## Pinning of closure captures\n\n Particular care is required when using `Pin::new_unchecked` in a closure:\n `Pin::new_unchecked(&mut var)` where `var` is a by-value (moved) closure capture\n implicitly makes the promise that the closure itself is pinned, and that *all* uses\n of this closure capture respect that pinning.\n ```\n use std::pin::Pin;\n use std::task::Context;\n use std::future::Future;\n\n fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n     // Create a closure that moves `x`, and then internally uses it in a pinned way.\n     let mut closure = move || unsafe {\n         let _ignore = Pin::new_unchecked(&mut x).poll(cx);\n     };\n     // Call the closure, so the future can assume it has been pinned.\n     closure();\n     // Move the closure somewhere else. This also moves `x`!\n     let mut moved = closure;\n     // Calling it again means we polled the future from two different locations,\n     // violating the pinning API contract.\n     moved(); // Potential UB ⚠️\n }\n ```\n When passing a closure to another API, it might be moving the closure any time, so\n `Pin::new_unchecked` on closure captures may only be used if the API explicitly documents\n that the closure is pinned.\n\n The better alternative is to avoid all that trouble and do the pinning in the outer function\n instead (here using the [`pin!`][crate::pin::pin] macro):\n ```\n use std::pin::pin;\n use std::task::Context;\n use std::future::Future;\n\n fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n     let mut x = pin!(x);\n     // Create a closure that captures `x: Pin<&mut _>`, which is safe to move.\n     let mut closure = move || {\n         let _ignore = x.as_mut().poll(cx);\n     };\n     // Call the closure, so the future can assume it has been pinned.\n     closure();\n     // Move the closure somewhere else.\n     let mut moved = closure;\n     // Calling it again here is fine (except that we might be polling a future that already\n     // returned `Poll::Ready`, but that is a separate problem).\n     moved();\n }\n ```\n\n [`mem::swap`]: crate::mem::swap\n [`pin` module docs]: self\n",
      "adt": {}
    }
  },
  "adts": {
    "core::pin::Pin": [
      "Plain"
    ],
    "alloc_crate::boxed::Box": [
      "Plain"
    ],
    "core::sync::atomic::AtomicPtr": [
      "Ref"
    ],
    "sys::sync::once_box::OnceBox": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 548, kind: RigidTy(RawPtr(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])"
    ]
  },
  "path": 4302,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/once_box.rs:62:5: 73:6",
  "src": "fn initialize(&self, f: impl FnOnce() -> Pin<Box<T>>) -> Pin<&T> {\n        let new_ptr = Box::into_raw(unsafe { Pin::into_inner_unchecked(f()) });\n        match self.ptr.compare_exchange(null_mut(), new_ptr, Release, Acquire) {\n            Ok(_) => unsafe { Pin::new_unchecked(&*new_ptr) },\n            Err(ptr) => {\n                // Lost the race to another thread.\n                // Drop the value we created, and use the one from the other thread instead.\n                drop(unsafe { Box::from_raw(new_ptr) });\n                unsafe { Pin::new_unchecked(&*ptr) }\n            }\n        }\n    }",
  "mir": "fn sys::sync::once_box::OnceBox::<T>::initialize(_1: &sys::sync::once_box::OnceBox<T>, _2: impl FnOnce() -> Pin<Box<T>>) -> core::pin::Pin<&T> {\n    let mut _0: core::pin::Pin<&T>;\n    let  _3: *mut T;\n    let mut _4: alloc_crate::boxed::Box<T>;\n    let mut _5: core::pin::Pin<alloc_crate::boxed::Box<T>>;\n    let mut _6: core::result::Result<*mut T, *mut T>;\n    let mut _7: &core::sync::atomic::AtomicPtr<T>;\n    let mut _8: *mut T;\n    let mut _9: core::sync::atomic::Ordering;\n    let mut _10: core::sync::atomic::Ordering;\n    let mut _11: isize;\n    let  _12: &T;\n    let  _13: *mut T;\n    let  _14: ();\n    let mut _15: alloc_crate::boxed::Box<T>;\n    let  _16: &T;\n    let mut _17: *const ();\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: bool;\n    let mut _22: *const ();\n    let mut _23: usize;\n    let mut _24: usize;\n    let mut _25: usize;\n    let mut _26: bool;\n    let mut _27: *const ();\n    let mut _28: usize;\n    let mut _29: bool;\n    let mut _30: bool;\n    let mut _31: bool;\n    let mut _32: *const ();\n    let mut _33: usize;\n    let mut _34: bool;\n    let mut _35: bool;\n    let mut _36: bool;\n    debug self => _1;\n    debug f => _2;\n    debug new_ptr => _3;\n    debug ptr => _13;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = <impl FnOnce() -> Pin<Box<T>> as core::ops::FnOnce<()>>::call_once(_2, ()) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = core::pin::Pin::<alloc_crate::boxed::Box<T>>::into_inner_unchecked(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = alloc_crate::boxed::Box::<T>::into_raw(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &((*_1).0: core::sync::atomic::AtomicPtr<T>);\n        StorageLive(_8);\n        _8 = core::ptr::null_mut::<T>() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_9);\n        _9 = core::sync::atomic::Ordering::Release;\n        StorageLive(_10);\n        _10 = core::sync::atomic::Ordering::Acquire;\n        _6 = core::sync::atomic::AtomicPtr::<T>::compare_exchange(move _7, move _8, _3, move _9, move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        _11 = discriminant(_6);\n        switchInt(move _11) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        StorageLive(_13);\n        _13 = ((_6 as variant#1).0: *mut T);\n        StorageLive(_15);\n        _15 = alloc_crate::boxed::Box::<T>::from_raw(_3) -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _22 = _3 as *const ();\n        _23 = _22 as usize;\n        _24 = Sub(<T as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _25 = BitAnd(_23, _24);\n        _26 = Eq(_25, 0_usize);\n        assert(_26, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<T as core::mem::SizedTypeProperties>::ALIGN, _23) -> [success: bb15, unwind unreachable];\n    }\n    bb9: {\n        goto -> bb13;\n    }\n    bb10: {\n        _14 = core::mem::drop::<alloc_crate::boxed::Box<T>>(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        _17 = _13 as *const ();\n        _18 = _17 as usize;\n        _19 = Sub(<T as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _20 = BitAnd(_18, _19);\n        _21 = Eq(_20, 0_usize);\n        assert(_21, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<T as core::mem::SizedTypeProperties>::ALIGN, _18) -> [success: bb14, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_13);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageDead(_6);\n        return;\n    }\n    bb14: {\n        _32 = _13 as *const ();\n        _33 = _32 as usize;\n        _34 = Eq(_33, 0_usize);\n        _35 = BitAnd(_34, true);\n        _36 = Not(_35);\n        assert(_36, \"null pointer dereference occurred\") -> [success: bb17, unwind unreachable];\n    }\n    bb15: {\n        _27 = _3 as *const ();\n        _28 = _27 as usize;\n        _29 = Eq(_28, 0_usize);\n        _30 = BitAnd(_29, true);\n        _31 = Not(_30);\n        assert(_31, \"null pointer dereference occurred\") -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _12 = &(*_3);\n        _0 = core::pin::Pin::<&T>::new_unchecked(_12) -> [return: bb9, unwind unreachable];\n    }\n    bb17: {\n        _16 = &(*_13);\n        _0 = core::pin::Pin::<&T>::new_unchecked(_16) -> [return: bb12, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}