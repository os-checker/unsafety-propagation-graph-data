{
  "name": "<io::buffered::bufreader::BufReader<T> as sys::io::kernel_copy::linux::CopyRead>::drain_to",
  "safe": true,
  "callees": {
    "io::buffered::bufreader::BufReader::<R>::buffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the internally buffered data.\n\n Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n\n [`fill_buf`]: BufRead::fill_buf\n\n # Examples\n\n ```no_run\n use std::io::{BufReader, BufRead};\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let f = File::open(\"log.txt\")?;\n     let mut reader = BufReader::new(f);\n     assert!(reader.buffer().is_empty());\n\n     if reader.fill_buf()?.len() > 0 {\n         assert!(!reader.buffer().is_empty());\n     }\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::buffered::bufreader::BufReader": "ImmutableAsArgument"
      }
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Result::unwrap_or_else\n\n # Examples\n\n ```\n let default = 2;\n let x: Result<u32, &str> = Ok(9);\n assert_eq!(x.unwrap_or(default), 9);\n\n let x: Result<u32, &str> = Err(\"error\");\n assert_eq!(x.unwrap_or(default), default);\n ```\n",
      "adt": {}
    },
    "core::cmp::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::min`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::min(1, 2), 1);\n assert_eq!(cmp::min(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::min(Equal(\"v1\"), Equal(\"v2\")).0, \"v1\");\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "io::Write::write_all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to write an entire buffer into this writer.\n\n This method will continuously call [`write`] until there is no more data\n to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n returned. This method will not return until the entire buffer has been\n successfully written or such an error occurs. The first error that is\n not of [`ErrorKind::Interrupted`] kind generated from this method will be\n returned.\n\n If the buffer contains no data, this will never call [`write`].\n\n # Errors\n\n This function will return the first error of\n non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n\n [`write`]: Write::write\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     buffer.write_all(b\"some bytes\")?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "io::BufRead::consume": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marks the given `amount` of additional bytes from the internal buffer as having been read.\n Subsequent calls to `read` only return bytes that have not been marked as read.\n\n This is a lower-level method and is meant to be used together with [`fill_buf`],\n which can be used to fill the internal buffer via `Read` methods.\n\n It is a logic error if `amount` exceeds the number of unread bytes in the internal buffer, which is returned by [`fill_buf`].\n\n # Examples\n\n Since `consume()` is meant to be used with [`fill_buf`],\n that method's example includes an example of `consume()`.\n\n [`fill_buf`]: BufRead::fill_buf\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::buffered::bufreader::BufReader::<R>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the underlying reader.\n\n It is inadvisable to directly read from the underlying reader.\n\n # Examples\n\n ```no_run\n use std::io::BufReader;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let f1 = File::open(\"log.txt\")?;\n     let mut reader = BufReader::new(f1);\n\n     let f2 = reader.get_mut();\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::buffered::bufreader::BufReader": "MutableAsArgument"
      }
    },
    "sys::io::kernel_copy::linux::CopyRead::drain_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Implementations that contain buffers (i.e. `BufReader`) must transfer data from their internal\n buffers into `writer` until either the buffers are emptied or `limit` bytes have been\n transferred, whichever occurs sooner.\n If nested buffers are present the outer buffers must be drained first.\n\n This is necessary to directly bypass the wrapper types while preserving the data order\n when operating directly on the underlying file descriptors.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "io::buffered::bufreader::BufReader": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])"
    ]
  },
  "path": 1304,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/io/kernel_copy/linux.rs:509:5: 522:6",
  "src": "fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let buf = self.buffer();\n        let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n        let bytes = buf.len();\n        writer.write_all(buf)?;\n        self.consume(bytes);\n\n        let remaining = outer_limit - bytes as u64;\n\n        // in case of nested bufreaders we also need to drain the ones closer to the source\n        let inner_bytes = self.get_mut().drain_to(writer, remaining)?;\n\n        Ok(bytes as u64 + inner_bytes)\n    }",
  "mir": "fn <io::buffered::bufreader::BufReader<T> as sys::io::kernel_copy::linux::CopyRead>::drain_to(_1: &mut io::buffered::bufreader::BufReader<T>, _2: &mut W, _3: u64) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let  _4: &[u8];\n    let mut _5: &io::buffered::bufreader::BufReader<T>;\n    let  _6: &[u8];\n    let mut _7: core::ops::Range<usize>;\n    let mut _8: usize;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: core::result::Result<usize, core::num::TryFromIntError>;\n    let  _12: usize;\n    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _14: core::result::Result<(), io::error::Error>;\n    let mut _15: isize;\n    let  _16: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _17: ();\n    let  _18: u64;\n    let mut _19: u64;\n    let mut _20: (u64, bool);\n    let mut _21: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _22: core::result::Result<u64, io::error::Error>;\n    let mut _23: &mut T;\n    let mut _24: isize;\n    let  _25: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _26: u64;\n    let mut _27: u64;\n    let mut _28: u64;\n    let mut _29: (u64, bool);\n    debug self => _1;\n    debug writer => _2;\n    debug outer_limit => _3;\n    debug buf => _4;\n    debug buf => _6;\n    debug bytes => _12;\n    debug residual => _16;\n    debug val => ();\n    debug remaining => _18;\n    debug inner_bytes => _26;\n    debug residual => _25;\n    debug val => _26;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = io::buffered::bufreader::BufReader::<T>::buffer(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = PtrMetadata(_4);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = <u64 as core::convert::TryInto<usize>>::try_into(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _10 = core::result::Result::<usize, core::num::TryFromIntError>::unwrap_or(move _11, core::num::<impl usize>::MAX) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _8 = core::cmp::min::<usize>(move _9, move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageDead(_9);\n        _7 = Range(0_usize, move _8);\n        StorageDead(_8);\n        _6 = <[u8] as core::ops::Index<core::ops::Range<usize>>>::index(_4, move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _12 = PtrMetadata(_6);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = <W as io::Write>::write_all(_2, _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _14) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_14);\n        _15 = discriminant(_13);\n        switchInt(move _15) -> [0: bb9, 1: bb10, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        StorageDead(_13);\n        _17 = <io::buffered::bufreader::BufReader<T> as io::BufRead>::consume(_1, _12) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _16 = move ((_13 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_16) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        goto -> bb21;\n    }\n    bb12: {\n        StorageLive(_19);\n        _19 = _12 as u64;\n        _20 = CheckedSub(_3, _19);\n        assert(!move (_20.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, move _19) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = move (_20.0: u64);\n        StorageDead(_19);\n        StorageLive(_21);\n        StorageLive(_22);\n        _23 = io::buffered::bufreader::BufReader::<T>::get_mut(_1) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _22 = <T as sys::io::kernel_copy::linux::CopyRead>::drain_to::<W>(_23, _2, _18) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _21 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_22);\n        _24 = discriminant(_21);\n        switchInt(move _24) -> [0: bb17, 1: bb18, otherwise: bb8];\n    }\n    bb17: {\n        _26 = ((_21 as variant#0).0: u64);\n        StorageDead(_21);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _12 as u64;\n        _29 = CheckedAdd(_28, _26);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _28, _26) -> [success: bb20, unwind unreachable];\n    }\n    bb18: {\n        _25 = move ((_21 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_25) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_21);\n        goto -> bb21;\n    }\n    bb20: {\n        _27 = move (_29.0: u64);\n        StorageDead(_28);\n        _0 = core::result::Result::Ok(move _27);\n        StorageDead(_27);\n        goto -> bb22;\n    }\n    bb21: {\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}