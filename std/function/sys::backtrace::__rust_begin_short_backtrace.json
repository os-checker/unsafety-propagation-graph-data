{
  "name": "sys::backtrace::__rust_begin_short_backtrace",
  "safe": true,
  "callees": {
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::hint::black_box": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n `black_box` could do.\n\n Unlike [`std::convert::identity`], a Rust compiler is encouraged to assume that `black_box` can\n use `dummy` in any possible valid way that Rust code is allowed to without introducing undefined\n behavior in the calling code. This property makes `black_box` useful for writing code in which\n certain optimizations are not desired, such as benchmarks.\n\n <div class=\"warning\">\n\n Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n extent to which it can block optimisations may vary depending upon the platform and code-gen\n backend used. Programs cannot rely on `black_box` for *correctness*, beyond it behaving as the\n identity function. As such, it **must not be relied upon to control critical program behavior.**\n This also means that this function does not offer any guarantees for cryptographic or security\n purposes.\n\n This limitation is not specific to `black_box`; there is no mechanism in the entire Rust\n language that can provide the guarantees required for constant-time cryptography.\n (There is also no such mechanism in LLVM, so the same is true for every other LLVM-based compiler.)\n\n </div>\n\n [`std::convert::identity`]: crate::convert::identity\n\n # When is this useful?\n\n While not suitable in those mission-critical cases, `black_box`'s functionality can generally be\n relied upon for benchmarking, and should be used there. It will try to ensure that the\n compiler doesn't optimize away part of the intended test code based on context. For\n example:\n\n ```\n fn contains(haystack: &[&str], needle: &str) -> bool {\n     haystack.iter().any(|x| x == &needle)\n }\n\n pub fn benchmark() {\n     let haystack = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"];\n     let needle = \"ghi\";\n     for _ in 0..10 {\n         contains(&haystack, needle);\n     }\n }\n ```\n\n The compiler could theoretically make optimizations like the following:\n\n - The `needle` and `haystack` do not change, move the call to `contains` outside the loop and\n   delete the loop\n - Inline `contains`\n - `needle` and `haystack` have values known at compile time, `contains` is always true. Remove\n   the call and replace with `true`\n - Nothing is done with the result of `contains`: delete this function call entirely\n - `benchmark` now has no purpose: delete this function\n\n It is not likely that all of the above happens, but the compiler is definitely able to make some\n optimizations that could result in a very inaccurate benchmark. This is where `black_box` comes\n in:\n\n ```\n use std::hint::black_box;\n\n // Same `contains` function.\n fn contains(haystack: &[&str], needle: &str) -> bool {\n     haystack.iter().any(|x| x == &needle)\n }\n\n pub fn benchmark() {\n     let haystack = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"];\n     let needle = \"ghi\";\n     for _ in 0..10 {\n         // Force the compiler to run `contains`, even though it is a pure function whose\n         // results are unused.\n         black_box(contains(\n             // Prevent the compiler from making assumptions about the input.\n             black_box(&haystack),\n             black_box(needle),\n         ));\n     }\n }\n ```\n\n This essentially tells the compiler to block optimizations across any calls to `black_box`. So,\n it now:\n\n - Treats both arguments to `contains` as unpredictable: the body of `contains` can no longer be\n   optimized based on argument values\n - Treats the call to `contains` and its result as volatile: the body of `benchmark` cannot\n   optimize this away\n\n This makes our benchmark much more realistic to how the function would actually be used, where\n arguments are usually not known at compile time and the result is used in some way.\n\n # How to use this\n\n In practice, `black_box` serves two purposes:\n\n 1. It prevents the compiler from making optimizations related to the value returned by `black_box`\n 2. It forces the value passed to `black_box` to be calculated, even if the return value of `black_box` is unused\n\n ```\n use std::hint::black_box;\n\n let zero = 0;\n let five = 5;\n\n // The compiler will see this and remove the `* five` call, because it knows that multiplying\n // any integer by 0 will result in 0.\n let c = zero * five;\n\n // Adding `black_box` here disables the compiler's ability to reason about the first operand in the multiplication.\n // It is forced to assume that it can be any possible number, so it cannot remove the `* five`\n // operation.\n let c = black_box(zero) * five;\n ```\n\n While most cases will not be as clear-cut as the above example, it still illustrates how\n `black_box` can be used. When benchmarking a function, you usually want to wrap its inputs in\n `black_box` so the compiler cannot make optimizations that would be unrealistic in real-life\n use.\n\n ```\n use std::hint::black_box;\n\n // This is a simple function that increments its input by 1. Note that it is pure, meaning it\n // has no side-effects. This function has no effect if its result is unused. (An example of a\n // function *with* side-effects is `println!()`.)\n fn increment(x: u8) -> u8 {\n     x + 1\n }\n\n // Here, we call `increment` but discard its result. The compiler, seeing this and knowing that\n // `increment` is pure, will eliminate this function call entirely. This may not be desired,\n // though, especially if we're trying to track how much time `increment` takes to execute.\n let _ = increment(black_box(5));\n\n // Here, we force `increment` to be executed. This is because the compiler treats `black_box`\n // as if it has side-effects, and thus must compute its input.\n let _ = black_box(increment(black_box(5)));\n ```\n\n There may be additional situations where you want to wrap the result of a function in\n `black_box` to force its execution. This is situational though, and may not have any effect\n (such as when the function returns a zero-sized type such as [`()` unit][unit]).\n\n Note that `black_box` has no effect on how its input is treated, only its output. As such,\n expressions passed to `black_box` may still be optimized:\n\n ```\n use std::hint::black_box;\n\n // The compiler sees this...\n let y = black_box(5 * 10);\n\n // ...as this. As such, it will likely simplify `5 * 10` to just `50`.\n let _0 = 5 * 10;\n let y = black_box(_0);\n ```\n\n In the above example, the `5 * 10` expression is considered distinct from the `black_box` call,\n and thus is still optimized by the compiler. You can prevent this by moving the multiplication\n operation outside of `black_box`:\n\n ```\n use std::hint::black_box;\n\n // No assumptions can be made about either operand, so the multiplication is not optimized out.\n let y = black_box(5) * black_box(10);\n ```\n\n During constant evaluation, `black_box` is treated as a no-op.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "std::sys::backtrace::__rust_begin_short_backtrace"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:156:1: 166:2",
  "src": "pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\nwhere\n    F: FnOnce() -> T,\n{\n    let result = f();\n\n    // prevent this frame from being tail-call optimised away\n    crate::hint::black_box(());\n\n    result\n}",
  "mir": "fn sys::backtrace::__rust_begin_short_backtrace(_1: F) -> T {\n    let mut _0: T;\n    let  _2: ();\n    debug f => _1;\n    debug result => _0;\n    bb0: {\n        _0 = <F as core::ops::FnOnce<()>>::call_once(_1, ()) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::hint::black_box::<()>(()) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n this is only inline(never) when backtraces in std are enabled, otherwise\n it's fine to optimize away.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}