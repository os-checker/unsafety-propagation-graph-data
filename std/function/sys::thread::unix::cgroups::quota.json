{
  "name": "sys::thread::unix::cgroups::quota",
  "safe": true,
  "callees": {
    "alloc_crate::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "fs::File::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to open a file in read-only mode.\n\n See the [`OpenOptions::open`] method for more details.\n\n If you only need to read the entire file contents,\n consider [`std::fs::read()`][self::read] or\n [`std::fs::read_to_string()`][self::read_to_string] instead.\n\n # Errors\n\n This function will return an error if `path` does not already exist.\n Other errors may also be returned according to [`OpenOptions::open`].\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Read;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut data = vec![];\n     f.read_to_end(&mut data)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "io::Read::read_to_end": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes until EOF in this source, placing them into `buf`.\n\n All bytes read from this source will be appended to the specified buffer\n `buf`. This function will continuously call [`read()`] to append more data to\n `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n non-[`ErrorKind::Interrupted`] kind.\n\n If successful, this function will return the total number of bytes read.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If any other read error is encountered then this function immediately\n returns. Any bytes which have already been read will be appended to\n `buf`.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read()`]: Read::read\n [`Ok(0)`]: Ok\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = Vec::new();\n\n     // read the whole file\n     f.read_to_end(&mut buffer)?;\n     Ok(())\n }\n ```\n\n (See also the [`std::fs::read`] convenience function for reading from a\n file.)\n\n [`std::fs::read`]: crate::fs::read\n\n ## Implementing `read_to_end`\n\n When implementing the `io::Read` trait, it is recommended to allocate\n memory using [`Vec::try_reserve`]. However, this behavior is not guaranteed\n by all implementations, and `read_to_end` may not handle out-of-memory\n situations gracefully.\n\n ```no_run\n # use std::io::{self, BufRead};\n # struct Example { example_datasource: io::Empty } impl Example {\n # fn get_some_data_for_the_example(&self) -> &'static [u8] { &[] }\n fn read_to_end(&mut self, dest_vec: &mut Vec<u8>) -> io::Result<usize> {\n     let initial_vec_len = dest_vec.len();\n     loop {\n         let src_buf = self.example_datasource.fill_buf()?;\n         if src_buf.is_empty() {\n             break;\n         }\n         dest_vec.try_reserve(src_buf.len())?;\n         dest_vec.extend_from_slice(src_buf);\n\n         // Any irreversible side effects should happen after `try_reserve` succeeds,\n         // to avoid losing data on allocation error.\n         let read = src_buf.len();\n         self.example_datasource.consume(read);\n     }\n     Ok(dest_vec.len() - initial_vec_len)\n }\n # }\n ```\n\n # Usage Notes\n\n `read_to_end` attempts to read a source until EOF, but many sources are continuous streams\n that do not send EOF. In these cases, `read_to_end` will block indefinitely. Standard input\n is one such stream which may be finite if piped, but is typically continuous. For example,\n `cat file | my-rust-program` will correctly terminate with an `EOF` upon closure of cat.\n Reading user input or running programs that remain open indefinitely will never terminate\n the stream with `EOF` (e.g. `yes | my-rust-program`).\n\n Using `.lines()` with a [`BufReader`] or using [`read`] can provide a better solution\n\n[`read`]: Read::read\n\n [`Vec::try_reserve`]: crate::vec::Vec::try_reserve\n",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::try_trait::residual_into_try_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::slice::<impl [T]>::split": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over subslices separated by elements that match\n `pred`. The matched element is not contained in the subslices.\n\n # Examples\n\n ```\n let slice = [10, 40, 33, 20];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10, 40]);\n assert_eq!(iter.next().unwrap(), &[20]);\n assert!(iter.next().is_none());\n ```\n\n If the first element is matched, an empty slice will be the first item\n returned by the iterator. Similarly, if the last element in the slice\n is matched, an empty slice will be the last item returned by the\n iterator:\n\n ```\n let slice = [10, 40, 33];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10, 40]);\n assert_eq!(iter.next().unwrap(), &[]);\n assert!(iter.next().is_none());\n ```\n\n If two matched elements are directly adjacent, an empty slice will be\n present between them:\n\n ```\n let slice = [10, 6, 33, 20];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10]);\n assert_eq!(iter.next().unwrap(), &[]);\n assert_eq!(iter.next().unwrap(), &[20]);\n assert!(iter.next().is_none());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Folds every element into an accumulator by applying an operation,\n returning the final result.\n\n `fold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `fold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `fold()`, and similar methods that traverse the entire iterator,\n might not terminate for infinite iterators, even on traits for which a\n result is determinable in finite time.\n\n Note: [`reduce()`] can be used to use the first element as the initial\n value, if the accumulator type and item type is the same.\n\n Note: `fold()` combines elements in a *left-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `fold()` on the internal parts\n from which this iterator is composed.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of the array\n let sum = a.iter().fold(0, |acc, x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n Let's walk through each step of the iteration here:\n\n | element | acc | x | result |\n |---------|-----|---|--------|\n |         | 0   |   |        |\n | 1       | 0   | 1 | 1      |\n | 2       | 1   | 2 | 3      |\n | 3       | 3   | 3 | 6      |\n\n And so, our final result, `6`.\n\n This example demonstrates the left-associative nature of `fold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the front until the back:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().fold(zero, |acc, &x| {\n     format!(\"({acc} + {x})\")\n });\n\n assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n ```\n It's common for people who haven't used iterators a lot to\n use a `for` loop with a list of things to build up a result. Those\n can be turned into `fold()`s:\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let mut result = 0;\n\n // for loop:\n for i in &numbers {\n     result = result + i;\n }\n\n // fold:\n let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n // they're the same\n assert_eq!(result, result2);\n ```\n\n [`reduce()`]: Iterator::reduce\n",
      "adt": {}
    },
    "os::unix::ffi::os_str::OsStringExt::from_vec": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an [`OsString`] from a byte vector.\n\n See the module documentation for an example.\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "sys::thread::unix::cgroups::quota_v2": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::PathBuf": "MutableAsArgument"
      }
    },
    "sys::thread::unix::cgroups::quota_v1": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::PathBuf": "MutableAsArgument"
      }
    },
    "core::ops::Try::from_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from its `Output` type.\n\n This should be implemented consistently with the `branch` method\n such that applying the `?` operator will get back the original value:\n `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::Try;\n\n assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n assert_eq!(\n     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n     std::ops::ControlFlow::Continue(5),\n );\n\n # fn make_question_mark_work() -> Option<()> {\n assert_eq!(Option::from_output(4)?, 4);\n # None }\n # make_question_mark_work();\n\n // This is used, for example, on the accumulator in `try_fold`:\n let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n assert_eq!(r, Some(4));\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef",
      "Unknown([Field(0, Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 17446, kind: RigidTy(Adt(AdtDef(DefId { id: 12457, name: \"sys::thread::unix::cgroups::Cgroup\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 17444, kind: RigidTy(Tuple([Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) }, Ty { id: 17446, kind: RigidTy(Adt(AdtDef(DefId { id: 12457, name: \"sys::thread::unix::cgroups::Cgroup\" }), GenericArgs([]))) }])) })])"
    ],
    "fs::File": [
      "Plain",
      "MutRef"
    ],
    "core::slice::Split": [
      "Plain"
    ],
    "sys::thread::unix::cgroups::Cgroup": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 17446, kind: RigidTy(Adt(AdtDef(DefId { id: 12457, name: \"sys::thread::unix::cgroups::Cgroup\" }), GenericArgs([]))) })])"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ],
    "path::PathBuf": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::thread::unix::cgroups::quota"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:658:5: 703:6",
  "src": "pub(super) fn quota() -> usize {\n        let mut quota = usize::MAX;\n        if cfg!(miri) {\n            // Attempting to open a file fails under default flags due to isolation.\n            // And Miri does not have parallelism anyway.\n            return quota;\n        }\n\n        let _: Option<()> = try {\n            let mut buf = Vec::with_capacity(128);\n            // find our place in the cgroup hierarchy\n            File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n            let (cgroup_path, version) =\n                buf.split(|&c| c == b'\\n').fold(None, |previous, line| {\n                    let mut fields = line.splitn(3, |&c| c == b':');\n                    // 2nd field is a list of controllers for v1 or empty for v2\n                    let version = match fields.nth(1) {\n                        Some(b\"\") => Cgroup::V2,\n                        Some(controllers)\n                            if from_utf8(controllers)\n                                .is_ok_and(|c| c.split(',').any(|c| c == \"cpu\")) =>\n                        {\n                            Cgroup::V1\n                        }\n                        _ => return previous,\n                    };\n\n                    // already-found v1 trumps v2 since it explicitly specifies its controllers\n                    if previous.is_some() && version == Cgroup::V2 {\n                        return previous;\n                    }\n\n                    let path = fields.last()?;\n                    // skip leading slash\n                    Some((path[1..].to_owned(), version))\n                })?;\n            let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n\n            quota = match version {\n                Cgroup::V1 => quota_v1(cgroup_path),\n                Cgroup::V2 => quota_v2(cgroup_path),\n            };\n        };\n\n        quota\n    }",
  "mir": "fn sys::thread::unix::cgroups::quota() -> usize {\n    let mut _0: usize;\n    let mut _1: usize;\n    let mut _2: core::option::Option<()>;\n    let mut _3: alloc_crate::vec::Vec<u8>;\n    let mut _4: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;\n    let mut _5: core::option::Option<usize>;\n    let mut _6: core::result::Result<usize, io::error::Error>;\n    let mut _7: &mut fs::File;\n    let mut _8: fs::File;\n    let mut _9: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, fs::File>;\n    let mut _10: core::option::Option<fs::File>;\n    let mut _11: core::result::Result<fs::File, io::error::Error>;\n    let mut _12: isize;\n    let  _13: fs::File;\n    let mut _14: &mut alloc_crate::vec::Vec<u8>;\n    let mut _15: isize;\n    let  _16: usize;\n    let  _17: alloc_crate::vec::Vec<u8>;\n    let  _18: sys::thread::unix::cgroups::Cgroup;\n    let mut _19: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, (alloc_crate::vec::Vec<u8>, sys::thread::unix::cgroups::Cgroup)>;\n    let mut _20: core::option::Option<(alloc_crate::vec::Vec<u8>, sys::thread::unix::cgroups::Cgroup)>;\n    let mut _21: core::slice::Split<'_, u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:671:27: 671:31}>;\n    let  _22: &[u8];\n    let mut _23: &alloc_crate::vec::Vec<u8>;\n    let mut _24: core::option::Option<(alloc_crate::vec::Vec<u8>, sys::thread::unix::cgroups::Cgroup)>;\n    let mut _25: isize;\n    let  _26: (alloc_crate::vec::Vec<u8>, sys::thread::unix::cgroups::Cgroup);\n    let  _27: path::PathBuf;\n    let mut _28: ffi::os_str::OsString;\n    let mut _29: usize;\n    let mut _30: isize;\n    debug quota => _1;\n    debug buf => _3;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _13;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _16;\n    debug cgroup_path => _17;\n    debug version => _18;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _26;\n    debug cgroup_path => _27;\n    bb0: {\n        StorageLive(_1);\n        _1 = core::num::<impl usize>::MAX;\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = alloc_crate::vec::Vec::<u8>::with_capacity(128_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = fs::File::open::<&str>(\"/proc/self/cgroup\") -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _10 = core::result::Result::<fs::File, io::error::Error>::ok(move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _9 = <core::option::Option<fs::File> as core::ops::Try>::branch(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _12 = discriminant(_9);\n        switchInt(move _12) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_13);\n        _13 = move ((_9 as variant#0).0: fs::File);\n        _8 = move _13;\n        StorageDead(_13);\n        _7 = &mut _8;\n        _14 = &mut _3;\n        _6 = <fs::File as io::Read>::read_to_end(move _7, _14) -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _2 = core::ops::try_trait::residual_into_try_type::<core::option::Option<core::convert::Infallible>, ()>(core::option::Option::<core::convert::Infallible>::None) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb35;\n    }\n    bb9: {\n        StorageDead(_7);\n        _5 = core::result::Result::<usize, io::error::Error>::ok(move _6) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_6);\n        _4 = <core::option::Option<usize> as core::ops::Try>::branch(move _5) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_5);\n        _15 = discriminant(_4);\n        switchInt(move _15) -> [0: bb12, 1: bb13, otherwise: bb5];\n    }\n    bb12: {\n        StorageLive(_16);\n        _16 = ((_4 as variant#0).0: usize);\n        StorageDead(_16);\n        drop(_8) -> [return: bb34, unwind unreachable];\n    }\n    bb13: {\n        _2 = core::ops::try_trait::residual_into_try_type::<core::option::Option<core::convert::Infallible>, ()>(core::option::Option::<core::convert::Infallible>::None) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        drop(_8) -> [return: bb35, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        _21 = core::slice::<impl [u8]>::split::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:671:27: 671:31}>(_22, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:671:27: 671:31}) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_24);\n        _24 = core::option::Option::None;\n        _20 = <core::slice::Split<'_, u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:671:27: 671:31}> as core::iter::Iterator>::fold::<core::option::Option<(alloc_crate::vec::Vec<u8>, sys::thread::unix::cgroups::Cgroup)>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:671:55: 671:71}>(move _21, move _24, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:671:55: 671:71}) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_24);\n        StorageDead(_21);\n        _19 = <core::option::Option<(alloc_crate::vec::Vec<u8>, sys::thread::unix::cgroups::Cgroup)> as core::ops::Try>::branch(move _20) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_20);\n        _25 = discriminant(_19);\n        switchInt(move _25) -> [0: bb19, 1: bb20, otherwise: bb5];\n    }\n    bb19: {\n        _26 = move ((_19 as variant#0).0: (alloc_crate::vec::Vec<u8>, sys::thread::unix::cgroups::Cgroup));\n        _17 = (_26.0: alloc_crate::vec::Vec<u8>);\n        StorageLive(_18);\n        _18 = (_26.1: sys::thread::unix::cgroups::Cgroup);\n        StorageDead(_19);\n        StorageLive(_28);\n        _28 = <ffi::os_str::OsString as os::unix::ffi::os_str::OsStringExt>::from_vec(_17) -> [return: bb22, unwind unreachable];\n    }\n    bb20: {\n        _2 = core::ops::try_trait::residual_into_try_type::<core::option::Option<core::convert::Infallible>, ()>(core::option::Option::<core::convert::Infallible>::None) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_19);\n        goto -> bb31;\n    }\n    bb22: {\n        _27 = <path::PathBuf as core::convert::From<ffi::os_str::OsString>>::from(move _28) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_28);\n        StorageLive(_29);\n        _30 = discriminant(_18);\n        switchInt(move _30) -> [0: bb25, 1: bb24, otherwise: bb5];\n    }\n    bb24: {\n        _29 = sys::thread::unix::cgroups::quota_v2(_27) -> [return: bb27, unwind unreachable];\n    }\n    bb25: {\n        _29 = sys::thread::unix::cgroups::quota_v1(_27) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        goto -> bb28;\n    }\n    bb27: {\n        goto -> bb28;\n    }\n    bb28: {\n        _1 = move _29;\n        StorageDead(_29);\n        _2 = <core::option::Option<()> as core::ops::Try>::from_output(()) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_18);\n        drop(_3) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_3);\n        goto -> bb33;\n    }\n    bb31: {\n        drop(_3) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_3);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_2);\n        _0 = _1;\n        StorageDead(_1);\n        return;\n    }\n    bb34: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_4);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_23);\n        _23 = &_3;\n        _22 = <alloc_crate::vec::Vec<u8> as core::ops::Deref>::deref(move _23) -> [return: bb15, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_4);\n        goto -> bb31;\n    }\n}\n",
  "doc": " Returns cgroup CPU quota in core-equivalents, rounded down or usize::MAX if the quota cannot\n be determined or is not set.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}