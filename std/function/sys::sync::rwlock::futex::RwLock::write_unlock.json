{
  "name": "sys::sync::rwlock::futex::RwLock::write_unlock",
  "safe": false,
  "callees": {
    "core::sync::atomic::AtomicU32::fetch_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Subtracts from the current value, returning the previous value.\n\n This operation wraps around on overflow.\n\n `fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Examples\n\n ```\n\n assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\n",
      "adt": {}
    },
    "sys::sync::rwlock::futex::is_unlocked": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::sync::rwlock::futex::has_writers_waiting": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "sys::sync::rwlock::futex::has_readers_waiting": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::sync::rwlock::futex::RwLock::wake_writer_or_readers": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wakes up waiting threads after unlocking.\n\n If both are waiting, this will wake up only one writer, but will fall\n back to waking up readers if there was no writer to wake up.\n",
      "adt": {
        "sys::sync::rwlock::futex::RwLock": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::sync::atomic::AtomicU32": [
      "Ref"
    ],
    "sys::sync::rwlock::futex::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": 4329,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/rwlock/futex.rs:182:5: 190:6",
  "src": "pub unsafe fn write_unlock(&self) {\n        let state = self.state.fetch_sub(WRITE_LOCKED, Release) - WRITE_LOCKED;\n\n        debug_assert!(is_unlocked(state));\n\n        if has_writers_waiting(state) || has_readers_waiting(state) {\n            self.wake_writer_or_readers(state);\n        }\n    }",
  "mir": "fn sys::sync::rwlock::futex::RwLock::write_unlock(_1: &sys::sync::rwlock::futex::RwLock) -> () {\n    let mut _0: ();\n    let  _2: u32;\n    let mut _3: u32;\n    let mut _4: &core::sync::atomic::AtomicU32;\n    let mut _5: core::sync::atomic::Ordering;\n    let mut _6: (u32, bool);\n    let mut _7: bool;\n    let mut _8: !;\n    let mut _9: bool;\n    let mut _10: bool;\n    let  _11: ();\n    debug self => _1;\n    debug state => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: core::sync::atomic::AtomicU32);\n        StorageLive(_5);\n        _5 = core::sync::atomic::Ordering::Release;\n        _3 = core::sync::atomic::AtomicU32::fetch_sub(move _4, sys::sync::rwlock::futex::WRITE_LOCKED, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _6 = CheckedSub(_3, sys::sync::rwlock::futex::WRITE_LOCKED);\n        assert(!move (_6.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _3, sys::sync::rwlock::futex::WRITE_LOCKED) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _2 = move (_6.0: u32);\n        StorageDead(_3);\n        StorageLive(_7);\n        _7 = sys::sync::rwlock::futex::is_unlocked(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _7) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = sys::sync::rwlock::futex::has_writers_waiting(_2) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        _8 = core::panicking::panic(\"assertion failed: is_unlocked(state)\") -> unwind unreachable;\n    }\n    bb6: {\n        switchInt(move _9) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        goto -> bb11;\n    }\n    bb8: {\n        StorageLive(_10);\n        _10 = sys::sync::rwlock::futex::has_readers_waiting(_2) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _10) -> [0: bb13, otherwise: bb10];\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        _11 = sys::sync::rwlock::futex::RwLock::wake_writer_or_readers(_1, _2) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        goto -> bb14;\n    }\n    bb13: {\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_10);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": " # Safety\n\n The `RwLock` must be write-locked (single writer) in order to call this.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}