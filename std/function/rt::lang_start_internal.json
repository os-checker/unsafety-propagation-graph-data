{
  "name": "rt::lang_start_internal",
  "safe": true,
  "callees": {
    "panic::catch_unwind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n\n This function will return `Ok` with the closure's result if the closure does\n not panic, and will return `Err(cause)` if the closure panics. The `cause`\n returned is the object with which panic was originally invoked.\n\n Rust functions that are expected to be called from foreign code that does\n not support unwinding (such as C compiled with `-fno-exceptions`) should be\n defined using `extern \"C\"`, which ensures that if the Rust code panics, it\n is automatically caught and the process is aborted. If this is the desired\n behavior, it is not necessary to use `catch_unwind` explicitly. This\n function should instead be used when more graceful error-handling is needed.\n\n It is **not** recommended to use this function for a general try/catch\n mechanism. The [`Result`] type is more appropriate to use for functions that\n can fail on a regular basis. Additionally, this function is not guaranteed\n to catch all panics, see the \"Notes\" section below.\n\n The closure provided is required to adhere to the [`UnwindSafe`] trait to\n ensure that all captured variables are safe to cross this boundary. The\n purpose of this bound is to encode the concept of [exception safety][rfc] in\n the type system. Most usage of this function should not need to worry about\n this bound as programs are naturally unwind safe without `unsafe` code. If\n it becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to\n quickly assert that the usage here is indeed unwind safe.\n\n [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n\n # Notes\n\n This function **might not catch all Rust panics**. A Rust panic is not\n always implemented via unwinding, but can be implemented by aborting the\n process as well. This function *only* catches unwinding panics, not those\n that abort the process.\n\n If a custom panic hook has been set, it will be invoked before the panic is\n caught, before unwinding.\n\n Although unwinding into Rust code with a foreign exception (e.g. an\n exception thrown from C++ code, or a `panic!` in Rust code compiled or\n linked with a different runtime) via an appropriate ABI (e.g. `\"C-unwind\"`)\n is permitted, catching such an exception using this function will have one\n of two behaviors, and it is unspecified which will occur:\n\n * The process aborts, after executing all destructors of `f` and the\n   functions it called.\n * The function returns a `Result::Err` containing an opaque type.\n\n Finally, be **careful in how you drop the result of this function**. If it\n is `Err`, it contains the panic payload, and dropping that may in turn\n panic!\n\n # Examples\n\n ```\n use std::panic;\n\n let result = panic::catch_unwind(|| {\n     println!(\"hello!\");\n });\n assert!(result.is_ok());\n\n let result = panic::catch_unwind(|| {\n     panic!(\"oh no!\");\n });\n assert!(result.is_err());\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or computes it from a closure.\n\n\n # Examples\n\n ```\n fn count(x: &str) -> usize { x.len() }\n\n assert_eq!(Ok(2).unwrap_or_else(count), 2);\n assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n ```\n",
      "adt": {}
    },
    "rt::handle_rt_panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::rt::lang_start_internal"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:152:1: 195:2",
  "src": "fn lang_start_internal(\n    main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n    argc: isize,\n    argv: *const *const u8,\n    sigpipe: u8,\n) -> isize {\n    // Guard against the code called by this function from unwinding outside of the Rust-controlled\n    // code, which is UB. This is a requirement imposed by a combination of how the\n    // `#[lang=\"start\"]` attribute is implemented as well as by the implementation of the panicking\n    // mechanism itself.\n    //\n    // There are a couple of instances where unwinding can begin. First is inside of the\n    // `rt::init`, `rt::cleanup` and similar functions controlled by std. In those instances a\n    // panic is a std implementation bug. A quite likely one too, as there isn't any way to\n    // prevent std from accidentally introducing a panic to these functions. Another is from\n    // user code from `main` or, more nefariously, as described in e.g. issue #86030.\n    //\n    // We use `catch_unwind` with `handle_rt_panic` instead of `abort_unwind` to make the error in\n    // case of a panic a bit nicer.\n    panic::catch_unwind(move || {\n        // SAFETY: Only called once during runtime initialization.\n        unsafe { init(argc, argv, sigpipe) };\n\n        let ret_code = panic::catch_unwind(main).unwrap_or_else(move |payload| {\n            // Carefully dispose of the panic payload.\n            let payload = panic::AssertUnwindSafe(payload);\n            panic::catch_unwind(move || drop({ payload }.0)).unwrap_or_else(move |e| {\n                mem::forget(e); // do *not* drop the 2nd payload\n                rtabort!(\"drop of the panic payload panicked\");\n            });\n            // Return error code for panicking programs.\n            101\n        });\n        let ret_code = ret_code as isize;\n\n        cleanup();\n        // Guard against multiple threads calling `libc::exit` concurrently.\n        // See the documentation for `unique_thread_exit` for more information.\n        crate::sys::exit_guard::unique_thread_exit();\n\n        ret_code\n    })\n    .unwrap_or_else(handle_rt_panic)\n}",
  "mir": "fn rt::lang_start_internal(_1: &dyn core::ops::Fn() -> i32 + core::marker::Sync + core::panic::RefUnwindSafe, _2: isize, _3: *const *const u8, _4: u8) -> isize {\n    let mut _0: isize;\n    let mut _5: core::result::Result<isize, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>;\n    let mut _6: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:171:25: 171:32};\n    debug main => _1;\n    debug argc => _2;\n    debug argv => _3;\n    debug sigpipe => _4;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:171:25: 171:32}(_2, _3, _4, _1);\n        _5 = panic::catch_unwind::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:171:25: 171:32}, isize>(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _0 = core::result::Result::<isize, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>::unwrap_or_else::<fn(alloc_crate::boxed::Box<(dyn core::any::Any + core::marker::Send + 'static)>) -> isize {rt::handle_rt_panic::<isize>}>(move _5, rt::handle_rt_panic::<isize>) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}