{
  "name": "sys::process::unix::common::cstring_array::CStringArray::write",
  "safe": true,
  "callees": {
    "alloc_crate::vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {}
    },
    "core::ops::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "alloc_crate::ffi::CString::into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the `CString` and transfers ownership of the string to a C caller.\n\n The pointer which this function returns must be returned to Rust and reconstituted using\n [`CString::from_raw`] to be properly deallocated. Specifically, one\n should *not* use the standard C `free()` function to deallocate\n this string.\n\n Failure to call [`CString::from_raw`] will lead to a memory leak.\n\n The C side must **not** modify the length of the string (by writing a\n nul byte somewhere inside the string or removing the final one) before\n it makes it back into Rust using [`CString::from_raw`]. See the safety section\n in [`CString::from_raw`].\n\n # Examples\n\n ```\n use std::ffi::CString;\n\n let c_string = CString::from(c\"foo\");\n\n let ptr = c_string.into_raw();\n\n unsafe {\n     assert_eq!(b'f', *ptr as u8);\n     assert_eq!(b'o', *ptr.add(1) as u8);\n     assert_eq!(b'o', *ptr.add(2) as u8);\n     assert_eq!(b'\\0', *ptr.add(3) as u8);\n\n     // retake pointer to free memory\n     let _ = CString::from_raw(ptr);\n }\n ```\n",
      "adt": {}
    },
    "core::mem::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves `src` into the referenced `dest`, returning the previous `dest` value.\n\n Neither value is dropped.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a default value, see [`take`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n assert_eq!(vec![1, 2], old_v);\n assert_eq!(vec![3, 4, 5], v);\n ```\n\n `replace` allows consumption of a struct field by replacing it with another value.\n Without `replace` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let t = self.buf[i];\n         self.buf[i] = v;\n         t\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n avoid the move. But `replace` can be used to disassociate the original value at that index from\n `self`, allowing it to be returned:\n\n ```\n # #![allow(dead_code)]\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         mem::replace(&mut self.buf[i], v)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf[0], 0);\n\n assert_eq!(buffer.replace_index(0, 2), 0);\n assert_eq!(buffer.buf[0], 2);\n ```\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Changes constness without changing the type.\n\n This is a bit safer than `as` because it wouldn't silently change the type if the code is\n refactored.\n",
      "adt": {}
    },
    "alloc_crate::ffi::CString::from_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Retakes ownership of a `CString` that was transferred to C via\n [`CString::into_raw`].\n\n Additionally, the length of the string will be recalculated from the pointer.\n\n # Safety\n\n This should only ever be called with a pointer that was earlier\n obtained by calling [`CString::into_raw`], and the memory it points to must not be accessed\n through any other pointer during the lifetime of reconstructed `CString`.\n Other usage (e.g., trying to take ownership of a string that was allocated by foreign code)\n is likely to lead to undefined behavior or allocator corruption.\n\n This function does not validate ownership of the raw pointer's memory.\n A double-free may occur if the function is called twice on the same raw pointer.\n Additionally, the caller must ensure the pointer is not dangling.\n\n It should be noted that the length isn't just \"recomputed,\" but that\n the recomputed length must match the original length from the\n [`CString::into_raw`] call. This means the [`CString::into_raw`]/`from_raw`\n methods should not be used when passing the string to C functions that can\n modify the string's length.\n\n > **Note:** If you need to borrow a string that was allocated by\n > foreign code, use [`CStr`]. If you need to take ownership of\n > a string that was allocated by foreign code, you will need to\n > make your own provisions for freeing it appropriately, likely\n > with the foreign code's API to do that.\n\n # Examples\n\n Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n ownership with `from_raw`:\n\n ```ignore (extern-declaration)\n use std::ffi::CString;\n use std::os::raw::c_char;\n\n extern \"C\" {\n     fn some_extern_function(s: *mut c_char);\n }\n\n let c_string = CString::from(c\"Hello!\");\n let raw = c_string.into_raw();\n unsafe {\n     some_extern_function(raw);\n     let c_string = CString::from_raw(raw);\n }\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Ref",
      "MutRef"
    ],
    "sys::process::unix::common::cstring_array::CStringArray": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "alloc_crate::ffi::CString": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::process::unix::common::cstring_array::CStringArray::write"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/common/cstring_array.rs:24:5: 33:6",
  "src": "pub fn write(&mut self, index: usize, item: CString) {\n        let argc = self.ptrs.len() - 1;\n        let ptr = &mut self.ptrs[..argc][index];\n        let old = mem::replace(ptr, item.into_raw());\n        // SAFETY:\n        // `CStringArray` owns all of its strings, and they were all transformed\n        // into pointers using `CString::into_raw`. Also, this is not the null\n        // pointer since the indexing above would have failed.\n        drop(unsafe { CString::from_raw(old.cast_mut()) });\n    }",
  "mir": "fn sys::process::unix::common::cstring_array::CStringArray::write(_1: &mut sys::process::unix::common::cstring_array::CStringArray, _2: usize, _3: alloc_crate::ffi::CString) -> () {\n    let mut _0: ();\n    let  _4: usize;\n    let mut _5: usize;\n    let mut _6: &alloc_crate::vec::Vec<*const u8>;\n    let mut _7: (usize, bool);\n    let  _8: &mut *const u8;\n    let mut _9: &mut [*const u8];\n    let mut _10: &mut alloc_crate::vec::Vec<*const u8>;\n    let mut _11: core::ops::RangeTo<usize>;\n    let mut _12: *const [*const u8];\n    let mut _13: usize;\n    let mut _14: bool;\n    let  _15: *const u8;\n    let mut _16: *const u8;\n    let mut _17: *mut u8;\n    let  _18: ();\n    let mut _19: alloc_crate::ffi::CString;\n    let mut _20: *mut u8;\n    debug self => _1;\n    debug index => _2;\n    debug item => _3;\n    debug argc => _4;\n    debug ptr => _8;\n    debug old => _15;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &((*_1).0: alloc_crate::vec::Vec<*const u8>);\n        _5 = alloc_crate::vec::Vec::<*const u8>::len(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _7 = CheckedSub(_5, 1_usize);\n        assert(!move (_7.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _5, 1_usize) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = move (_7.0: usize);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut ((*_1).0: alloc_crate::vec::Vec<*const u8>);\n        StorageLive(_11);\n        _11 = RangeTo(_4);\n        _9 = <alloc_crate::vec::Vec<*const u8> as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut(move _10, move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _12 = &raw const (fake) (*_9);\n        _13 = PtrMetadata(move _12);\n        _14 = Lt(_2, _13);\n        assert(move _14, \"index out of bounds: the length is {} but the index is {}\", move _13, _2) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = &mut (*_9)[_2];\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = alloc_crate::ffi::CString::into_raw(_3) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _16 = move _17 as *const u8;\n        StorageDead(_17);\n        _15 = core::mem::replace::<*const u8>(_8, move _16) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = core::ptr::const_ptr::<impl *const u8>::cast_mut(_15) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _19 = alloc_crate::ffi::CString::from_raw(move _20) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_20);\n        _18 = core::mem::drop::<alloc_crate::ffi::CString>(move _19) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_19);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": " Replace the string at position `index`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}