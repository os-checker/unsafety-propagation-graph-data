{
  "name": "sys::thread::unix::set_name",
  "safe": true,
  "callees": {
    "sys::thread::unix::truncate_cstr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::ffi::CStr": "ImmutableAsArgument"
      }
    },
    "libc::pthread_self": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "libc::pthread_setname_np": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ffi::CStr": [
      "Ref"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 4350,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:424:1: 442:2",
  "src": "pub fn set_name(name: &CStr) {\n    unsafe {\n        cfg_select! {\n            any(target_os = \"linux\", target_os = \"cygwin\") => {\n                // Linux and Cygwin limits the allowed length of the name.\n                const TASK_COMM_LEN: usize = 16;\n                let name = truncate_cstr::<{ TASK_COMM_LEN }>(name);\n            }\n            _ => {\n                // FreeBSD, DragonFly BSD and NuttX do not enforce length limits.\n            }\n        };\n        // Available since glibc 2.12, musl 1.1.16, and uClibc 1.0.20 for Linux,\n        // FreeBSD 12.2 and 13.0, and DragonFly BSD 6.0.\n        let res = libc::pthread_setname_np(libc::pthread_self(), name.as_ptr());\n        // We have no good way of propagating errors here, but in debug-builds let's check that this actually worked.\n        debug_assert_eq!(res, 0);\n    }\n}",
  "mir": "fn sys::thread::unix::set_name(_1: &core::ffi::CStr) -> () {\n    let mut _0: ();\n    let  _2: [u8; 16];\n    let  _3: i32;\n    let mut _4: u64;\n    let mut _5: *const u8;\n    let mut _6: &[u8];\n    let mut _7: &[u8; 16];\n    let mut _8: (&i32, &i32);\n    let mut _9: &i32;\n    let mut _10: &i32;\n    let  _11: &i32;\n    let  _12: &i32;\n    let mut _13: bool;\n    let mut _14: i32;\n    let mut _15: i32;\n    let  _16: core::panicking::AssertKind;\n    let  _17: !;\n    let mut _18: core::option::Option<core::fmt::Arguments<'_>>;\n    debug name => _1;\n    debug name => _2;\n    debug res => _3;\n    debug left_val => _11;\n    debug right_val => _12;\n    debug kind => _16;\n    bb0: {\n        StorageLive(_2);\n        _2 = sys::thread::unix::truncate_cstr::<16>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = libc::pthread_self() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_2;\n        _6 = move _7 as &[u8];\n        StorageDead(_7);\n        _5 = core::slice::<impl [u8]>::as_ptr(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _3 = libc::pthread_setname_np(move _4, move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_3;\n        StorageLive(_10);\n        _10 = sys::thread::unix::set_name::promoted[0];\n        _8 = (move _9, move _10);\n        StorageDead(_10);\n        StorageDead(_9);\n        _11 = (_8.0: &i32);\n        _12 = (_8.1: &i32);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = (*_11);\n        StorageLive(_15);\n        _15 = (*_12);\n        _13 = Eq(move _14, move _15);\n        switchInt(move _13) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_8);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n    bb6: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _16 = core::panicking::AssertKind::Eq;\n        StorageLive(_18);\n        _18 = core::option::Option::None;\n        _17 = core::panicking::assert_failed::<i32, i32>(_16, _11, _12, move _18) -> unwind unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}