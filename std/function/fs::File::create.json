{
  "name": "fs::File::create",
  "safe": true,
  "callees": {
    "fs::OpenOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a blank new set of options ready for configuration.\n\n All options are initially set to `false`.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let mut options = OpenOptions::new();\n let file = options.read(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "Constructor"
      }
    },
    "fs::OpenOptions::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option for write access.\n\n This option, when true, will indicate that the file should be\n `write`-able if opened.\n\n If the file already exists, any write calls on it will overwrite its\n contents, without truncating it.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "fs::OpenOptions::create": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option to create a new file, or open it if it already exists.\n\n In order for the file to be created, [`OpenOptions::write`] or\n [`OpenOptions::append`] access must be used.\n\n See also [`std::fs::write()`][self::write] for a simple function to\n create a file with some given data.\n\n # Errors\n\n If `.create(true)` is set without `.write(true)` or `.append(true)`,\n calling [`open`](Self::open) will fail with [`InvalidInput`](io::ErrorKind::InvalidInput) error.\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true).create(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "fs::OpenOptions::truncate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option for truncating a previous file.\n\n If a file is successfully opened with this option set to true, it will truncate\n the file to 0 length if it already exists.\n\n The file must be opened with write access for truncate to work.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true).truncate(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "fs::OpenOptions::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Opens a file at `path` with the options specified by `self`.\n\n # Errors\n\n This function will return an error under a number of different\n circumstances. Some of these error conditions are listed here, together\n with their [`io::ErrorKind`]. The mapping to [`io::ErrorKind`]s is not\n part of the compatibility contract of the function.\n\n * [`NotFound`]: The specified file does not exist and neither `create`\n   or `create_new` is set.\n * [`NotFound`]: One of the directory components of the file path does\n   not exist.\n * [`PermissionDenied`]: The user lacks permission to get the specified\n   access rights for the file.\n * [`PermissionDenied`]: The user lacks permission to open one of the\n   directory components of the specified path.\n * [`AlreadyExists`]: `create_new` was specified and the file already\n   exists.\n * [`InvalidInput`]: Invalid combinations of open options (truncate\n   without write access, create without write or append access,\n   no access mode set, etc.).\n\n The following errors don't match any existing [`io::ErrorKind`] at the moment:\n * One of the directory components of the specified file path\n   was not, in fact, a directory.\n * Filesystem-level errors: full disk, write permission\n   requested on a read-only file system, exceeded disk quota, too many\n   open files, too long filename, too many symbolic links in the\n   specified path (Unix-like systems only), etc.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().read(true).open(\"foo.txt\");\n ```\n\n [`AlreadyExists`]: io::ErrorKind::AlreadyExists\n [`InvalidInput`]: io::ErrorKind::InvalidInput\n [`NotFound`]: io::ErrorKind::NotFound\n [`PermissionDenied`]: io::ErrorKind::PermissionDenied\n",
      "adt": {
        "fs::OpenOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "fs::OpenOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::fs::File::create"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:601:5: 603:6",
  "src": "pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> {\n        OpenOptions::new().write(true).create(true).truncate(true).open(path.as_ref())\n    }",
  "mir": "fn fs::File::create(_1: P) -> core::result::Result<fs::File, io::error::Error> {\n    let mut _0: core::result::Result<fs::File, io::error::Error>;\n    let mut _2: &fs::OpenOptions;\n    let  _3: &mut fs::OpenOptions;\n    let mut _4: &mut fs::OpenOptions;\n    let mut _5: &mut fs::OpenOptions;\n    let mut _6: &mut fs::OpenOptions;\n    let mut _7: fs::OpenOptions;\n    let mut _8: &path::Path;\n    let mut _9: &P;\n    debug path => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = fs::OpenOptions::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = &mut _7;\n        _5 = fs::OpenOptions::write(move _6, true) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = fs::OpenOptions::create(_5, true) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _3 = fs::OpenOptions::truncate(_4, true) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _2 = &(*_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_1;\n        _8 = <P as core::convert::AsRef<path::Path>>::as_ref(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        _0 = fs::OpenOptions::open::<&path::Path>(move _2, move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageDead(_2);\n        drop(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": " Opens a file in write-only mode.\n\n This function will create a file if it does not exist,\n and will truncate it if it does.\n\n Depending on the platform, this function may fail if the\n full directory path does not exist.\n See the [`OpenOptions::open`] function for more details.\n\n See also [`std::fs::write()`][self::write] for a simple function to\n create a file with some given data.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Write;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::create(\"foo.txt\")?;\n     f.write_all(&1234_u32.to_be_bytes())?;\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}