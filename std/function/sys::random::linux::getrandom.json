{
  "name": "sys::random::linux::getrandom",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicBool::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the bool.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n assert_eq!(some_bool.load(Ordering::Relaxed), true);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "sys::random::linux::getrandom::getrandom": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "sys::pal::unix::os::errno": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the platform-specific value of errno\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicBool::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the bool.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n some_bool.store(false, Ordering::Relaxed);\n assert_eq!(some_bool.load(Ordering::Relaxed), false);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "fs::File::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to open a file in read-only mode.\n\n See the [`OpenOptions::open`] method for more details.\n\n If you only need to read the entire file contents,\n consider [`std::fs::read()`][self::read] or\n [`std::fs::read_to_string()`][self::read_to_string] instead.\n\n # Errors\n\n This function will return an error if `path` does not already exist.\n Other errors may also be returned according to [`OpenOptions::open`].\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Read;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut data = vec![];\n     f.read_to_end(&mut data)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "libc::poll": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "sync::once_lock::OnceLock::<T>::get_or_try_init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the contents of the cell, initializing it to `f()` if\n the cell was uninitialized. If the cell was uninitialized\n and `f()` failed, an error is returned.\n\n # Panics\n\n If `f()` panics, the panic is propagated to the caller, and\n the cell remains uninitialized.\n\n It is an error to reentrantly initialize the cell from `f`.\n The exact outcome is unspecified. Current implementation\n deadlocks, but this may be changed to a panic in the future.\n\n # Examples\n\n ```\n #![feature(once_cell_try)]\n\n use std::sync::OnceLock;\n\n let cell = OnceLock::new();\n assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n assert!(cell.get().is_none());\n let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n     Ok(92)\n });\n assert_eq!(value, Ok(&92));\n assert_eq!(cell.get(), Some(&92))\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "sync::once_lock::OnceLock": "ImmutableAsArgument"
      }
    },
    "core::result::Result::<T, E>::and_then": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n\n\n This function can be used for control flow based on `Result` values.\n\n # Examples\n\n ```\n fn sq_then_to_string(x: u32) -> Result<String, &'static str> {\n     x.checked_mul(x).map(|sq| sq.to_string()).ok_or(\"overflowed\")\n }\n\n assert_eq!(Ok(2).and_then(sq_then_to_string), Ok(4.to_string()));\n assert_eq!(Ok(1_000_000).and_then(sq_then_to_string), Err(\"overflowed\"));\n assert_eq!(Err(\"not a number\").and_then(sq_then_to_string), Err(\"not a number\"));\n ```\n\n Often used to chain fallible operations that may return [`Err`].\n\n ```\n use std::{io::ErrorKind, path::Path};\n\n // Note: on Windows \"/\" maps to \"C:\\\"\n let root_modified_time = Path::new(\"/\").metadata().and_then(|md| md.modified());\n assert!(root_modified_time.is_ok());\n\n let should_fail = Path::new(\"/bad/path\").metadata().and_then(|md| md.modified());\n assert!(should_fail.is_err());\n assert_eq!(should_fail.unwrap_err().kind(), ErrorKind::NotFound);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicBool": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "fs::File": [
      "Plain",
      "Ref"
    ],
    "libc::pollfd": [
      "Plain",
      "MutRef",
      "Deref",
      "Unknown([Field(2, Ty { id: 791, kind: RigidTy(Int(I16)) })])"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "sync::once_lock::OnceLock": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::random::linux::getrandom"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/random/linux.rs:72:1: 158:2",
  "src": "fn getrandom(mut bytes: &mut [u8], insecure: bool) {\n    // A weak symbol allows interposition, e.g. for perf measurements that want to\n    // disable randomness for consistency. Otherwise, we'll try a raw syscall.\n    // (`getrandom` was added in glibc 2.25, musl 1.1.20, android API level 28)\n    syscall!(\n        fn getrandom(\n            buffer: *mut libc::c_void,\n            length: libc::size_t,\n            flags: libc::c_uint,\n        ) -> libc::ssize_t;\n    );\n\n    static GETRANDOM_AVAILABLE: Atomic<bool> = AtomicBool::new(true);\n    static GRND_INSECURE_AVAILABLE: Atomic<bool> = AtomicBool::new(true);\n    static URANDOM_READY: Atomic<bool> = AtomicBool::new(false);\n    static DEVICE: OnceLock<File> = OnceLock::new();\n\n    if GETRANDOM_AVAILABLE.load(Relaxed) {\n        loop {\n            if bytes.is_empty() {\n                return;\n            }\n\n            let flags = if insecure {\n                if GRND_INSECURE_AVAILABLE.load(Relaxed) {\n                    libc::GRND_INSECURE\n                } else {\n                    libc::GRND_NONBLOCK\n                }\n            } else {\n                0\n            };\n\n            let ret = unsafe { getrandom(bytes.as_mut_ptr().cast(), bytes.len(), flags) };\n            if ret != -1 {\n                bytes = &mut bytes[ret as usize..];\n            } else {\n                match errno() {\n                    libc::EINTR => continue,\n                    // `GRND_INSECURE` is not available, try\n                    // `GRND_NONBLOCK`.\n                    libc::EINVAL if flags == libc::GRND_INSECURE => {\n                        GRND_INSECURE_AVAILABLE.store(false, Relaxed);\n                        continue;\n                    }\n                    // The pool is not initialized yet, fall back to\n                    // /dev/urandom for now.\n                    libc::EAGAIN if flags == libc::GRND_NONBLOCK => break,\n                    // `getrandom` is unavailable or blocked by seccomp.\n                    // Don't try it again and fall back to /dev/urandom.\n                    libc::ENOSYS | libc::EPERM => {\n                        GETRANDOM_AVAILABLE.store(false, Relaxed);\n                        break;\n                    }\n                    _ => panic!(\"failed to generate random data\"),\n                }\n            }\n        }\n    }\n\n    // When we want cryptographic strength, we need to wait for the CPRNG-pool\n    // to become initialized. Do this by polling `/dev/random` until it is ready.\n    if !insecure {\n        if !URANDOM_READY.load(Acquire) {\n            let random = File::open(\"/dev/random\").expect(\"failed to open /dev/random\");\n            let mut fd = libc::pollfd { fd: random.as_raw_fd(), events: libc::POLLIN, revents: 0 };\n\n            while !URANDOM_READY.load(Acquire) {\n                let ret = unsafe { libc::poll(&mut fd, 1, -1) };\n                match ret {\n                    1 => {\n                        assert_eq!(fd.revents, libc::POLLIN);\n                        URANDOM_READY.store(true, Release);\n                        break;\n                    }\n                    -1 if errno() == libc::EINTR => continue,\n                    _ => panic!(\"poll(\\\"/dev/random\\\") failed\"),\n                }\n            }\n        }\n    }\n\n    DEVICE\n        .get_or_try_init(|| File::open(\"/dev/urandom\"))\n        .and_then(|mut dev| dev.read_exact(bytes))\n        .expect(\"failed to generate random data\");\n}",
  "mir": "fn sys::random::linux::getrandom(_1: &mut [u8], _2: bool) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: &core::sync::atomic::AtomicBool;\n    let mut _5: core::sync::atomic::Ordering;\n    let mut _6: bool;\n    let mut _7: &[u8];\n    let  _8: u32;\n    let mut _9: bool;\n    let mut _10: &core::sync::atomic::AtomicBool;\n    let mut _11: core::sync::atomic::Ordering;\n    let  _12: isize;\n    let mut _13: *mut libc::c_void;\n    let mut _14: *mut u8;\n    let mut _15: &mut [u8];\n    let mut _16: usize;\n    let mut _17: &[u8];\n    let mut _18: u32;\n    let mut _19: &mut [u8];\n    let mut _20: &mut [u8];\n    let mut _21: core::ops::RangeFrom<usize>;\n    let mut _22: usize;\n    let mut _23: i32;\n    let mut _24: bool;\n    let mut _25: u32;\n    let  _26: ();\n    let mut _27: &core::sync::atomic::AtomicBool;\n    let mut _28: core::sync::atomic::Ordering;\n    let mut _29: bool;\n    let mut _30: u32;\n    let  _31: ();\n    let mut _32: &core::sync::atomic::AtomicBool;\n    let mut _33: core::sync::atomic::Ordering;\n    let  _34: !;\n    let mut _35: core::fmt::Arguments<'_>;\n    let mut _36: bool;\n    let mut _37: &core::sync::atomic::AtomicBool;\n    let mut _38: core::sync::atomic::Ordering;\n    let  _39: fs::File;\n    let mut _40: core::result::Result<fs::File, io::error::Error>;\n    let mut _41: &str;\n    let mut _42: libc::pollfd;\n    let mut _43: i32;\n    let mut _44: &fs::File;\n    let mut _45: bool;\n    let mut _46: &core::sync::atomic::AtomicBool;\n    let mut _47: core::sync::atomic::Ordering;\n    let  _48: i32;\n    let mut _49: *mut libc::pollfd;\n    let mut _50: &mut libc::pollfd;\n    let mut _51: (&i16, &i16);\n    let mut _52: &i16;\n    let mut _53: &i16;\n    let  _54: &i16;\n    let  _55: &i16;\n    let mut _56: bool;\n    let mut _57: i16;\n    let mut _58: i16;\n    let  _59: core::panicking::AssertKind;\n    let  _60: !;\n    let mut _61: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _62: ();\n    let mut _63: &core::sync::atomic::AtomicBool;\n    let mut _64: core::sync::atomic::Ordering;\n    let mut _65: bool;\n    let mut _66: i32;\n    let  _67: !;\n    let mut _68: core::fmt::Arguments<'_>;\n    let  _69: ();\n    let mut _70: core::result::Result<(), io::error::Error>;\n    let mut _71: core::result::Result<&fs::File, io::error::Error>;\n    let mut _72: &sync::once_lock::OnceLock<fs::File>;\n    let mut _73: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/random/linux.rs:156:19: 156:28};\n    let mut _74: &mut [u8];\n    let mut _75: &str;\n    debug bytes => _1;\n    debug insecure => _2;\n    debug flags => _8;\n    debug ret => _12;\n    debug random => _39;\n    debug fd => _42;\n    debug ret => _48;\n    debug left_val => _54;\n    debug right_val => _55;\n    debug kind => _59;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc447: &core::sync::atomic::AtomicBool};\n        StorageLive(_5);\n        _5 = core::sync::atomic::Ordering::Relaxed;\n        _3 = core::sync::atomic::AtomicBool::load(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb34, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb3;\n    }\n    bb3: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = core::slice::<impl [u8]>::is_empty(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _6) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb65;\n    }\n    bb6: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_8);\n        switchInt(_2) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = {alloc451: &core::sync::atomic::AtomicBool};\n        StorageLive(_11);\n        _11 = core::sync::atomic::Ordering::Relaxed;\n        _9 = core::sync::atomic::AtomicBool::load(move _10, move _11) -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        _8 = 0_u32;\n        goto -> bb13;\n    }\n    bb9: {\n        switchInt(move _9) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _8 = libc::GRND_INSECURE;\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _8 = libc::GRND_NONBLOCK;\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_9);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = _1;\n        _14 = core::slice::<impl [u8]>::as_mut_ptr(move _15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_15);\n        _13 = core::ptr::mut_ptr::<impl *mut u8>::cast::<libc::c_void>(move _14) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &(*_1);\n        _16 = PtrMetadata(move _17);\n        StorageDead(_17);\n        StorageLive(_18);\n        _18 = _8;\n        _12 = sys::random::linux::getrandom::getrandom(move _13, move _16, move _18) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageDead(_13);\n        switchInt(_12) -> [18446744073709551615: bb19, otherwise: bb17];\n    }\n    bb17: {\n        StorageLive(_20);\n        _20 = _1;\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = _12 as usize;\n        _21 = RangeFrom(move _22);\n        StorageDead(_22);\n        _19 = <[u8] as core::ops::IndexMut<core::ops::RangeFrom<usize>>>::index_mut(move _20, move _21) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_21);\n        StorageDead(_20);\n        _1 = _19;\n        StorageDead(_8);\n        goto -> bb3;\n    }\n    bb19: {\n        StorageLive(_23);\n        _23 = sys::pal::unix::os::errno() -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        switchInt(_23) -> [4: bb33, 22: bb24, 11: bb23, 38: bb22, 1: bb22, otherwise: bb21];\n    }\n    bb21: {\n        StorageLive(_35);\n        _35 = core::fmt::Arguments::<'_>::from_str(\"failed to generate random data\") -> [return: bb31, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_32);\n        _32 = {alloc447: &core::sync::atomic::AtomicBool};\n        StorageLive(_33);\n        _33 = core::sync::atomic::Ordering::Relaxed;\n        _31 = core::sync::atomic::AtomicBool::store(move _32, false, move _33) -> [return: bb30, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = _8;\n        _29 = Eq(move _30, libc::GRND_NONBLOCK);\n        switchInt(move _29) -> [0: bb29, otherwise: bb28];\n    }\n    bb24: {\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _8;\n        _24 = Eq(move _25, libc::GRND_INSECURE);\n        switchInt(move _24) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageLive(_27);\n        _27 = {alloc451: &core::sync::atomic::AtomicBool};\n        StorageLive(_28);\n        _28 = core::sync::atomic::Ordering::Relaxed;\n        _26 = core::sync::atomic::AtomicBool::store(move _27, false, move _28) -> [return: bb27, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_25);\n        StorageDead(_24);\n        goto -> bb21;\n    }\n    bb27: {\n        StorageDead(_28);\n        StorageDead(_27);\n        goto -> bb33;\n    }\n    bb28: {\n        StorageDead(_30);\n        StorageDead(_29);\n        goto -> bb32;\n    }\n    bb29: {\n        StorageDead(_30);\n        StorageDead(_29);\n        goto -> bb21;\n    }\n    bb30: {\n        StorageDead(_33);\n        StorageDead(_32);\n        goto -> bb32;\n    }\n    bb31: {\n        _34 = core::panicking::panic_fmt(move _35) -> unwind unreachable;\n    }\n    bb32: {\n        StorageDead(_23);\n        StorageDead(_8);\n        goto -> bb35;\n    }\n    bb33: {\n        StorageDead(_23);\n        StorageDead(_8);\n        goto -> bb3;\n    }\n    bb34: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_3);\n        switchInt(_2) -> [0: bb36, otherwise: bb61];\n    }\n    bb36: {\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = {alloc455: &core::sync::atomic::AtomicBool};\n        StorageLive(_38);\n        _38 = core::sync::atomic::Ordering::Acquire;\n        _36 = core::sync::atomic::AtomicBool::load(move _37, move _38) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        switchInt(move _36) -> [0: bb39, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb60;\n    }\n    bb39: {\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = fs::File::open::<&str>(\"/dev/random\") -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageLive(_41);\n        _41 = \"failed to open /dev/random\";\n        _39 = core::result::Result::<fs::File, io::error::Error>::expect(move _40, move _41) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &_39;\n        _43 = <fs::File as os::fd::raw::AsRawFd>::as_raw_fd(move _44) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_44);\n        _42 = pollfd(move _43, libc::POLLIN, 0_i16);\n        StorageDead(_43);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = {alloc455: &core::sync::atomic::AtomicBool};\n        StorageLive(_47);\n        _47 = core::sync::atomic::Ordering::Acquire;\n        _45 = core::sync::atomic::AtomicBool::load(move _46, move _47) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        switchInt(move _45) -> [0: bb46, otherwise: bb45];\n    }\n    bb45: {\n        StorageDead(_47);\n        StorageDead(_46);\n        goto -> bb58;\n    }\n    bb46: {\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = &mut _42;\n        _49 = &raw mut (*_50);\n        _48 = libc::poll(move _49, 1_u64, -1_i32) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_50);\n        StorageDead(_49);\n        switchInt(_48) -> [1: bb50, 4294967295: bb49, otherwise: bb48];\n    }\n    bb48: {\n        StorageLive(_68);\n        _68 = core::fmt::Arguments::<'_>::from_str(\"poll(\\\"/dev/random\\\") failed\") -> [return: bb57, unwind unreachable];\n    }\n    bb49: {\n        StorageLive(_65);\n        StorageLive(_66);\n        _66 = sys::pal::unix::os::errno() -> [return: bb54, unwind unreachable];\n    }\n    bb50: {\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &(_42.2: i16);\n        StorageLive(_53);\n        _53 = sys::random::linux::getrandom::promoted[0];\n        _51 = (move _52, move _53);\n        StorageDead(_53);\n        StorageDead(_52);\n        _54 = (_51.0: &i16);\n        _55 = (_51.1: &i16);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = (*_54);\n        StorageLive(_58);\n        _58 = (*_55);\n        _56 = Eq(move _57, move _58);\n        switchInt(move _56) -> [0: bb52, otherwise: bb51];\n    }\n    bb51: {\n        StorageDead(_58);\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageDead(_51);\n        StorageLive(_63);\n        _63 = {alloc455: &core::sync::atomic::AtomicBool};\n        StorageLive(_64);\n        _64 = core::sync::atomic::Ordering::Release;\n        _62 = core::sync::atomic::AtomicBool::store(move _63, true, move _64) -> [return: bb53, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_58);\n        StorageDead(_57);\n        _59 = core::panicking::AssertKind::Eq;\n        StorageLive(_61);\n        _61 = core::option::Option::None;\n        _60 = core::panicking::assert_failed::<i16, i16>(_59, _54, _55, move _61) -> unwind unreachable;\n    }\n    bb53: {\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageDead(_48);\n        goto -> bb58;\n    }\n    bb54: {\n        _65 = Eq(move _66, libc::EINTR);\n        switchInt(move _65) -> [0: bb56, otherwise: bb55];\n    }\n    bb55: {\n        StorageDead(_66);\n        StorageDead(_65);\n        StorageDead(_48);\n        StorageDead(_45);\n        goto -> bb43;\n    }\n    bb56: {\n        StorageDead(_66);\n        StorageDead(_65);\n        goto -> bb48;\n    }\n    bb57: {\n        _67 = core::panicking::panic_fmt(move _68) -> unwind unreachable;\n    }\n    bb58: {\n        StorageDead(_45);\n        StorageDead(_42);\n        drop(_39) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_39);\n        goto -> bb60;\n    }\n    bb60: {\n        StorageDead(_36);\n        goto -> bb61;\n    }\n    bb61: {\n        StorageLive(_70);\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = {alloc459: &sync::once_lock::OnceLock<fs::File>};\n        _71 = sync::once_lock::OnceLock::<fs::File>::get_or_try_init::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/random/linux.rs:155:26: 155:28}, io::error::Error>(move _72, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/random/linux.rs:155:26: 155:28}) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = _1;\n        _73 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/random/linux.rs:156:19: 156:28}(move _74);\n        StorageDead(_74);\n        _70 = core::result::Result::<&fs::File, io::error::Error>::and_then::<(), {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/random/linux.rs:156:19: 156:28}>(move _71, move _73) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_73);\n        StorageDead(_71);\n        StorageLive(_75);\n        _75 = \"failed to generate random data\";\n        _69 = core::result::Result::<(), io::error::Error>::expect(move _70, move _75) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_75);\n        StorageDead(_70);\n        goto -> bb65;\n    }\n    bb65: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}