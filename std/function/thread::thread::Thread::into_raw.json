{
  "name": "thread::thread::Thread::into_raw",
  "safe": true,
  "callees": {
    "core::pin::Pin::<Ptr>::into_inner_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unwraps this `Pin<Ptr>`, returning the underlying `Ptr`.\n\n # Safety\n\n This function is unsafe. You must guarantee that you will continue to\n treat the pointer `Ptr` as pinned after you call this function, so that\n the invariants on the `Pin` type can be upheld. If the code using the\n resulting `Ptr` does not continue to maintain the pinning invariants that\n is a violation of the API contract and may lead to undefined behavior in\n later (safe) operations.\n\n Note that you must be able to guarantee that the data pointed to by `Ptr`\n will be treated as pinned all the way until its `drop` handler is complete!\n\n *For more information, see the [`pin` module docs][self]*\n\n If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used\n instead.\n",
      "adt": {}
    },
    "alloc_crate::sync::Arc::<T, A>::into_raw_with_allocator": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the `Arc`, returning the wrapped pointer and allocator.\n\n To avoid a memory leak the pointer must be converted back to an `Arc` using\n [`Arc::from_raw_in`].\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n use std::sync::Arc;\n use std::alloc::System;\n\n let x = Arc::new_in(\"hello\".to_owned(), System);\n let (ptr, alloc) = Arc::into_raw_with_allocator(x);\n assert_eq!(unsafe { &*ptr }, \"hello\");\n let x = unsafe { Arc::from_raw_in(ptr, alloc) };\n assert_eq!(&*x, \"hello\");\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::pin::Pin": [
      "Plain"
    ],
    "thread::thread::Thread": [
      "Unknown([Field(0, Ty { id: 1030, kind: RigidTy(Adt(AdtDef(DefId { id: 4801, name: \"core::pin::Pin\" }), GenericArgs([Type(Ty { id: 1038, kind: RigidTy(Adt(AdtDef(DefId { id: 4653, name: \"alloc_crate::sync::Arc\" }), GenericArgs([Type(Ty { id: 1005, kind: RigidTy(Adt(AdtDef(DefId { id: 4820, name: \"thread::thread::Inner\" }), GenericArgs([]))) }), Type(Ty { id: 1021, kind: RigidTy(Adt(AdtDef(DefId { id: 4806, name: \"alloc::System\" }), GenericArgs([]))) })]))) })]))) })])",
      "Plain"
    ],
    "alloc_crate::sync::Arc": [
      "Plain"
    ],
    "alloc::System": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1076, kind: RigidTy(RawPtr(Ty { id: 1005, kind: RigidTy(Adt(AdtDef(DefId { id: 4820, name: \"thread::thread::Inner\" }), GenericArgs([]))) }, Not)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::thread::thread::Thread::into_raw"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/thread.rs:277:5: 281:6",
  "src": "pub fn into_raw(self) -> *const () {\n        // Safety: We only expose an opaque pointer, which maintains the `Pin` invariant.\n        let inner = unsafe { Pin::into_inner_unchecked(self.inner) };\n        Arc::into_raw_with_allocator(inner).0 as *const ()\n    }",
  "mir": "fn thread::thread::Thread::into_raw(_1: thread::thread::Thread) -> *const () {\n    let mut _0: *const ();\n    let  _2: alloc_crate::sync::Arc<thread::thread::Inner, alloc::System>;\n    let mut _3: core::pin::Pin<alloc_crate::sync::Arc<thread::thread::Inner, alloc::System>>;\n    let mut _4: *const thread::thread::Inner;\n    let mut _5: (*const thread::thread::Inner, alloc::System);\n    debug self => _1;\n    debug inner => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = move (_1.0: core::pin::Pin<alloc_crate::sync::Arc<thread::thread::Inner, alloc::System>>);\n        _2 = core::pin::Pin::<alloc_crate::sync::Arc<thread::thread::Inner, alloc::System>>::into_inner_unchecked(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = alloc_crate::sync::Arc::<thread::thread::Inner, alloc::System>::into_raw_with_allocator(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = (_5.0: *const thread::thread::Inner);\n        _0 = move _4 as *const ();\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Consumes the `Thread`, returning a raw pointer.\n\n To avoid a memory leak the pointer must be converted\n back into a `Thread` using [`Thread::from_raw`]. The pointer is\n guaranteed to be aligned to at least 8 bytes.\n\n # Examples\n\n ```\n #![feature(thread_raw)]\n\n use std::thread::{self, Thread};\n\n let thread = thread::current();\n let id = thread.id();\n let ptr = Thread::into_raw(thread);\n unsafe {\n     assert_eq!(Thread::from_raw(ptr).id(), id);\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}