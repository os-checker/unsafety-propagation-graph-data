{
  "name": "io::error::repr_bitpacked::decode_repr",
  "safe": false,
  "callees": {
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n [without_provenance]: without_provenance_mut\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {}
    },
    "io::error::repr_bitpacked::kind_from_prim": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "io::error::ErrorKind": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::wrapping_byte_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Subtracts an unsigned offset in bytes from a pointer using wrapping arithmetic.\n\n `count` is in units of bytes.\n\n This is purely a convenience for casting to a `u8` pointer and\n using [wrapping_sub][pointer::wrapping_sub] on it. See that method for documentation.\n\n For non-`Sized` pointees this operation changes only the data pointer,\n leaving the metadata untouched.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ptr::NonNull": [
      "Plain"
    ],
    "io::error::ErrorData": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "io::error::ErrorKind": [
      "Plain"
    ],
    "io::error::SimpleMessage": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::error::repr_bitpacked::decode_repr"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:244:1: 284:2",
  "src": "unsafe fn decode_repr<C, F>(ptr: NonNull<()>, make_custom: F) -> ErrorData<C>\nwhere\n    F: FnOnce(*mut Custom) -> C,\n{\n    let bits = ptr.as_ptr().addr();\n    match bits & TAG_MASK {\n        TAG_OS => {\n            let code = ((bits as i64) >> 32) as RawOsError;\n            ErrorData::Os(code)\n        }\n        TAG_SIMPLE => {\n            let kind_bits = (bits >> 32) as u32;\n            let kind = kind_from_prim(kind_bits).unwrap_or_else(|| {\n                debug_assert!(false, \"Invalid io::error::Repr bits: `Repr({:#018x})`\", bits);\n                // This means the `ptr` passed in was not valid, which violates\n                // the unsafe contract of `decode_repr`.\n                //\n                // Using this rather than unwrap meaningfully improves the code\n                // for callers which only care about one variant (usually\n                // `Custom`)\n                unsafe { core::hint::unreachable_unchecked() };\n            });\n            ErrorData::Simple(kind)\n        }\n        TAG_SIMPLE_MESSAGE => {\n            // SAFETY: per tag\n            unsafe { ErrorData::SimpleMessage(&*ptr.cast::<SimpleMessage>().as_ptr()) }\n        }\n        TAG_CUSTOM => {\n            // It would be correct for us to use `ptr::byte_sub` here (see the\n            // comment above the `wrapping_add` call in `new_custom` for why),\n            // but it isn't clear that it makes a difference, so we don't.\n            let custom = ptr.as_ptr().wrapping_byte_sub(TAG_CUSTOM).cast::<Custom>();\n            ErrorData::Custom(make_custom(custom))\n        }\n        _ => {\n            // Can't happen, and compiler can tell\n            unreachable!();\n        }\n    }\n}",
  "mir": "fn io::error::repr_bitpacked::decode_repr(_1: core::ptr::NonNull<()>, _2: F) -> io::error::ErrorData<C> {\n    let mut _0: io::error::ErrorData<C>;\n    let  _3: usize;\n    let mut _4: *mut ();\n    let mut _5: usize;\n    let  _6: i32;\n    let mut _7: i64;\n    let mut _8: i64;\n    let mut _9: u32;\n    let mut _10: bool;\n    let  _11: u32;\n    let mut _12: usize;\n    let mut _13: u32;\n    let mut _14: bool;\n    let  _15: io::error::ErrorKind;\n    let mut _16: core::option::Option<io::error::ErrorKind>;\n    let mut _17: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:256:65: 256:67};\n    let mut _18: &usize;\n    let  _19: &io::error::SimpleMessage;\n    let  _20: *mut io::error::SimpleMessage;\n    let mut _21: core::ptr::NonNull<io::error::SimpleMessage>;\n    let  _22: *mut io::error::Custom;\n    let mut _23: *mut ();\n    let mut _24: *mut ();\n    let mut _25: C;\n    let mut _26: F;\n    let mut _27: (*mut io::error::Custom,);\n    let  _28: !;\n    let mut _29: bool;\n    let mut _30: *const ();\n    let mut _31: usize;\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: bool;\n    let mut _35: *const ();\n    let mut _36: usize;\n    let mut _37: bool;\n    let mut _38: bool;\n    let mut _39: bool;\n    debug ptr => _1;\n    debug make_custom => _2;\n    debug bits => _3;\n    debug code => _6;\n    debug kind_bits => _11;\n    debug kind => _15;\n    debug custom => _22;\n    bb0: {\n        _29 = false;\n        _29 = true;\n        StorageLive(_4);\n        _4 = core::ptr::NonNull::<()>::as_ptr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = core::ptr::mut_ptr::<impl *mut ()>::addr(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = BitAnd(_3, io::error::repr_bitpacked::TAG_MASK);\n        switchInt(_5) -> [2: bb7, 3: bb6, 0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _28 = core::panicking::panic(\"internal error: entered unreachable code\") -> unwind unreachable;\n    }\n    bb4: {\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = core::ptr::NonNull::<()>::as_ptr(_1) -> [return: bb14, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = core::ptr::NonNull::<()>::cast::<io::error::SimpleMessage>(_1) -> [return: bb12, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_12);\n        _13 = 32_i32 as u32;\n        _14 = Lt(move _13, 64_u32);\n        assert(move _14, \"attempt to shift right by `{}`, which would overflow\", 32_i32) -> [success: bb9, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = _3 as i64;\n        _9 = 32_i32 as u32;\n        _10 = Lt(move _9, 64_u32);\n        assert(move _10, \"attempt to shift right by `{}`, which would overflow\", 32_i32) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _7 = Shr(move _8, 32_i32);\n        StorageDead(_8);\n        _6 = move _7 as i32;\n        StorageDead(_7);\n        _0 = io::error::ErrorData::Os(_6);\n        goto -> bb18;\n    }\n    bb9: {\n        _12 = Shr(_3, 32_i32);\n        _11 = move _12 as u32;\n        StorageDead(_12);\n        StorageLive(_16);\n        _16 = io::error::repr_bitpacked::kind_from_prim(_11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_3;\n        _17 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:256:65: 256:67}(move _18);\n        StorageDead(_18);\n        _15 = core::option::Option::<io::error::ErrorKind>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:256:65: 256:67}>(move _16, move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _0 = io::error::ErrorData::Simple(_15);\n        goto -> bb18;\n    }\n    bb12: {\n        _20 = core::ptr::NonNull::<io::error::SimpleMessage>::as_ptr(move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        _30 = _20 as *const ();\n        _31 = _30 as usize;\n        _32 = Sub(<io::error::SimpleMessage as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _33 = BitAnd(_31, _32);\n        _34 = Eq(_33, 0_usize);\n        assert(_34, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<io::error::SimpleMessage as core::mem::SizedTypeProperties>::ALIGN, _31) -> [success: bb21, unwind unreachable];\n    }\n    bb14: {\n        _23 = core::ptr::mut_ptr::<impl *mut ()>::wrapping_byte_sub(move _24, io::error::repr_bitpacked::TAG_CUSTOM) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_24);\n        _22 = core::ptr::mut_ptr::<impl *mut ()>::cast::<io::error::Custom>(move _23) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        _29 = false;\n        _26 = move _2;\n        StorageLive(_27);\n        _27 = (_22);\n        _25 = <F as core::ops::FnOnce<(*mut io::error::Custom,)>>::call_once(move _26, move _27) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_27);\n        StorageDead(_26);\n        _0 = io::error::ErrorData::Custom(move _25);\n        StorageDead(_25);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_5);\n        switchInt(_29) -> [0: bb19, otherwise: bb20];\n    }\n    bb19: {\n        return;\n    }\n    bb20: {\n        drop(_2) -> [return: bb19, unwind unreachable];\n    }\n    bb21: {\n        _35 = _20 as *const ();\n        _36 = _35 as usize;\n        _37 = Eq(_36, 0_usize);\n        _38 = BitAnd(_37, true);\n        _39 = Not(_38);\n        assert(_39, \"null pointer dereference occurred\") -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _19 = &(*_20);\n        _0 = io::error::ErrorData::SimpleMessage(_19);\n        StorageDead(_20);\n        goto -> bb18;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}