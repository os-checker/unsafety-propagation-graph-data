{
  "name": "io::impls::<impl io::Read for alloc_crate::collections::VecDeque<u8, A>>::read_exact",
  "safe": true,
  "callees": {
    "alloc_crate::collections::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at_mut_checked": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index, returning `None` if the\n slice is too short.\n\n If `mid ≤ len` returns a pair of slices where the first will contain all\n indices from `[0, mid)` (excluding the index `mid` itself) and the\n second will contain all indices from `[mid, len)` (excluding the index\n `len` itself).\n\n Otherwise, if `mid > len`, returns `None`.\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n\n if let Some((left, right)) = v.split_at_mut_checked(2) {\n     assert_eq!(left, [1, 0]);\n     assert_eq!(right, [3, 0, 5, 6]);\n     left[1] = 2;\n     right[1] = 4;\n }\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n\n assert_eq!(None, v.split_at_mut_checked(7));\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at_checked": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index, returning `None` if the slice is\n too short.\n\n If `mid ≤ len` returns a pair of slices where the first will contain all\n indices from `[0, mid)` (excluding the index `mid` itself) and the\n second will contain all indices from `[mid, len)` (excluding the index\n `len` itself).\n\n Otherwise, if `mid > len`, returns `None`.\n\n # Examples\n\n ```\n let v = [1, -2, 3, -4, 5, -6];\n\n {\n    let (left, right) = v.split_at_checked(0).unwrap();\n    assert_eq!(left, []);\n    assert_eq!(right, [1, -2, 3, -4, 5, -6]);\n }\n\n {\n     let (left, right) = v.split_at_checked(2).unwrap();\n     assert_eq!(left, [1, -2]);\n     assert_eq!(right, [3, -4, 5, -6]);\n }\n\n {\n     let (left, right) = v.split_at_checked(6).unwrap();\n     assert_eq!(left, [1, -2, 3, -4, 5, -6]);\n     assert_eq!(right, []);\n }\n\n assert_eq!(None, v.split_at_checked(7));\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::copy_from_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies all elements from `src` into `self`, using a memcpy.\n\n The length of `src` must be the same as `self`.\n\n If `T` does not implement `Copy`, use [`clone_from_slice`].\n\n # Panics\n\n This function will panic if the two slices have different lengths.\n\n # Examples\n\n Copying two elements from a slice into another:\n\n ```\n let src = [1, 2, 3, 4];\n let mut dst = [0, 0];\n\n // Because the slices have to be the same length,\n // we slice the source slice from four elements\n // to two. It will panic if we don't do this.\n dst.copy_from_slice(&src[2..]);\n\n assert_eq!(src, [1, 2, 3, 4]);\n assert_eq!(dst, [3, 4]);\n ```\n\n Rust enforces that there can only be one mutable reference with no\n immutable references to a particular piece of data in a particular\n scope. Because of this, attempting to use `copy_from_slice` on a\n single slice will result in a compile failure:\n\n ```compile_fail\n let mut slice = [1, 2, 3, 4, 5];\n\n slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n ```\n\n To work around this, we can use [`split_at_mut`] to create two distinct\n sub-slices from a slice:\n\n ```\n let mut slice = [1, 2, 3, 4, 5];\n\n {\n     let (left, right) = slice.split_at_mut(2);\n     left.copy_from_slice(&right[1..]);\n }\n\n assert_eq!(slice, [4, 5, 3, 4, 5]);\n ```\n\n [`clone_from_slice`]: slice::clone_from_slice\n [`split_at_mut`]: slice::split_at_mut\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clears the deque, removing all values.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n deque.push_back(1);\n deque.clear();\n assert!(deque.is_empty());\n ```\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::drain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the specified range from the deque in bulk, returning all\n removed elements as an iterator. If the iterator is dropped before\n being fully consumed, it drops the remaining removed elements.\n\n The returned iterator keeps a mutable borrow on the queue to optimize\n its implementation.\n\n\n # Panics\n\n Panics if the range has `start_bound > end_bound`, or, if the range is\n bounded on either end and past the length of the deque.\n\n # Leaking\n\n If the returned iterator goes out of scope without being dropped (due to\n [`mem::forget`], for example), the deque may have lost and leaked\n elements arbitrarily, including elements outside the range.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque: VecDeque<_> = [1, 2, 3].into();\n let drained = deque.drain(2..).collect::<VecDeque<_>>();\n assert_eq!(drained, [3]);\n assert_eq!(deque, [1, 2]);\n\n // A full range clears all contents, like `clear()` does\n deque.drain(..);\n assert!(deque.is_empty());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::collections::VecDeque": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5205, kind: RigidTy(Tuple([Ty { id: 3888, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Mut)) }, Ty { id: 3888, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Mut)) }])) }), Field(0, Ty { id: 3888, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5205, kind: RigidTy(Tuple([Ty { id: 3888, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Mut)) }, Ty { id: 3888, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Mut)) }])) }), Field(1, Ty { id: 3888, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5024, kind: RigidTy(Tuple([Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) }, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) }])) }), Field(0, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })])"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "alloc_crate::collections::vec_deque::Drain": [
      "Plain"
    ]
  },
  "path": 1834,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/impls.rs:535:5: 556:6",
  "src": "fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        let (front, back) = self.as_slices();\n\n        // Use only the front buffer if it is big enough to fill `buf`, else use\n        // the back buffer too.\n        match buf.split_at_mut_checked(front.len()) {\n            None => buf.copy_from_slice(&front[..buf.len()]),\n            Some((buf_front, buf_back)) => match back.split_at_checked(buf_back.len()) {\n                Some((back, _)) => {\n                    buf_front.copy_from_slice(front);\n                    buf_back.copy_from_slice(back);\n                }\n                None => {\n                    self.clear();\n                    return Err(io::Error::READ_EXACT_EOF);\n                }\n            },\n        }\n\n        self.drain(..buf.len());\n        Ok(())\n    }",
  "mir": "fn io::impls::<impl io::Read for alloc_crate::collections::VecDeque<u8, A>>::read_exact(_1: &mut alloc_crate::collections::VecDeque<u8, A>, _2: &mut [u8]) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let  _3: &[u8];\n    let  _4: &[u8];\n    let mut _5: (&[u8], &[u8]);\n    let mut _6: &alloc_crate::collections::VecDeque<u8, A>;\n    let  _7: ();\n    let mut _8: core::option::Option<(&mut [u8], &mut [u8])>;\n    let mut _9: usize;\n    let mut _10: isize;\n    let  _11: &[u8];\n    let mut _12: core::ops::RangeTo<usize>;\n    let mut _13: usize;\n    let mut _14: &[u8];\n    let  _15: &mut [u8];\n    let  _16: &mut [u8];\n    let mut _17: core::option::Option<(&[u8], &[u8])>;\n    let mut _18: usize;\n    let mut _19: &[u8];\n    let mut _20: isize;\n    let  _21: &[u8];\n    let  _22: ();\n    let  _23: ();\n    let  _24: ();\n    let  _25: alloc_crate::collections::vec_deque::Drain<'_, u8, A>;\n    let mut _26: core::ops::RangeTo<usize>;\n    let mut _27: usize;\n    let mut _28: &[u8];\n    debug self => _1;\n    debug buf => _2;\n    debug front => _3;\n    debug back => _4;\n    debug buf_front => _15;\n    debug buf_back => _16;\n    debug back => _21;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = alloc_crate::collections::VecDeque::<u8, A>::as_slices(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _3 = (_5.0: &[u8]);\n        _4 = (_5.1: &[u8]);\n        StorageDead(_5);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = PtrMetadata(_3);\n        _8 = core::slice::<impl [u8]>::split_at_mut_checked(_2, move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_9);\n        _10 = discriminant(_8);\n        switchInt(move _10) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _15 = move (((_8 as variant#1).0: (&mut [u8], &mut [u8])).0: &mut [u8]);\n        _16 = move (((_8 as variant#1).0: (&mut [u8], &mut [u8])).1: &mut [u8]);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &(*_16);\n        _18 = PtrMetadata(move _19);\n        StorageDead(_19);\n        _17 = core::slice::<impl [u8]>::split_at_checked(_4, move _18) -> [return: bb8, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_2);\n        _13 = PtrMetadata(move _14);\n        StorageDead(_14);\n        _12 = RangeTo(move _13);\n        StorageDead(_13);\n        _11 = <[u8] as core::ops::Index<core::ops::RangeTo<usize>>>::index(_3, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        _7 = core::slice::<impl [u8]>::copy_from_slice(_2, _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb14;\n    }\n    bb8: {\n        StorageDead(_18);\n        _20 = discriminant(_17);\n        switchInt(move _20) -> [0: bb9, 1: bb10, otherwise: bb3];\n    }\n    bb9: {\n        _24 = alloc_crate::collections::VecDeque::<u8, A>::clear(_1) -> [return: bb13, unwind unreachable];\n    }\n    bb10: {\n        _21 = (((_17 as variant#1).0: (&[u8], &[u8])).0: &[u8]);\n        _22 = core::slice::<impl [u8]>::copy_from_slice(_15, _3) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _23 = core::slice::<impl [u8]>::copy_from_slice(_16, _21) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_17);\n        goto -> bb14;\n    }\n    bb13: {\n        _0 = core::result::Result::Err(io::error::Error::READ_EXACT_EOF);\n        StorageDead(_17);\n        StorageDead(_8);\n        goto -> bb17;\n    }\n    bb14: {\n        StorageDead(_8);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = &(*_2);\n        _27 = PtrMetadata(move _28);\n        StorageDead(_28);\n        _26 = RangeTo(move _27);\n        StorageDead(_27);\n        _25 = alloc_crate::collections::VecDeque::<u8, A>::drain::<core::ops::RangeTo<usize>>(_1, move _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_26);\n        drop(_25) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_25);\n        _0 = core::result::Result::Ok(());\n        goto -> bb17;\n    }\n    bb17: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}