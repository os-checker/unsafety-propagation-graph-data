{
  "name": "backtrace_rs::symbolize::gimli::elf::locate_debuglink",
  "safe": true,
  "callees": {
    "fs::canonicalize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the canonical, absolute form of a path with all intermediate\n components normalized and symbolic links resolved.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `realpath` function on Unix\n and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.\n Note that this [may change in the future][changes].\n\n On Windows, this converts the path to use [extended length path][path]\n syntax, which allows your program to use longer path names, but means you\n can only join backslash-delimited paths to it, and it may be incompatible\n with other applications (if passed to the application on the command-line,\n or written to a file another application may read).\n\n [changes]: io#platform-specific-behavior\n [path]: https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n\n # Errors\n\n This function will return an error in the following situations, but is not\n limited to just these cases:\n\n * `path` does not exist.\n * A non-final component in path is not a directory.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let path = fs::canonicalize(\"../a/../foo.txt\")?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "path::PathBuf": "Constructor"
      }
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "path::Path::parent": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `Path` without its final component, if there is one.\n\n This means it returns `Some(\"\")` for relative paths with one component.\n\n Returns [`None`] if the path terminates in a root or prefix, or if it's\n the empty string.\n\n # Examples\n\n ```\n use std::path::Path;\n\n let path = Path::new(\"/foo/bar\");\n let parent = path.parent().unwrap();\n assert_eq!(parent, Path::new(\"/foo\"));\n\n let grand_parent = parent.parent().unwrap();\n assert_eq!(grand_parent, Path::new(\"/\"));\n assert_eq!(grand_parent.parent(), None);\n\n let relative_path = Path::new(\"foo/bar\");\n let parent = relative_path.parent();\n assert_eq!(parent, Some(Path::new(\"foo\")));\n let grand_parent = parent.and_then(Path::parent);\n assert_eq!(grand_parent, Some(Path::new(\"\")));\n let great_grand_parent = grand_parent.and_then(Path::parent);\n assert_eq!(great_grand_parent, None);\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "path::Path::as_os_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields the underlying [`OsStr`] slice.\n\n # Examples\n\n ```\n use std::path::Path;\n\n let os_str = Path::new(\"foo.txt\").as_os_str();\n assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "ffi::os_str::OsStr::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of this `OsStr`.\n\n Note that this does **not** return the number of bytes in the string in\n OS string form.\n\n The length returned is that of the underlying storage used by `OsStr`.\n As discussed in the [`OsString`] introduction, [`OsString`] and `OsStr`\n store strings in a form best suited for cheap inter-conversion between\n native-platform and Rust string forms, which may differ significantly\n from both of them, including in storage size and encoding.\n\n This number is simply useful for passing to other methods, like\n [`OsString::with_capacity`] to avoid reallocations.\n\n See the main `OsString` documentation information about encoding and capacity units.\n\n # Examples\n\n ```\n use std::ffi::OsStr;\n\n let os_str = OsStr::new(\"\");\n assert_eq!(os_str.len(), 0);\n\n let os_str = OsStr::new(\"foo\");\n assert_eq!(os_str.len(), 3);\n ```\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "path::PathBuf::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `PathBuf` with a given capacity used to create the\n internal [`OsString`]. See [`with_capacity`] defined on [`OsString`].\n\n # Examples\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::with_capacity(10);\n let capacity = path.capacity();\n\n // This push is done without reallocating\n path.push(r\"C:\\\");\n\n assert_eq!(capacity, path.capacity());\n ```\n\n [`with_capacity`]: OsString::with_capacity\n",
      "adt": {
        "path::PathBuf": "Constructor"
      }
    },
    "path::Path::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Directly wraps a string slice as a `Path` slice.\n\n This is a cost-free conversion.\n\n # Examples\n\n ```\n use std::path::Path;\n\n Path::new(\"foo.txt\");\n ```\n\n You can create `Path`s from `String`s, or even other `Path`s:\n\n ```\n use std::path::Path;\n\n let string = String::from(\"foo.txt\");\n let from_string = Path::new(&string);\n let from_path = Path::new(&from_string);\n assert_eq!(from_string, from_path);\n ```\n",
      "adt": {}
    },
    "path::PathBuf::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends `self` with `path`.\n\n If `path` is absolute, it replaces the current path.\n\n On Windows:\n\n * if `path` has a root but no prefix (e.g., `\\windows`), it\n   replaces everything except for the prefix (if any) of `self`.\n * if `path` has a prefix but no root, it replaces `self`.\n * if `self` has a verbatim prefix (e.g. `\\\\?\\C:\\windows`)\n   and `path` is not empty, the new path is normalized: all references\n   to `.` and `..` are removed.\n\n Consider using [`Path::join`] if you need a new `PathBuf` instead of\n using this function on a cloned `PathBuf`.\n\n # Examples\n\n Pushing a relative path extends the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"file.bk\");\n assert_eq!(path, PathBuf::from(\"/tmp/file.bk\"));\n ```\n\n Pushing an absolute path replaces the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"/etc\");\n assert_eq!(path, PathBuf::from(\"/etc\"));\n ```\n",
      "adt": {
        "path::PathBuf": "MutableAsArgument"
      }
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "path::Path::is_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the path exists on disk and is pointing at a regular file.\n\n This function will traverse symbolic links to query information about the\n destination file.\n\n If you cannot access the metadata of the file, e.g. because of a\n permission error or broken symbolic links, this will return `false`.\n\n # Examples\n\n ```no_run\n use std::path::Path;\n assert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\n assert_eq!(Path::new(\"a_file.txt\").is_file(), true);\n ```\n\n # See Also\n\n This is a convenience function that coerces errors to false. If you want to\n check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n [`fs::Metadata::is_file`] if it was [`Ok`].\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`fs::File::open`] or\n [`fs::OpenOptions::open`] for more information.\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "path::PathBuf::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invokes [`clear`] on the underlying instance of [`OsString`].\n\n [`clear`]: OsString::clear\n",
      "adt": {
        "path::PathBuf": "MutableAsArgument"
      }
    },
    "backtrace_rs::symbolize::gimli::elf::debug_path_exists": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "path::Path::strip_prefix": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a path that, when joined onto `base`, yields `self`.\n\n # Errors\n\n If `base` is not a prefix of `self` (i.e., [`starts_with`]\n returns `false`), returns [`Err`].\n\n [`starts_with`]: Path::starts_with\n\n # Examples\n\n ```\n use std::path::{Path, PathBuf};\n\n let path = Path::new(\"/test/haha/foo.txt\");\n\n assert_eq!(path.strip_prefix(\"/\"), Ok(Path::new(\"test/haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test\"), Ok(Path::new(\"haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\n assert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\n\n assert!(path.strip_prefix(\"test\").is_err());\n assert!(path.strip_prefix(\"/te\").is_err());\n assert!(path.strip_prefix(\"/haha\").is_err());\n\n let prefix = PathBuf::from(\"/test/\");\n assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1226, kind: RigidTy(Adt(AdtDef(DefId { id: 5561, name: \"path::PathBuf\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2754, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2756, kind: RigidTy(Adt(AdtDef(DefId { id: 5564, name: \"path::Path\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "path::PathBuf": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::gimli::elf::locate_debuglink"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:462:1: 497:2",
  "src": "fn locate_debuglink(path: &Path, filename: &OsStr) -> Option<PathBuf> {\n    let path = fs::canonicalize(path).ok()?;\n    let parent = path.parent()?;\n    let mut f =\n        PathBuf::with_capacity(DEBUG_PATH.len() + parent.as_os_str().len() + filename.len() + 2);\n    let filename = Path::new(filename);\n\n    // Try \"/parent/filename\" if it differs from \"path\"\n    f.push(parent);\n    f.push(filename);\n    if f != path && f.is_file() {\n        return Some(f);\n    }\n\n    // Try \"/parent/.debug/filename\"\n    f.clear();\n    f.push(parent);\n    f.push(\".debug\");\n    f.push(filename);\n    if f.is_file() {\n        return Some(f);\n    }\n\n    if debug_path_exists() {\n        // Try \"/usr/lib/debug/parent/filename\"\n        f.clear();\n        f.push(DEBUG_PATH);\n        f.push(parent.strip_prefix(\"/\").unwrap());\n        f.push(filename);\n        if f.is_file() {\n            return Some(f);\n        }\n    }\n\n    None\n}",
  "mir": "fn backtrace_rs::symbolize::gimli::elf::locate_debuglink(_1: &path::Path, _2: &ffi::os_str::OsStr) -> core::option::Option<path::PathBuf> {\n    let mut _0: core::option::Option<path::PathBuf>;\n    let  _3: path::PathBuf;\n    let mut _4: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, path::PathBuf>;\n    let mut _5: core::option::Option<path::PathBuf>;\n    let mut _6: core::result::Result<path::PathBuf, io::error::Error>;\n    let mut _7: isize;\n    let  _8: path::PathBuf;\n    let mut _9: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &path::Path>;\n    let mut _10: core::option::Option<&path::Path>;\n    let  _11: &path::Path;\n    let mut _12: &path::PathBuf;\n    let mut _13: isize;\n    let  _14: &path::Path;\n    let mut _15: path::PathBuf;\n    let mut _16: usize;\n    let mut _17: usize;\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: &str;\n    let mut _21: usize;\n    let  _22: &ffi::os_str::OsStr;\n    let mut _23: (usize, bool);\n    let mut _24: usize;\n    let mut _25: (usize, bool);\n    let mut _26: (usize, bool);\n    let  _27: &path::Path;\n    let  _28: ();\n    let mut _29: &mut path::PathBuf;\n    let  _30: ();\n    let mut _31: &mut path::PathBuf;\n    let mut _32: bool;\n    let mut _33: &path::PathBuf;\n    let mut _34: &path::PathBuf;\n    let mut _35: bool;\n    let  _36: &path::Path;\n    let mut _37: &path::PathBuf;\n    let mut _38: path::PathBuf;\n    let  _39: ();\n    let mut _40: &mut path::PathBuf;\n    let  _41: ();\n    let mut _42: &mut path::PathBuf;\n    let  _43: ();\n    let mut _44: &mut path::PathBuf;\n    let  _45: ();\n    let mut _46: &mut path::PathBuf;\n    let mut _47: bool;\n    let  _48: &path::Path;\n    let mut _49: &path::PathBuf;\n    let mut _50: path::PathBuf;\n    let mut _51: bool;\n    let  _52: ();\n    let mut _53: &mut path::PathBuf;\n    let  _54: ();\n    let mut _55: &mut path::PathBuf;\n    let  _56: ();\n    let mut _57: &mut path::PathBuf;\n    let mut _58: &path::Path;\n    let mut _59: core::result::Result<&path::Path, path::StripPrefixError>;\n    let  _60: ();\n    let mut _61: &mut path::PathBuf;\n    let mut _62: bool;\n    let  _63: &path::Path;\n    let mut _64: &path::PathBuf;\n    let mut _65: path::PathBuf;\n    debug path => _1;\n    debug filename => _2;\n    debug path => _3;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _8;\n    debug parent => _14;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _14;\n    debug f => _15;\n    debug filename => _27;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = fs::canonicalize::<&path::Path>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = core::result::Result::<path::PathBuf, io::error::Error>::ok(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = <core::option::Option<path::PathBuf> as core::ops::Try>::branch(move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        _7 = discriminant(_4);\n        switchInt(move _7) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        StorageLive(_8);\n        _8 = move ((_4 as variant#0).0: path::PathBuf);\n        _3 = move _8;\n        StorageDead(_8);\n        StorageDead(_4);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_12);\n        _12 = &_3;\n        _11 = <path::PathBuf as core::ops::Deref>::deref(move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _0 = <core::option::Option<path::PathBuf> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_4);\n        goto -> bb58;\n    }\n    bb8: {\n        StorageDead(_12);\n        _10 = path::Path::parent(_11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _9 = <core::option::Option<&path::Path> as core::ops::Try>::branch(move _10) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_10);\n        _13 = discriminant(_9);\n        switchInt(move _13) -> [0: bb11, 1: bb12, otherwise: bb4];\n    }\n    bb11: {\n        _14 = ((_9 as variant#0).0: &path::Path);\n        StorageDead(_9);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = backtrace_rs::symbolize::gimli::elf::DEBUG_PATH;\n        _19 = core::str::<impl str>::len(move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _0 = <core::option::Option<path::PathBuf> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_9);\n        goto -> bb57;\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageLive(_21);\n        _22 = path::Path::as_os_str(_14) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _21 = ffi::os_str::OsStr::len(_22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _23 = CheckedAdd(_19, _21);\n        assert(!move (_23.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _19, move _21) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _18 = move (_23.0: usize);\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageLive(_24);\n        _24 = ffi::os_str::OsStr::len(_2) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _25 = CheckedAdd(_18, _24);\n        assert(!move (_25.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _18, move _24) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _17 = move (_25.0: usize);\n        StorageDead(_24);\n        StorageDead(_18);\n        _26 = CheckedAdd(_17, 2_usize);\n        assert(!move (_26.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _17, 2_usize) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _16 = move (_26.0: usize);\n        StorageDead(_17);\n        _15 = path::PathBuf::with_capacity(move _16) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_16);\n        _27 = path::Path::new::<ffi::os_str::OsStr>(_2) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_29);\n        _29 = &mut _15;\n        _28 = path::PathBuf::push::<&path::Path>(move _29, _14) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_29);\n        StorageLive(_31);\n        _31 = &mut _15;\n        _30 = path::PathBuf::push::<&path::Path>(move _31, _27) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_15;\n        StorageLive(_34);\n        _34 = &_3;\n        _32 = <path::PathBuf as core::cmp::PartialEq>::ne(move _33, move _34) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _32) -> [0: bb31, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageLive(_35);\n        StorageLive(_37);\n        _37 = &_15;\n        _36 = <path::PathBuf as core::ops::Deref>::deref(move _37) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_37);\n        _35 = path::Path::is_file(_36) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        switchInt(move _35) -> [0: bb30, otherwise: bb29];\n    }\n    bb29: {\n        StorageLive(_38);\n        _38 = move _15;\n        _0 = core::option::Option::Some(move _38);\n        StorageDead(_38);\n        StorageDead(_35);\n        StorageDead(_32);\n        goto -> bb56;\n    }\n    bb30: {\n        goto -> bb32;\n    }\n    bb31: {\n        StorageDead(_34);\n        StorageDead(_33);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_35);\n        StorageDead(_32);\n        StorageLive(_40);\n        _40 = &mut _15;\n        _39 = path::PathBuf::clear(move _40) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_40);\n        StorageLive(_42);\n        _42 = &mut _15;\n        _41 = path::PathBuf::push::<&path::Path>(move _42, _14) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_42);\n        StorageLive(_44);\n        _44 = &mut _15;\n        _43 = path::PathBuf::push::<&str>(move _44, \".debug\") -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_44);\n        StorageLive(_46);\n        _46 = &mut _15;\n        _45 = path::PathBuf::push::<&path::Path>(move _46, _27) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_46);\n        StorageLive(_47);\n        StorageLive(_49);\n        _49 = &_15;\n        _48 = <path::PathBuf as core::ops::Deref>::deref(move _49) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_49);\n        _47 = path::Path::is_file(_48) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        switchInt(move _47) -> [0: bb40, otherwise: bb39];\n    }\n    bb39: {\n        StorageLive(_50);\n        _50 = move _15;\n        _0 = core::option::Option::Some(move _50);\n        StorageDead(_50);\n        StorageDead(_47);\n        goto -> bb56;\n    }\n    bb40: {\n        StorageDead(_47);\n        StorageLive(_51);\n        _51 = backtrace_rs::symbolize::gimli::elf::debug_path_exists() -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        switchInt(move _51) -> [0: bb53, otherwise: bb42];\n    }\n    bb42: {\n        StorageLive(_53);\n        _53 = &mut _15;\n        _52 = path::PathBuf::clear(move _53) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_53);\n        StorageLive(_55);\n        _55 = &mut _15;\n        _54 = path::PathBuf::push::<&str>(move _55, backtrace_rs::symbolize::gimli::elf::DEBUG_PATH) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_55);\n        StorageLive(_57);\n        _57 = &mut _15;\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = path::Path::strip_prefix::<&str>(_14, \"/\") -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        _58 = core::result::Result::<&path::Path, path::StripPrefixError>::unwrap(move _59) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_59);\n        _56 = path::PathBuf::push::<&path::Path>(move _57, move _58) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_58);\n        StorageDead(_57);\n        StorageLive(_61);\n        _61 = &mut _15;\n        _60 = path::PathBuf::push::<&path::Path>(move _61, _27) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_61);\n        StorageLive(_62);\n        StorageLive(_64);\n        _64 = &_15;\n        _63 = <path::PathBuf as core::ops::Deref>::deref(move _64) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_64);\n        _62 = path::Path::is_file(_63) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        switchInt(move _62) -> [0: bb52, otherwise: bb51];\n    }\n    bb51: {\n        StorageLive(_65);\n        _65 = move _15;\n        _0 = core::option::Option::Some(move _65);\n        StorageDead(_65);\n        StorageDead(_62);\n        StorageDead(_51);\n        goto -> bb56;\n    }\n    bb52: {\n        StorageDead(_62);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_51);\n        _0 = core::option::Option::None;\n        drop(_15) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_15);\n        drop(_3) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_3);\n        goto -> bb59;\n    }\n    bb56: {\n        StorageDead(_15);\n        goto -> bb57;\n    }\n    bb57: {\n        drop(_3) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_3);\n        goto -> bb59;\n    }\n    bb59: {\n        return;\n    }\n}\n",
  "doc": " Locate a file specified in a `.gnu_debuglink` section.\n\n `path` is the file containing the section.\n `filename` is from the contents of the section.\n\n Search order is based on gdb, documented at:\n https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html\n\n gdb also allows the user to customize the debug search path, but we don't.\n\n gdb also supports debuginfod, but we don't yet.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}