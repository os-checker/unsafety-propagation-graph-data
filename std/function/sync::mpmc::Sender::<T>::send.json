{
  "name": "sync::mpmc::Sender::<T>::send",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sync::mpmc::array::Channel::<T>::send": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sends a message into the channel.\n",
      "adt": {
        "sync::mpmc::array::Channel": "ImmutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sync::mpmc::list::Channel::<T>::send": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sends a message into the channel.\n",
      "adt": {
        "sync::mpmc::list::Channel": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sync::mpmc::zero::Channel::<T>::send": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sends a message into the channel.\n",
      "adt": {
        "sync::mpmc::zero::Channel": "ImmutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::mpmc::SenderFlavor": [
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(2, ThreadLocalIndex)), Field(0, Ty { id: 11135, kind: RigidTy(Adt(AdtDef(DefId { id: 9339, name: \"sync::mpmc::counter::Sender\" }), GenericArgs([Type(Ty { id: 11057, kind: RigidTy(Adt(AdtDef(DefId { id: 9477, name: \"sync::mpmc::zero::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11125, kind: RigidTy(Adt(AdtDef(DefId { id: 9339, name: \"sync::mpmc::counter::Sender\" }), GenericArgs([Type(Ty { id: 10845, kind: RigidTy(Adt(AdtDef(DefId { id: 9390, name: \"sync::mpmc::list::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11138, kind: RigidTy(Adt(AdtDef(DefId { id: 9339, name: \"sync::mpmc::counter::Sender\" }), GenericArgs([Type(Ty { id: 10556, kind: RigidTy(Adt(AdtDef(DefId { id: 9234, name: \"sync::mpmc::array::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])"
    ],
    "sync::mpmc::Sender": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::mpmc::counter::Sender": [
      "Ref"
    ],
    "sync::mpmc::zero::Channel": [
      "Ref"
    ],
    "sync::mpmc::list::Channel": [
      "Ref"
    ],
    "sync::mpmc::array::Channel": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::mpmc::Sender::<T>::send"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:392:5: 402:6",
  "src": "pub fn send(&self, msg: T) -> Result<(), SendError<T>> {\n        match &self.flavor {\n            SenderFlavor::Array(chan) => chan.send(msg, None),\n            SenderFlavor::List(chan) => chan.send(msg, None),\n            SenderFlavor::Zero(chan) => chan.send(msg, None),\n        }\n        .map_err(|err| match err {\n            SendTimeoutError::Disconnected(msg) => SendError(msg),\n            SendTimeoutError::Timeout(_) => unreachable!(),\n        })\n    }",
  "mir": "fn sync::mpmc::Sender::<T>::send(_1: &sync::mpmc::Sender<T>, _2: T) -> core::result::Result<(), sync::mpsc::SendError<T>> {\n    let mut _0: core::result::Result<(), sync::mpsc::SendError<T>>;\n    let mut _3: core::result::Result<(), sync::mpmc::error::SendTimeoutError<T>>;\n    let mut _4: &sync::mpmc::SenderFlavor<T>;\n    let mut _5: isize;\n    let  _6: &sync::mpmc::counter::Sender<sync::mpmc::array::Channel<T>>;\n    let  _7: &sync::mpmc::array::Channel<T>;\n    let mut _8: core::option::Option<time::Instant>;\n    let  _9: &sync::mpmc::counter::Sender<sync::mpmc::list::Channel<T>>;\n    let  _10: &sync::mpmc::list::Channel<T>;\n    let mut _11: core::option::Option<time::Instant>;\n    let  _12: &sync::mpmc::counter::Sender<sync::mpmc::zero::Channel<T>>;\n    let  _13: &sync::mpmc::zero::Channel<T>;\n    let mut _14: core::option::Option<time::Instant>;\n    debug self => _1;\n    debug msg => _2;\n    debug chan => _6;\n    debug chan => _9;\n    debug chan => _12;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: sync::mpmc::SenderFlavor<T>);\n        _5 = discriminant((*_4));\n        switchInt(move _5) -> [0: bb4, 1: bb3, 2: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        _12 = &(((*_4) as variant#2).0: sync::mpmc::counter::Sender<sync::mpmc::zero::Channel<T>>);\n        _13 = <sync::mpmc::counter::Sender<sync::mpmc::zero::Channel<T>> as core::ops::Deref>::deref(_12) -> [return: bb9, unwind unreachable];\n    }\n    bb3: {\n        _9 = &(((*_4) as variant#1).0: sync::mpmc::counter::Sender<sync::mpmc::list::Channel<T>>);\n        _10 = <sync::mpmc::counter::Sender<sync::mpmc::list::Channel<T>> as core::ops::Deref>::deref(_9) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        _6 = &(((*_4) as variant#0).0: sync::mpmc::counter::Sender<sync::mpmc::array::Channel<T>>);\n        _7 = <sync::mpmc::counter::Sender<sync::mpmc::array::Channel<T>> as core::ops::Deref>::deref(_6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_8);\n        _8 = core::option::Option::None;\n        _3 = sync::mpmc::array::Channel::<T>::send(_7, _2, move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        goto -> bb11;\n    }\n    bb7: {\n        StorageLive(_11);\n        _11 = core::option::Option::None;\n        _3 = sync::mpmc::list::Channel::<T>::send(_10, _2, move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageLive(_14);\n        _14 = core::option::Option::None;\n        _3 = sync::mpmc::zero::Channel::<T>::send(_13, _2, move _14) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        goto -> bb11;\n    }\n    bb11: {\n        _0 = core::result::Result::<(), sync::mpmc::error::SendTimeoutError<T>>::map_err::<sync::mpsc::SendError<T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:398:18: 398:23}>(move _3, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:398:18: 398:23}) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Attempts to send a value on this channel, returning it back if it could\n not be sent.\n\n A successful send occurs when it is determined that the other end of\n the channel has not hung up already. An unsuccessful send would be one\n where the corresponding receiver has already been deallocated. Note\n that a return value of [`Err`] means that the data will never be\n received, but a return value of [`Ok`] does *not* mean that the data\n will be received. It is possible for the corresponding receiver to\n hang up immediately after this function returns [`Ok`]. However, if\n the channel is zero-capacity, it acts as a rendezvous channel and a\n return value of [`Ok`] means that the data has been received.\n\n If the channel is full and not disconnected, this call will block until\n the send operation can proceed. If the channel becomes disconnected,\n this call will wake up and return an error. The returned error contains\n the original message.\n\n If called on a zero-capacity channel, this method will wait for a receive\n operation to appear on the other side of the channel.\n\n # Examples\n\n ```\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc::channel;\n\n let (tx, rx) = channel();\n\n // This send is always successful\n tx.send(1).unwrap();\n\n // This send will fail because the receiver is gone\n drop(rx);\n assert!(tx.send(1).is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}