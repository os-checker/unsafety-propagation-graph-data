{
  "name": "<os::unix::net::ancillary::Messages<'a> as core::iter::Iterator>::next",
  "safe": true,
  "callees": {
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "libc::CMSG_NXTHDR": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::CMSG_FIRSTHDR": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::as_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n ```\n let ptr: *mut u8 = &mut 10u8 as *mut u8;\n\n unsafe {\n     let val_back = &*ptr;\n     println!(\"We got back the value: {val_back}!\");\n }\n ```\n\n # Examples\n\n ```\n let ptr: *mut u8 = &mut 10u8 as *mut u8;\n\n unsafe {\n     if let Some(val_back) = ptr.as_ref() {\n         println!(\"We got back the value: {val_back}!\");\n     }\n }\n ```\n\n # See Also\n\n For the mutable counterpart see [`as_mut`].\n\n [`is_null`]: #method.is_null-1\n [`as_uninit_ref`]: pointer#method.as_uninit_ref-1\n [`as_mut`]: #method.as_mut\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares raw pointers for equality.\n\n This is the same as using the `==` operator, but less generic:\n the arguments have to be `*const T` raw pointers,\n not anything that implements `PartialEq`.\n\n This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n by their address rather than comparing the values they point to\n (which is what the `PartialEq for &T` implementation does).\n\n When comparing wide pointers, both the address and the metadata are tested for equality.\n However, note that comparing trait object pointers (`*const dyn Trait`) is unreliable: pointers\n to values of the same underlying type can compare inequal (because vtables are duplicated in\n multiple codegen units), and pointers to values of *different* underlying type can compare equal\n (since identical vtables can be deduplicated within a codegen unit).\n\n # Examples\n\n ```\n use std::ptr;\n\n let five = 5;\n let other_five = 5;\n let five_ref = &five;\n let same_five_ref = &five;\n let other_five_ref = &other_five;\n\n assert!(five_ref == same_five_ref);\n assert!(ptr::eq(five_ref, same_five_ref));\n\n assert!(five_ref == other_five_ref);\n assert!(!ptr::eq(five_ref, other_five_ref));\n ```\n\n Slices are also compared by their length (fat pointers):\n\n ```\n let a = [1, 2, 3];\n assert!(std::ptr::eq(&a[..3], &a[..3]));\n assert!(!std::ptr::eq(&a[..2], &a[..3]));\n assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n ```\n",
      "adt": {}
    },
    "os::unix::net::ancillary::AncillaryData::<'a>::try_from_cmsghdr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "libc::cmsghdr": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "libc::msghdr": [
      "Plain",
      "Unknown([Field(4, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(5, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Ref",
      "Deref"
    ],
    "os::unix::net::ancillary::Messages": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "libc::cmsghdr": [
      "Ref",
      "Deref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8310, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 8231, kind: RigidTy(Adt(AdtDef(DefId { id: 8208, name: \"libc::cmsghdr\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2119,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/ancillary.rs:546:5: 573:6",
  "src": "fn next(&mut self) -> Option<Self::Item> {\n        unsafe {\n            let mut msg: libc::msghdr = zeroed();\n            msg.msg_control = self.buffer.as_ptr() as *mut _;\n            msg.msg_controllen = self.buffer.len() as _;\n\n            let cmsg = if let Some(current) = self.current {\n                libc::CMSG_NXTHDR(&msg, current)\n            } else {\n                libc::CMSG_FIRSTHDR(&msg)\n            };\n\n            let cmsg = cmsg.as_ref()?;\n\n            // Most operating systems, but not Linux or emscripten, return the previous pointer\n            // when its length is zero. Therefore, check if the previous pointer is the same as\n            // the current one.\n            if let Some(current) = self.current {\n                if eq(current, cmsg) {\n                    return None;\n                }\n            }\n\n            self.current = Some(cmsg);\n            let ancillary_result = AncillaryData::try_from_cmsghdr(cmsg);\n            Some(ancillary_result)\n        }\n    }",
  "mir": "fn <os::unix::net::ancillary::Messages<'a> as core::iter::Iterator>::next(_1: &mut os::unix::net::ancillary::Messages<'_>) -> core::option::Option<core::result::Result<os::unix::net::ancillary::AncillaryData<'_>, os::unix::net::ancillary::AncillaryError>> {\n    let mut _0: core::option::Option<core::result::Result<os::unix::net::ancillary::AncillaryData<'_>, os::unix::net::ancillary::AncillaryError>>;\n    let mut _2: libc::msghdr;\n    let mut _3: *mut libc::c_void;\n    let mut _4: *const u8;\n    let mut _5: usize;\n    let  _6: *mut libc::cmsghdr;\n    let mut _7: isize;\n    let  _8: &libc::cmsghdr;\n    let mut _9: *const libc::msghdr;\n    let  _10: &libc::msghdr;\n    let mut _11: *const libc::cmsghdr;\n    let mut _12: *const libc::msghdr;\n    let  _13: &libc::msghdr;\n    let mut _14: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &libc::cmsghdr>;\n    let mut _15: core::option::Option<&libc::cmsghdr>;\n    let mut _16: *mut libc::cmsghdr;\n    let mut _17: isize;\n    let  _18: &libc::cmsghdr;\n    let mut _19: isize;\n    let  _20: &libc::cmsghdr;\n    let mut _21: bool;\n    let mut _22: *const libc::cmsghdr;\n    let mut _23: *const libc::cmsghdr;\n    let mut _24: core::option::Option<&libc::cmsghdr>;\n    let  _25: core::result::Result<os::unix::net::ancillary::AncillaryData<'_>, os::unix::net::ancillary::AncillaryError>;\n    let mut _26: &[u8];\n    let mut _27: &[u8];\n    debug self => _1;\n    debug msg => _2;\n    debug cmsg => _6;\n    debug current => _8;\n    debug cmsg => _18;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _18;\n    debug current => _20;\n    debug ancillary_result => _25;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::zeroed::<libc::msghdr>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _26 = ((*_1).0: &[u8]);\n        _4 = core::slice::<impl [u8]>::as_ptr(_26) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = move _4 as *mut libc::c_void;\n        StorageDead(_4);\n        (_2.4: *mut libc::c_void) = _3;\n        _27 = ((*_1).0: &[u8]);\n        _5 = PtrMetadata(_27);\n        (_2.5: usize) = _5;\n        StorageLive(_6);\n        _7 = discriminant(((*_1).1: core::option::Option<&libc::cmsghdr>));\n        switchInt(move _7) -> [1: bb3, 0: bb5, otherwise: bb10];\n    }\n    bb3: {\n        StorageLive(_8);\n        _8 = ((((*_1).1: core::option::Option<&libc::cmsghdr>) as variant#1).0: &libc::cmsghdr);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_2;\n        _9 = &raw const (*_10);\n        StorageLive(_11);\n        _11 = &raw const (*_8);\n        _6 = libc::CMSG_NXTHDR(move _9, move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb7;\n    }\n    bb5: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_2;\n        _12 = &raw const (*_13);\n        _6 = libc::CMSG_FIRSTHDR(move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        StorageDead(_12);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _6;\n        _15 = core::ptr::mut_ptr::<impl *mut libc::cmsghdr>::as_ref::<'_>(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        _14 = <core::option::Option<&libc::cmsghdr> as core::ops::Try>::branch(move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        _17 = discriminant(_14);\n        switchInt(move _17) -> [0: bb11, 1: bb12, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        _18 = ((_14 as variant#0).0: &libc::cmsghdr);\n        StorageDead(_14);\n        _19 = discriminant(((*_1).1: core::option::Option<&libc::cmsghdr>));\n        switchInt(move _19) -> [1: bb14, 0: bb18, otherwise: bb10];\n    }\n    bb12: {\n        _0 = <core::option::Option<core::result::Result<os::unix::net::ancillary::AncillaryData<'_>, os::unix::net::ancillary::AncillaryError>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_14);\n        goto -> bb20;\n    }\n    bb14: {\n        StorageLive(_20);\n        _20 = ((((*_1).1: core::option::Option<&libc::cmsghdr>) as variant#1).0: &libc::cmsghdr);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &raw const (*_20);\n        StorageLive(_23);\n        _23 = &raw const (*_18);\n        _21 = core::ptr::eq::<libc::cmsghdr>(move _22, move _23) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _21) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageDead(_22);\n        _0 = core::option::Option::None;\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb20;\n    }\n    bb17: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_24);\n        _24 = core::option::Option::Some(_18);\n        ((*_1).1: core::option::Option<&libc::cmsghdr>) = move _24;\n        StorageDead(_24);\n        _25 = os::unix::net::ancillary::AncillaryData::<'_>::try_from_cmsghdr(_18) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _0 = core::option::Option::Some(_25);\n        StorageDead(_6);\n        StorageDead(_2);\n        goto -> bb21;\n    }\n    bb20: {\n        StorageDead(_6);\n        StorageDead(_2);\n        goto -> bb21;\n    }\n    bb21: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}