{
  "name": "os::unix::net::ancillary::add_to_ancillary_data",
  "safe": true,
  "callees": {
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "core::num::<impl usize>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::convert::TryFrom::try_from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "libc::CMSG_SPACE": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::num::<impl usize>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::ops::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::fill": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Fills `self` with elements by cloning `value`.\n\n # Examples\n\n ```\n let mut buf = vec![0; 10];\n buf.fill(1);\n assert_eq!(buf, vec![1; 10]);\n ```\n",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "libc::CMSG_FIRSTHDR": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "libc::CMSG_NXTHDR": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares raw pointers for equality.\n\n This is the same as using the `==` operator, but less generic:\n the arguments have to be `*const T` raw pointers,\n not anything that implements `PartialEq`.\n\n This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n by their address rather than comparing the values they point to\n (which is what the `PartialEq for &T` implementation does).\n\n When comparing wide pointers, both the address and the metadata are tested for equality.\n However, note that comparing trait object pointers (`*const dyn Trait`) is unreliable: pointers\n to values of the same underlying type can compare inequal (because vtables are duplicated in\n multiple codegen units), and pointers to values of *different* underlying type can compare equal\n (since identical vtables can be deduplicated within a codegen unit).\n\n # Examples\n\n ```\n use std::ptr;\n\n let five = 5;\n let other_five = 5;\n let five_ref = &five;\n let same_five_ref = &five;\n let other_five_ref = &other_five;\n\n assert!(five_ref == same_five_ref);\n assert!(ptr::eq(five_ref, same_five_ref));\n\n assert!(five_ref == other_five_ref);\n assert!(!ptr::eq(five_ref, other_five_ref));\n ```\n\n Slices are also compared by their length (fat pointers):\n\n ```\n let a = [1, 2, 3];\n assert!(std::ptr::eq(&a[..3], &a[..3]));\n assert!(!std::ptr::eq(&a[..2], &a[..3]));\n assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "libc::memcpy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::CMSG_LEN": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::CMSG_DATA": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 608, kind: RigidTy(Uint(U32)) })])"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "libc::msghdr": [
      "Plain",
      "Unknown([Field(4, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(5, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Ref",
      "Deref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::os::unix::net::ancillary::add_to_ancillary_data"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/ancillary.rs:90:1: 160:2",
  "src": "fn add_to_ancillary_data<T>(\n    buffer: &mut [u8],\n    length: &mut usize,\n    source: &[T],\n    cmsg_level: libc::c_int,\n    cmsg_type: libc::c_int,\n) -> bool {\n    #[cfg(not(target_os = \"freebsd\"))]\n    let cmsg_size = source.len().checked_mul(size_of::<T>());\n    #[cfg(target_os = \"freebsd\")]\n    let cmsg_size = Some(unsafe { libc::SOCKCRED2SIZE(1) });\n\n    let source_len = if let Some(source_len) = cmsg_size {\n        if let Ok(source_len) = u32::try_from(source_len) {\n            source_len\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    };\n\n    unsafe {\n        let additional_space = libc::CMSG_SPACE(source_len) as usize;\n\n        let new_length = if let Some(new_length) = additional_space.checked_add(*length) {\n            new_length\n        } else {\n            return false;\n        };\n\n        if new_length > buffer.len() {\n            return false;\n        }\n\n        buffer[*length..new_length].fill(0);\n\n        *length = new_length;\n\n        let mut msg: libc::msghdr = zeroed();\n        msg.msg_control = buffer.as_mut_ptr().cast();\n        msg.msg_controllen = *length as _;\n\n        let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n        let mut previous_cmsg = cmsg;\n        while !cmsg.is_null() {\n            previous_cmsg = cmsg;\n            cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n\n            // Most operating systems, but not Linux or emscripten, return the previous pointer\n            // when its length is zero. Therefore, check if the previous pointer is the same as\n            // the current one.\n            if eq(cmsg, previous_cmsg) {\n                break;\n            }\n        }\n\n        if previous_cmsg.is_null() {\n            return false;\n        }\n\n        (*previous_cmsg).cmsg_level = cmsg_level;\n        (*previous_cmsg).cmsg_type = cmsg_type;\n        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as _;\n\n        let data = libc::CMSG_DATA(previous_cmsg).cast();\n\n        libc::memcpy(data, source.as_ptr().cast(), source_len as usize);\n    }\n    true\n}",
  "mir": "fn os::unix::net::ancillary::add_to_ancillary_data(_1: &mut [u8], _2: &mut usize, _3: &[T], _4: i32, _5: i32) -> bool {\n    let mut _0: bool;\n    let  _6: core::option::Option<usize>;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: isize;\n    let  _10: usize;\n    let mut _11: core::result::Result<u32, core::num::TryFromIntError>;\n    let mut _12: isize;\n    let  _13: u32;\n    let  _14: usize;\n    let mut _15: u32;\n    let mut _16: core::option::Option<usize>;\n    let mut _17: usize;\n    let mut _18: isize;\n    let  _19: usize;\n    let mut _20: bool;\n    let mut _21: usize;\n    let mut _22: &[u8];\n    let  _23: ();\n    let mut _24: &mut [u8];\n    let mut _25: core::ops::Range<usize>;\n    let mut _26: usize;\n    let mut _27: libc::msghdr;\n    let mut _28: *mut libc::c_void;\n    let mut _29: *mut u8;\n    let mut _30: usize;\n    let mut _31: *mut libc::cmsghdr;\n    let mut _32: *const libc::msghdr;\n    let  _33: &libc::msghdr;\n    let mut _34: *mut libc::cmsghdr;\n    let mut _35: bool;\n    let mut _36: *mut libc::cmsghdr;\n    let mut _37: *mut libc::cmsghdr;\n    let mut _38: *mut libc::cmsghdr;\n    let mut _39: *const libc::msghdr;\n    let  _40: &libc::msghdr;\n    let mut _41: *const libc::cmsghdr;\n    let mut _42: *mut libc::cmsghdr;\n    let mut _43: bool;\n    let mut _44: *const libc::cmsghdr;\n    let mut _45: *mut libc::cmsghdr;\n    let mut _46: *const libc::cmsghdr;\n    let mut _47: *mut libc::cmsghdr;\n    let mut _48: bool;\n    let mut _49: *mut libc::cmsghdr;\n    let mut _50: usize;\n    let mut _51: u32;\n    let  _52: *mut libc::c_void;\n    let mut _53: *mut u8;\n    let mut _54: *const libc::cmsghdr;\n    let mut _55: *mut libc::cmsghdr;\n    let  _56: *mut libc::c_void;\n    let mut _57: *const libc::c_void;\n    let mut _58: *const T;\n    let mut _59: usize;\n    let mut _60: *const ();\n    let mut _61: usize;\n    let mut _62: usize;\n    let mut _63: usize;\n    let mut _64: bool;\n    let mut _65: *const ();\n    let mut _66: usize;\n    let mut _67: usize;\n    let mut _68: usize;\n    let mut _69: bool;\n    let mut _70: *const ();\n    let mut _71: usize;\n    let mut _72: usize;\n    let mut _73: usize;\n    let mut _74: bool;\n    let mut _75: *const ();\n    let mut _76: usize;\n    let mut _77: bool;\n    let mut _78: bool;\n    let mut _79: bool;\n    let mut _80: bool;\n    let mut _81: *const ();\n    let mut _82: usize;\n    let mut _83: bool;\n    let mut _84: bool;\n    let mut _85: bool;\n    let mut _86: bool;\n    let mut _87: *const ();\n    let mut _88: usize;\n    let mut _89: bool;\n    let mut _90: bool;\n    let mut _91: bool;\n    let mut _92: bool;\n    debug buffer => _1;\n    debug length => _2;\n    debug source => _3;\n    debug cmsg_level => _4;\n    debug cmsg_type => _5;\n    debug cmsg_size => _6;\n    debug source_len => _13;\n    debug source_len => _10;\n    debug source_len => _13;\n    debug additional_space => _14;\n    debug new_length => _19;\n    debug new_length => _19;\n    debug msg => _27;\n    debug cmsg => _31;\n    debug previous_cmsg => _34;\n    debug data => _52;\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = PtrMetadata(_3);\n        StorageLive(_8);\n        _8 = core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = core::num::<impl usize>::checked_mul(move _7, move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _9 = discriminant(_6);\n        switchInt(move _9) -> [1: bb3, 0: bb7, otherwise: bb47];\n    }\n    bb3: {\n        _10 = ((_6 as variant#1).0: usize);\n        StorageLive(_11);\n        _11 = <u32 as core::convert::TryFrom<usize>>::try_from(_10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _12 = discriminant(_11);\n        switchInt(move _12) -> [0: bb5, 1: bb6, otherwise: bb47];\n    }\n    bb5: {\n        _13 = ((_11 as variant#0).0: u32);\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = libc::CMSG_SPACE(_13) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _0 = false;\n        goto -> bb39;\n    }\n    bb7: {\n        _0 = false;\n        goto -> bb39;\n    }\n    bb8: {\n        _14 = move _15 as usize;\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (*_2);\n        _16 = core::num::<impl usize>::checked_add(_14, move _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [1: bb10, 0: bb11, otherwise: bb47];\n    }\n    bb10: {\n        _19 = ((_16 as variant#1).0: usize);\n        StorageDead(_16);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_1);\n        _21 = PtrMetadata(move _22);\n        StorageDead(_22);\n        _20 = Gt(_19, move _21);\n        switchInt(move _20) -> [0: bb13, otherwise: bb12];\n    }\n    bb11: {\n        StorageDead(_16);\n        _0 = false;\n        goto -> bb38;\n    }\n    bb12: {\n        StorageDead(_21);\n        _0 = false;\n        StorageDead(_20);\n        goto -> bb38;\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = (*_2);\n        _25 = Range(move _26, _19);\n        StorageDead(_26);\n        _24 = <[u8] as core::ops::IndexMut<core::ops::Range<usize>>>::index_mut(_1, move _25) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_25);\n        _23 = core::slice::<impl [u8]>::fill(_24, 0_u8) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        (*_2) = _19;\n        StorageLive(_27);\n        _27 = core::mem::zeroed::<libc::msghdr>() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = core::slice::<impl [u8]>::as_mut_ptr(_1) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _28 = core::ptr::mut_ptr::<impl *mut u8>::cast::<libc::c_void>(move _29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_29);\n        (_27.4: *mut libc::c_void) = move _28;\n        StorageDead(_28);\n        _30 = (*_2);\n        (_27.5: usize) = _30;\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_27;\n        _32 = &raw const (*_33);\n        _31 = libc::CMSG_FIRSTHDR(move _32) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_32);\n        StorageDead(_33);\n        StorageLive(_34);\n        _34 = _31;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = _31;\n        _35 = core::ptr::mut_ptr::<impl *mut libc::cmsghdr>::is_null(move _36) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        switchInt(move _35) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_36);\n        goto -> bb28;\n    }\n    bb23: {\n        StorageDead(_36);\n        StorageLive(_37);\n        _37 = _31;\n        _34 = move _37;\n        StorageDead(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &_27;\n        _39 = &raw const (*_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = _31;\n        _41 = move _42 as *const libc::cmsghdr;\n        StorageDead(_42);\n        _38 = libc::CMSG_NXTHDR(move _39, move _41) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_41);\n        StorageDead(_39);\n        _31 = move _38;\n        StorageDead(_38);\n        StorageDead(_40);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = _31;\n        _44 = move _45 as *const libc::cmsghdr;\n        StorageDead(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = _34;\n        _46 = move _47 as *const libc::cmsghdr;\n        StorageDead(_47);\n        _43 = core::ptr::eq::<libc::cmsghdr>(move _44, move _46) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _43) -> [0: bb27, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_46);\n        StorageDead(_44);\n        StorageDead(_43);\n        goto -> bb28;\n    }\n    bb27: {\n        StorageDead(_46);\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageDead(_35);\n        goto -> bb20;\n    }\n    bb28: {\n        StorageDead(_35);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = _34;\n        _48 = core::ptr::mut_ptr::<impl *mut libc::cmsghdr>::is_null(move _49) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        switchInt(move _48) -> [0: bb31, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_49);\n        _0 = false;\n        StorageDead(_48);\n        StorageDead(_34);\n        StorageDead(_31);\n        StorageDead(_27);\n        goto -> bb38;\n    }\n    bb31: {\n        StorageDead(_49);\n        StorageDead(_48);\n        _70 = _34 as *const ();\n        _71 = _70 as usize;\n        _72 = Sub(<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _73 = BitAnd(_71, _72);\n        _74 = Eq(_73, 0_usize);\n        assert(_74, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, _71) -> [success: bb43, unwind unreachable];\n    }\n    bb32: {\n        _50 = move _51 as usize;\n        StorageDead(_51);\n        _60 = _34 as *const ();\n        _61 = _60 as usize;\n        _62 = Sub(<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _63 = BitAnd(_61, _62);\n        _64 = Eq(_63, 0_usize);\n        assert(_64, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, _61) -> [success: bb41, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_54);\n        _52 = core::ptr::mut_ptr::<impl *mut u8>::cast::<libc::c_void>(move _53) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_53);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = core::slice::<impl [T]>::as_ptr(_3) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _57 = core::ptr::const_ptr::<impl *const T>::cast::<libc::c_void>(move _58) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_58);\n        StorageLive(_59);\n        _59 = _13 as usize;\n        _56 = libc::memcpy(_52, move _57, move _59) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_59);\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageDead(_34);\n        StorageDead(_31);\n        StorageDead(_27);\n        _0 = true;\n        StorageDead(_6);\n        goto -> bb40;\n    }\n    bb38: {\n        goto -> bb39;\n    }\n    bb39: {\n        StorageDead(_6);\n        goto -> bb40;\n    }\n    bb40: {\n        return;\n    }\n    bb41: {\n        _87 = _34 as *const ();\n        _88 = _87 as usize;\n        _89 = Ne(<libc::cmsghdr as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _90 = Eq(_88, 0_usize);\n        _91 = BitAnd(_90, _89);\n        _92 = Not(_91);\n        assert(_92, \"null pointer dereference occurred\") -> [success: bb46, unwind unreachable];\n    }\n    bb42: {\n        _81 = _34 as *const ();\n        _82 = _81 as usize;\n        _83 = Ne(<libc::cmsghdr as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _84 = Eq(_82, 0_usize);\n        _85 = BitAnd(_84, _83);\n        _86 = Not(_85);\n        assert(_86, \"null pointer dereference occurred\") -> [success: bb45, unwind unreachable];\n    }\n    bb43: {\n        _75 = _34 as *const ();\n        _76 = _75 as usize;\n        _77 = Ne(<libc::cmsghdr as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _78 = Eq(_76, 0_usize);\n        _79 = BitAnd(_78, _77);\n        _80 = Not(_79);\n        assert(_80, \"null pointer dereference occurred\") -> [success: bb44, unwind unreachable];\n    }\n    bb44: {\n        ((*_34).1: i32) = _4;\n        _65 = _34 as *const ();\n        _66 = _65 as usize;\n        _67 = Sub(<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _68 = BitAnd(_66, _67);\n        _69 = Eq(_68, 0_usize);\n        assert(_69, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, _66) -> [success: bb42, unwind unreachable];\n    }\n    bb45: {\n        ((*_34).2: i32) = _5;\n        StorageLive(_51);\n        _51 = libc::CMSG_LEN(_13) -> [return: bb32, unwind unreachable];\n    }\n    bb46: {\n        ((*_34).0: usize) = _50;\n        StorageLive(_53);\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = _34;\n        _54 = move _55 as *const libc::cmsghdr;\n        StorageDead(_55);\n        _53 = libc::CMSG_DATA(move _54) -> [return: bb33, unwind unreachable];\n    }\n    bb47: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}