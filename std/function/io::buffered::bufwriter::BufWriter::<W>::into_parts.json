{
  "name": "io::buffered::bufwriter::BufWriter::<W>::into_parts",
  "safe": true,
  "callees": {
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::mem::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Replaces `dest` with the default value of `T`, returning the previous `dest` value.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a passed value instead of the default value, see [`replace`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::take(&mut v);\n assert_eq!(vec![1, 2], old_v);\n assert!(v.is_empty());\n ```\n\n `take` allows taking ownership of a struct field by replacing it with an \"empty\" value.\n Without `take` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn get_and_reset(&mut self) -> Vec<T> {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let buf = self.buf;\n         self.buf = Vec::new();\n         buf\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n `self.buf`. But `take` can be used to disassociate the original value of `self.buf` from\n `self`, allowing it to be returned:\n\n ```\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn get_and_reset(&mut self) -> Vec<T> {\n         mem::take(&mut self.buf)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf.len(), 2);\n\n assert_eq!(buffer.get_and_reset(), vec![0, 1]);\n assert_eq!(buffer.buf.len(), 0);\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::ptr::read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads.\n\n * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n   case.\n\n * `src` must point to a properly initialized value of type `T`.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n # Examples\n\n Basic usage:\n\n ```\n let x = 12;\n let y = &x as *const i32;\n\n unsafe {\n     assert_eq!(std::ptr::read(y), 12);\n }\n ```\n\n Manually implement [`mem::swap`]:\n\n ```\n use std::ptr;\n\n fn swap<T>(a: &mut T, b: &mut T) {\n     unsafe {\n         // Create a bitwise copy of the value at `a` in `tmp`.\n         let tmp = ptr::read(a);\n\n         // Exiting at this point (either by explicitly returning or by\n         // calling a function which panics) would cause the value in `tmp` to\n         // be dropped while the same value is still referenced by `a`. This\n         // could trigger undefined behavior if `T` is not `Copy`.\n\n         // Create a bitwise copy of the value at `b` in `a`.\n         // This is safe because mutable references cannot alias.\n         ptr::copy_nonoverlapping(b, a, 1);\n\n         // As above, exiting here could trigger undefined behavior because\n         // the same value is referenced by `a` and `b`.\n\n         // Move `tmp` into `b`.\n         ptr::write(b, tmp);\n\n         // `tmp` has been moved (`write` takes ownership of its second argument),\n         // so nothing is dropped implicitly here.\n     }\n }\n\n let mut foo = \"foo\".to_owned();\n let mut bar = \"bar\".to_owned();\n\n swap(&mut foo, &mut bar);\n\n assert_eq!(foo, \"bar\");\n assert_eq!(bar, \"foo\");\n ```\n\n ## Ownership of the Returned Value\n\n `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n If `T` is not [`Copy`], using both the returned value and the value at\n `*src` can violate memory safety. Note that assigning to `*src` counts as a\n use because it will attempt to drop the value at `*src`.\n\n [`write()`] can be used to overwrite data without causing it to be dropped.\n\n ```\n use std::ptr;\n\n let mut s = String::from(\"foo\");\n unsafe {\n     // `s2` now points to the same underlying memory as `s`.\n     let mut s2: String = ptr::read(&s);\n\n     assert_eq!(s2, \"foo\");\n\n     // Assigning to `s2` causes its original value to be dropped. Beyond\n     // this point, `s` must no longer be used, as the underlying memory has\n     // been freed.\n     s2 = String::default();\n     assert_eq!(s2, \"\");\n\n     // Assigning to `s` would cause the old value to be dropped again,\n     // resulting in undefined behavior.\n     // s = String::from(\"bar\"); // ERROR\n\n     // `ptr::write` can be used to overwrite a value without dropping it.\n     ptr::write(&mut s, String::from(\"bar\"));\n }\n\n assert_eq!(s, \"bar\");\n ```\n\n [valid]: self#safety\n",
      "adt": {}
    }
  },
  "adts": {
    "io::buffered::bufwriter::BufWriter": [
      "Plain",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::mem::ManuallyDrop": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef",
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "io::buffered::bufwriter::WriterPanicked": [
      "Plain"
    ]
  },
  "path": 1348,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:175:5: 184:6",
  "src": "pub fn into_parts(self) -> (W, Result<Vec<u8>, WriterPanicked>) {\n        let mut this = ManuallyDrop::new(self);\n        let buf = mem::take(&mut this.buf);\n        let buf = if !this.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n\n        // SAFETY: double-drops are prevented by putting `this` in a ManuallyDrop that is never dropped\n        let inner = unsafe { ptr::read(&this.inner) };\n\n        (inner, buf)\n    }",
  "mir": "fn io::buffered::bufwriter::BufWriter::<W>::into_parts(_1: io::buffered::bufwriter::BufWriter<W>) -> (W, core::result::Result<alloc_crate::vec::Vec<u8>, io::buffered::bufwriter::WriterPanicked>) {\n    let mut _0: (W, core::result::Result<alloc_crate::vec::Vec<u8>, io::buffered::bufwriter::WriterPanicked>);\n    let mut _2: core::mem::ManuallyDrop<io::buffered::bufwriter::BufWriter<W>>;\n    let  _3: alloc_crate::vec::Vec<u8>;\n    let mut _4: &mut alloc_crate::vec::Vec<u8>;\n    let mut _5: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _6: &mut core::mem::ManuallyDrop<io::buffered::bufwriter::BufWriter<W>>;\n    let  _7: core::result::Result<alloc_crate::vec::Vec<u8>, io::buffered::bufwriter::WriterPanicked>;\n    let mut _8: bool;\n    let mut _9: &io::buffered::bufwriter::BufWriter<W>;\n    let mut _10: &core::mem::ManuallyDrop<io::buffered::bufwriter::BufWriter<W>>;\n    let mut _11: io::buffered::bufwriter::WriterPanicked;\n    let  _12: W;\n    let mut _13: *const W;\n    let  _14: &W;\n    let  _15: &io::buffered::bufwriter::BufWriter<W>;\n    let mut _16: &core::mem::ManuallyDrop<io::buffered::bufwriter::BufWriter<W>>;\n    let mut _17: core::result::Result<alloc_crate::vec::Vec<u8>, io::buffered::bufwriter::WriterPanicked>;\n    debug self => _1;\n    debug this => _2;\n    debug buf => _3;\n    debug buf => _7;\n    debug inner => _12;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::ManuallyDrop::<io::buffered::bufwriter::BufWriter<W>>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut _2;\n        _5 = <core::mem::ManuallyDrop<io::buffered::bufwriter::BufWriter<W>> as core::ops::DerefMut>::deref_mut(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = &mut ((*_5).0: alloc_crate::vec::Vec<u8>);\n        _3 = core::mem::take::<alloc_crate::vec::Vec<u8>>(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_2;\n        _9 = <core::mem::ManuallyDrop<io::buffered::bufwriter::BufWriter<W>> as core::ops::Deref>::deref(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = ((*_9).1: bool);\n        switchInt(move _8) -> [0: bb5, otherwise: bb6];\n    }\n    bb5: {\n        StorageDead(_9);\n        _7 = core::result::Result::Ok(_3);\n        goto -> bb7;\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = WriterPanicked(_3);\n        _7 = core::result::Result::Err(move _11);\n        StorageDead(_11);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_2;\n        _15 = <core::mem::ManuallyDrop<io::buffered::bufwriter::BufWriter<W>> as core::ops::Deref>::deref(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        _14 = &((*_15).2: W);\n        _13 = &raw const (*_14);\n        _12 = core::ptr::read::<W>(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_17);\n        _17 = move _7;\n        _0 = (_12, move _17);\n        StorageDead(_17);\n        StorageDead(_7);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n unwritten data.\n\n If the underlying writer panicked, it is not known what portion of the data was written.\n In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n contents can still be recovered).\n\n `into_parts` makes no attempt to flush data and cannot fail.\n\n # Examples\n\n ```\n use std::io::{BufWriter, Write};\n\n let mut buffer = [0u8; 10];\n let mut stream = BufWriter::new(buffer.as_mut());\n write!(stream, \"too much data\").unwrap();\n stream.flush().expect_err(\"it doesn't fit\");\n let (recovered_writer, buffered_data) = stream.into_parts();\n assert_eq!(recovered_writer.len(), 0);\n assert_eq!(&buffered_data.unwrap(), b\"ata\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}