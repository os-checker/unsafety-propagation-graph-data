{
  "name": "sys::backtrace::_print_fmt",
  "safe": false,
  "callees": {
    "env::current_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current working directory as a [`PathBuf`].\n\n # Platform-specific behavior\n\n This function [currently] corresponds to the `getcwd` function on Unix\n and the `GetCurrentDirectoryW` function on Windows.\n\n [currently]: crate::io#platform-specific-behavior\n\n # Errors\n\n Returns an [`Err`] if the current working directory value is invalid.\n Possible cases:\n\n * Current directory does not exist.\n * There are insufficient permissions to access the current directory.\n\n # Examples\n\n ```\n use std::env;\n\n fn main() -> std::io::Result<()> {\n     let path = env::current_dir()?;\n     println!(\"The current directory is {}\", path.display());\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Glue for usage of the [`write!`] macro with implementors of this trait.\n\n This method should generally not be invoked manually, but rather through\n the [`write!`] macro itself.\n\n Writes some formatted information into this instance.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo(-1)), \"Foo -1\");\n assert_eq!(format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "backtrace_rs::print::BacktraceFmt::<'a, 'b>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new `BacktraceFmt` which will write output to the provided\n `fmt`.\n\n The `format` argument will control the style in which the backtrace is\n printed, and the `print_path` argument will be used to print the\n `BytesOrWideString` instances of filenames. This type itself doesn't do\n any printing of filenames, but this callback is required to do so.\n",
      "adt": {
        "core::fmt::Formatter": "MutableAsArgument",
        "backtrace_rs::print::BacktraceFmt": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "backtrace_rs::print::BacktraceFmt::<'a, 'b>::add_context": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prints a preamble for the backtrace about to be printed.\n\n This is required on some platforms for backtraces to be fully\n symbolicated later, and otherwise this should just be the first method\n you call after creating a `BacktraceFmt`.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "backtrace_rs::print::BacktraceFmt": "MutableAsArgument"
      }
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "sys::backtrace::set_image_base": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "backtrace_rs::backtrace::trace_unsynchronized": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Same as `trace`, only unsafe as it's unsynchronized.\n\n This function does not have synchronization guarantees but is available\n when the `std` feature of this crate isn't compiled in. See the `trace`\n function for more documentation and examples.\n\n # Panics\n\n See information on `trace` for caveats on `cb` panicking.\n",
      "adt": {}
    },
    "backtrace_rs::print::BacktraceFmt::<'a, 'b>::finish": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Completes the backtrace output.\n\n This is currently a no-op but is added for future compatibility with\n backtrace formats.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "backtrace_rs::print::BacktraceFmt": "MutableAsArgument"
      }
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "backtrace_rs::print::PrintFmt": [
      "Plain",
      "Ref"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain"
    ],
    "backtrace_rs::print::BacktraceFmt": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::backtrace::_print_fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:48:1: 150:2",
  "src": "unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n    // Always 'fail' to get the cwd when running under Miri -\n    // this allows Miri to display backtraces in isolation mode\n    let cwd = if !cfg!(miri) { env::current_dir().ok() } else { None };\n\n    let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n        output_filename(fmt, bows, print_fmt, cwd.as_ref())\n    };\n    writeln!(fmt, \"stack backtrace:\")?;\n    let mut bt_fmt = BacktraceFmt::new(fmt, print_fmt, &mut print_path);\n    bt_fmt.add_context()?;\n    let mut idx = 0;\n    let mut res = Ok(());\n    let mut omitted_count: usize = 0;\n    let mut first_omit = true;\n    // If we're using a short backtrace, ignore all frames until we're told to start printing.\n    let mut print = print_fmt != PrintFmt::Short;\n    set_image_base();\n    // SAFETY: we roll our own locking in this town\n    unsafe {\n        backtrace_rs::trace_unsynchronized(|frame| {\n            if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n                return false;\n            }\n\n            if cfg!(feature = \"backtrace-trace-only\") {\n                const HEX_WIDTH: usize = 2 + 2 * size_of::<usize>();\n                let frame_ip = frame.ip();\n                res = writeln!(bt_fmt.formatter(), \"{idx:4}: {frame_ip:HEX_WIDTH$?}\");\n            } else {\n                let mut hit = false;\n                backtrace_rs::resolve_frame_unsynchronized(frame, |symbol| {\n                    hit = true;\n\n                    // `__rust_end_short_backtrace` means we are done hiding symbols\n                    // for now. Print until we see `__rust_begin_short_backtrace`.\n                    if print_fmt == PrintFmt::Short {\n                        if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n                            if sym.contains(\"__rust_end_short_backtrace\") {\n                                print = true;\n                                return;\n                            }\n                            if print && sym.contains(\"__rust_begin_short_backtrace\") {\n                                print = false;\n                                return;\n                            }\n                            if !print {\n                                omitted_count += 1;\n                            }\n                        }\n                    }\n\n                    if print {\n                        if omitted_count > 0 {\n                            debug_assert!(print_fmt == PrintFmt::Short);\n                            // only print the message between the middle of frames\n                            if !first_omit {\n                                let _ = writeln!(\n                                    bt_fmt.formatter(),\n                                    \"      [... omitted {} frame{} ...]\",\n                                    omitted_count,\n                                    if omitted_count > 1 { \"s\" } else { \"\" }\n                                );\n                            }\n                            first_omit = false;\n                            omitted_count = 0;\n                        }\n                        res = bt_fmt.frame().symbol(frame, symbol);\n                    }\n                });\n                #[cfg(all(target_os = \"nto\", any(target_env = \"nto70\", target_env = \"nto71\")))]\n                if libc::__my_thread_exit as *mut libc::c_void == frame.ip() {\n                    if !hit && print {\n                        use crate::backtrace_rs::SymbolName;\n                        res = bt_fmt.frame().print_raw(\n                            frame.ip(),\n                            Some(SymbolName::new(\"__my_thread_exit\".as_bytes())),\n                            None,\n                            None,\n                        );\n                    }\n                    return false;\n                }\n                if !hit && print {\n                    res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n                }\n            }\n\n            idx += 1;\n            res.is_ok()\n        })\n    };\n    res?;\n    bt_fmt.finish()?;\n    if print_fmt == PrintFmt::Short {\n        writeln!(\n            fmt,\n            \"note: Some details are omitted, \\\n             run with `RUST_BACKTRACE=full` for a verbose backtrace.\"\n        )?;\n    }\n    Ok(())\n}",
  "mir": "fn sys::backtrace::_print_fmt(_1: &mut core::fmt::Formatter<'_>, _2: backtrace_rs::print::PrintFmt) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let  _3: core::option::Option<path::PathBuf>;\n    let mut _4: core::result::Result<path::PathBuf, io::error::Error>;\n    let mut _5: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:53:26: 53:90};\n    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _7: core::result::Result<(), core::fmt::Error>;\n    let mut _8: core::fmt::Arguments<'_>;\n    let mut _9: isize;\n    let mut _10: backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _11: &mut dyn for<'a, 'b, 'c> core::ops::FnMut(&'a mut core::fmt::Formatter<'b>, backtrace_rs::types::BytesOrWideString<'c>) -> core::result::Result<(), core::fmt::Error>;\n    let mut _12: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:53:26: 53:90};\n    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _14: core::result::Result<(), core::fmt::Error>;\n    let mut _15: &mut backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _16: isize;\n    let mut _17: usize;\n    let mut _18: core::result::Result<(), core::fmt::Error>;\n    let mut _19: usize;\n    let mut _20: bool;\n    let mut _21: bool;\n    let mut _22: &backtrace_rs::print::PrintFmt;\n    let mut _23: &backtrace_rs::print::PrintFmt;\n    let  _24: ();\n    let  _25: ();\n    let mut _26: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:68:44: 68:51};\n    let mut _27: &backtrace_rs::print::PrintFmt;\n    let mut _28: &mut usize;\n    let mut _29: &mut core::result::Result<(), core::fmt::Error>;\n    let mut _30: &mut backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _31: &mut bool;\n    let mut _32: &mut usize;\n    let mut _33: &mut bool;\n    let mut _34: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _35: core::result::Result<(), core::fmt::Error>;\n    let mut _36: isize;\n    let mut _37: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _38: core::result::Result<(), core::fmt::Error>;\n    let mut _39: &mut backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _40: isize;\n    let mut _41: bool;\n    let mut _42: &backtrace_rs::print::PrintFmt;\n    let mut _43: &backtrace_rs::print::PrintFmt;\n    let mut _44: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _45: core::result::Result<(), core::fmt::Error>;\n    let mut _46: core::fmt::Arguments<'_>;\n    let mut _47: isize;\n    debug fmt => _1;\n    debug print_fmt => _2;\n    debug cwd => _3;\n    debug print_path => _5;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug bt_fmt => _10;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug idx => _17;\n    debug res => _18;\n    debug omitted_count => _19;\n    debug first_omit => _20;\n    debug print => _21;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = env::current_dir() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = core::result::Result::<path::PathBuf, io::error::Error>::ok(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:53:26: 53:90}(_2, move _3);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = core::fmt::Arguments::<'_>::from_str(\"stack backtrace:\\n\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = core::fmt::Formatter::<'_>::write_fmt(_1, move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _6 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _9 = discriminant(_6);\n        switchInt(move _9) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        StorageDead(_6);\n        StorageLive(_10);\n        StorageLive(_11);\n        _12 = &mut _5;\n        _11 = _12 as &mut dyn for<'a, 'b, 'c> core::ops::FnMut(&'a mut core::fmt::Formatter<'b>, backtrace_rs::types::BytesOrWideString<'c>) -> core::result::Result<(), core::fmt::Error>;\n        _10 = backtrace_rs::print::BacktraceFmt::<'_, '_>::new(_1, _2, move _11) -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        goto -> bb41;\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _10;\n        _14 = backtrace_rs::print::BacktraceFmt::<'_, '_>::add_context(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        _13 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        _16 = discriminant(_13);\n        switchInt(move _16) -> [0: bb13, 1: bb14, otherwise: bb6];\n    }\n    bb13: {\n        StorageDead(_13);\n        StorageLive(_17);\n        _17 = 0_usize;\n        StorageLive(_18);\n        _18 = core::result::Result::Ok(());\n        StorageLive(_19);\n        _19 = 0_usize;\n        StorageLive(_20);\n        _20 = true;\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_2;\n        StorageLive(_23);\n        _23 = sys::backtrace::_print_fmt::promoted[1];\n        _21 = <backtrace_rs::print::PrintFmt as core::cmp::PartialEq>::ne(move _22, move _23) -> [return: bb16, unwind unreachable];\n    }\n    bb14: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_13);\n        goto -> bb40;\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageDead(_22);\n        _24 = sys::backtrace::set_image_base() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &_2;\n        StorageLive(_28);\n        _28 = &mut _17;\n        StorageLive(_29);\n        _29 = &mut _18;\n        StorageLive(_30);\n        _30 = &mut _10;\n        StorageLive(_31);\n        _31 = &mut _21;\n        StorageLive(_32);\n        _32 = &mut _19;\n        StorageLive(_33);\n        _33 = &mut _20;\n        _26 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:68:44: 68:51}(move _27, move _28, move _29, move _30, move _31, move _32, move _33);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_27);\n        _25 = backtrace_rs::backtrace::trace_unsynchronized::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/backtrace.rs:68:44: 68:51}>(move _26) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_26);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = _18;\n        _34 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _35) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_35);\n        _36 = discriminant(_34);\n        switchInt(move _36) -> [0: bb20, 1: bb21, otherwise: bb6];\n    }\n    bb20: {\n        StorageDead(_34);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &mut _10;\n        _38 = backtrace_rs::print::BacktraceFmt::<'_, '_>::finish(move _39) -> [return: bb23, unwind unreachable];\n    }\n    bb21: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_34);\n        goto -> bb39;\n    }\n    bb23: {\n        StorageDead(_39);\n        _37 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _38) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_38);\n        _40 = discriminant(_37);\n        switchInt(move _40) -> [0: bb25, 1: bb26, otherwise: bb6];\n    }\n    bb25: {\n        StorageDead(_37);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &_2;\n        StorageLive(_43);\n        _43 = sys::backtrace::_print_fmt::promoted[0];\n        _41 = <backtrace_rs::print::PrintFmt as core::cmp::PartialEq>::eq(move _42, move _43) -> [return: bb28, unwind unreachable];\n    }\n    bb26: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_37);\n        goto -> bb39;\n    }\n    bb28: {\n        switchInt(move _41) -> [0: bb36, otherwise: bb29];\n    }\n    bb29: {\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageLive(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = core::fmt::Arguments::<'_>::from_str(\"note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\\n\") -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        _45 = core::fmt::Formatter::<'_>::write_fmt(_1, move _46) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_46);\n        _44 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _45) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_45);\n        _47 = discriminant(_44);\n        switchInt(move _47) -> [0: bb33, 1: bb34, otherwise: bb6];\n    }\n    bb33: {\n        StorageDead(_44);\n        goto -> bb37;\n    }\n    bb34: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_44);\n        StorageDead(_41);\n        goto -> bb39;\n    }\n    bb36: {\n        StorageDead(_43);\n        StorageDead(_42);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_41);\n        _0 = core::result::Result::Ok(());\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_10);\n        drop(_5) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb43;\n    }\n    bb39: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageDead(_10);\n        goto -> bb41;\n    }\n    bb41: {\n        drop(_5) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb43;\n    }\n    bb43: {\n        return;\n    }\n}\n",
  "doc": " # Safety\n\n This function is not Sync. The caller must hold a mutex lock, or there must be only one thread in the program.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}