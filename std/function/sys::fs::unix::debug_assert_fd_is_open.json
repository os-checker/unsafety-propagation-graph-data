{
  "name": "sys::fs::unix::debug_assert_fd_is_open",
  "safe": true,
  "callees": {
    "libc::fcntl": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::os::errno": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the platform-specific value of errno\n",
      "adt": {}
    },
    "sys::stdio::unix::panic_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::stdio::unix::Stderr": "Constructor"
      }
    },
    "core::fmt::Arguments::<'a>::from_str_nonconst": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::Write::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a formatted string into this writer, returning any error\n encountered.\n\n This method is primarily used to interface with the\n [`format_args!()`] macro, and it is rare that this should\n explicitly be called. The [`write!()`] macro should be favored to\n invoke this method instead.\n\n This function internally uses the [`write_all`] method on\n this trait and hence will continuously write data so long as no errors\n are received. This also means that partial writes are not indicated in\n this signature.\n\n [`write_all`]: Write::write_all\n\n # Errors\n\n This function will return any I/O error reported while formatting.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // this call\n     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n     // turns into this:\n     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::fmt::Arguments": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "process::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Terminates the process in an abnormal fashion.\n\n The function will never return and will immediately terminate the current\n process in a platform specific \"abnormal\" manner. As a consequence,\n no destructors on the current stack or any other thread's stack\n will be run, Rust IO buffers (eg, from `BufWriter`) will not be flushed,\n and C stdio buffers will (on most platforms) not be flushed.\n\n This is in contrast to the default behavior of [`panic!`] which unwinds\n the current thread's stack and calls all destructors.\n When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n [`panic!`] will still call the [panic hook] while `abort` will not.\n\n If a clean shutdown is needed it is recommended to only call\n this function at a known point where there are no more destructors left\n to run.\n\n The process's termination will be similar to that from the C `abort()`\n function.  On Unix, the process will terminate with signal `SIGABRT`, which\n typically means that the shell prints \"Aborted\".\n\n # Examples\n\n ```no_run\n use std::process;\n\n fn main() {\n     println!(\"aborting\");\n\n     process::abort();\n\n     // execution never gets here\n }\n ```\n\n The `abort` function terminates the process, so the destructor will not\n get run on the example below:\n\n ```no_run\n use std::process;\n\n struct HasDrop;\n\n impl Drop for HasDrop {\n     fn drop(&mut self) {\n         println!(\"This will never be printed!\");\n     }\n }\n\n fn main() {\n     let _x = HasDrop;\n     process::abort();\n     // the destructor implemented for HasDrop will never get run\n }\n ```\n\n [panic hook]: crate::panic::set_hook\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "sys::stdio::unix::Stderr": [
      "MutRef",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 3462,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:856:1: 865:2",
  "src": "pub(crate) fn debug_assert_fd_is_open(fd: RawFd) {\n    use crate::sys::os::errno;\n\n    // this is similar to assert_unsafe_precondition!() but it doesn't require const\n    if core::ub_checks::check_library_ub() {\n        if unsafe { libc::fcntl(fd, libc::F_GETFD) } == -1 && errno() == libc::EBADF {\n            rtabort!(\"IO Safety violation: owned file descriptor already closed\");\n        }\n    }\n}",
  "mir": "fn sys::fs::unix::debug_assert_fd_is_open(_1: i32) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: i32;\n    let mut _4: bool;\n    let mut _5: i32;\n    let mut _6: core::option::Option<sys::stdio::unix::Stderr>;\n    let mut _7: isize;\n    let mut _8: sys::stdio::unix::Stderr;\n    let mut _9: core::result::Result<(), io::error::Error>;\n    let mut _10: &mut sys::stdio::unix::Stderr;\n    let mut _11: core::fmt::Arguments<'_>;\n    let  _12: !;\n    debug fd => _1;\n    debug out => sys::stdio::unix::Stderr;\n    bb0: {\n        StorageLive(_2);\n        _2 = RuntimeChecks(UbChecks)() \" \";\n        switchInt(move _2) -> [0: bb16, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = libc::fcntl(_1, libc::F_GETFD) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _3) -> [4294967295: bb3, otherwise: bb14];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = sys::pal::unix::os::errno() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _4 = Eq(move _5, libc::EBADF);\n        switchInt(move _4) -> [0: bb13, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = sys::stdio::unix::panic_output() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _7 = discriminant(_6);\n        switchInt(move _7) -> [1: bb7, 0: bb11, otherwise: bb17];\n    }\n    bb7: {\n        StorageLive(_9);\n        _10 = &mut _8;\n        StorageLive(_11);\n        _11 = core::fmt::Arguments::<'_>::from_str_nonconst(\"fatal runtime error: IO Safety violation: owned file descriptor already closed, aborting\\n\") -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _9 = <sys::stdio::unix::Stderr as io::Write>::write_fmt(_10, move _11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        drop(_9) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_9);\n        StorageDead(_6);\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_6);\n        goto -> bb12;\n    }\n    bb12: {\n        _12 = process::abort() -> unwind unreachable;\n    }\n    bb13: {\n        StorageDead(_5);\n        goto -> bb15;\n    }\n    bb14: {\n        StorageDead(_3);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_4);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_2);\n        return;\n    }\n    bb17: {\n        unreachable;\n    }\n}\n",
  "doc": " Aborts the process if a file desceriptor is not open, if debug asserts are enabled\n\n Many IO syscalls can't be fully trusted about EBADF error codes because those\n might get bubbled up from a remote FUSE server rather than the file descriptor\n in the current process being invalid.\n\n So we check file flags instead which live on the file descriptor and not the underlying file.\n The downside is that it costs an extra syscall, so we only do it for debug.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}