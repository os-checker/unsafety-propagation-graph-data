{
  "name": "panic::PanicHookInfo::<'a>::payload",
  "safe": true,
  "callees": {},
  "adts": {
    "panic::PanicHookInfo": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ]
  },
  "path": 2279,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:95:5: 97:6",
  "src": "pub fn payload(&self) -> &(dyn Any + Send) {\n        self.payload\n    }",
  "mir": "fn panic::PanicHookInfo::<'a>::payload(_1: &panic::PanicHookInfo<'_>) -> &dyn core::any::Any + core::marker::Send {\n    let mut _0: &dyn core::any::Any + core::marker::Send;\n    debug self => _1;\n    bb0: {\n        _0 = ((*_1).0: &dyn core::any::Any + core::marker::Send);\n        return;\n    }\n}\n",
  "doc": " Returns the payload associated with the panic.\n\n This will commonly, but not always, be a `&'static str` or [`String`].\n If you only care about such payloads, use [`payload_as_str`] instead.\n\n A invocation of the `panic!()` macro in Rust 2021 or later will always result in a\n panic payload of type `&'static str` or `String`.\n\n Only an invocation of [`panic_any`]\n (or, in Rust 2018 and earlier, `panic!(x)` where `x` is something other than a string)\n can result in a panic payload other than a `&'static str` or `String`.\n\n [`String`]: ../../std/string/struct.String.html\n [`payload_as_str`]: PanicHookInfo::payload_as_str\n\n # Examples\n\n ```should_panic\n use std::panic;\n\n panic::set_hook(Box::new(|panic_info| {\n     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n         println!(\"panic occurred: {s:?}\");\n     } else if let Some(s) = panic_info.payload().downcast_ref::<String>() {\n         println!(\"panic occurred: {s:?}\");\n     } else {\n         println!(\"panic occurred\");\n     }\n }));\n\n panic!(\"Normal panic\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}