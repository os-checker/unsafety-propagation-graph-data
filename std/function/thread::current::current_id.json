{
  "name": "thread::current::current_id",
  "safe": true,
  "callees": {
    "thread::current::id::get_or_init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "thread::id::ThreadId": "Constructor"
      }
    }
  },
  "adts": {
    "thread::id::ThreadId": [
      "Plain"
    ]
  },
  "path": 4450,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/current.rs:164:1: 175:2",
  "src": "pub fn current_id() -> ThreadId {\n    // If accessing the persistent thread ID takes multiple TLS accesses, try\n    // to retrieve it from the current thread handle, which will only take one\n    // TLS access.\n    if !id::CHEAP {\n        if let Some(id) = try_with_current(|t| t.map(|t| t.id())) {\n            return id;\n        }\n    }\n\n    id::get_or_init()\n}",
  "mir": "fn thread::current::current_id() -> thread::id::ThreadId {\n    let mut _0: thread::id::ThreadId;\n    let  _1: thread::id::ThreadId;\n    debug id => _1;\n    bb0: {\n        _0 = thread::current::id::get_or_init() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Gets the unique identifier of the thread which invokes it.\n\n Calling this function may be more efficient than accessing the current\n thread id through the current thread handle. i.e. `thread::current().id()`.\n\n This function will always succeed, will always return the same value for\n one thread and is guaranteed not to call the global allocator.\n\n # Examples\n\n ```\n #![feature(current_thread_id)]\n\n use std::thread;\n\n let other_thread = thread::spawn(|| {\n     thread::current_id()\n });\n\n let other_thread_id = other_thread.join().unwrap();\n assert_ne!(thread::current_id(), other_thread_id);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}