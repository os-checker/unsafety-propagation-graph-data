{
  "name": "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::FromStr>::from_str",
  "safe": true,
  "callees": {
    "core::str::<impl str>::trim_start": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a string slice with leading whitespace removed.\n\n 'Whitespace' is defined according to the terms of the Unicode Derived\n Core Property `White_Space`, which includes newlines.\n\n # Text directionality\n\n A string is a sequence of bytes. `start` in this context means the first\n position of that byte string; for a left-to-right language like English or\n Russian, this will be left side, and for right-to-left languages like\n Arabic or Hebrew, this will be the right side.\n\n # Examples\n\n Basic usage:\n\n ```\n let s = \"\\n Hello\\tworld\\t\\n\";\n assert_eq!(\"Hello\\tworld\\t\\n\", s.trim_start());\n ```\n\n Directionality:\n\n ```\n let s = \"  English  \";\n assert!(Some('E') == s.trim_start().chars().next());\n\n let s = \"  עברית  \";\n assert!(Some('ע') == s.trim_start().chars().next());\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::split_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the string on the first occurrence of the specified delimiter and\n returns prefix before delimiter and suffix after delimiter.\n\n # Examples\n\n ```\n assert_eq!(\"cfg\".split_once('='), None);\n assert_eq!(\"cfg=\".split_once('='), Some((\"cfg\", \"\")));\n assert_eq!(\"cfg=foo\".split_once('='), Some((\"cfg\", \"foo\")));\n assert_eq!(\"cfg=foo=bar\".split_once('='), Some((\"cfg\", \"foo=bar\")));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` has a length of zero bytes.\n\n # Examples\n\n ```\n let s = \"\";\n assert!(s.is_empty());\n\n let s = \"not empty\";\n assert!(!s.is_empty());\n ```\n",
      "adt": {}
    },
    "core::ops::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"y̆\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'y̆'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7424, kind: RigidTy(Tuple([Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) }, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) }])) }), Field(0, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7424, kind: RigidTy(Tuple([Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) }, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) }])) }), Field(1, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })])",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 18544, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3103, kind: RigidTy(Char) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])"
    ],
    "core::str::Chars": [
      "Plain",
      "MutRef"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ],
    "backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::FromStr>::from_str"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:98:5: 161:6",
  "src": "fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let (range_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if range_str.is_empty() {\n            return Err(\"Couldn't find address\");\n        }\n\n        let (perms_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if perms_str.is_empty() {\n            return Err(\"Couldn't find permissions\");\n        }\n\n        let (offset_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if offset_str.is_empty() {\n            return Err(\"Couldn't find offset\");\n        }\n\n        let (dev_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if dev_str.is_empty() {\n            return Err(\"Couldn't find dev\");\n        }\n\n        let (inode_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if inode_str.is_empty() {\n            return Err(\"Couldn't find inode\");\n        }\n\n        // Pathname may be omitted in which case it will be empty\n        let pathname_str = s.trim_start();\n\n        let hex = |s| usize::from_str_radix(s, 16).map_err(|_| \"Couldn't parse hex number\");\n        let hex64 = |s| u64::from_str_radix(s, 16).map_err(|_| \"Couldn't parse hex number\");\n\n        let address = if let Some((start, limit)) = range_str.split_once('-') {\n            (hex(start)?, hex(limit)?)\n        } else {\n            return Err(\"Couldn't parse address range\");\n        };\n        let perms: [char; 4] = {\n            let mut chars = perms_str.chars();\n            let mut c = || chars.next().ok_or(\"insufficient perms\");\n            let perms = [c()?, c()?, c()?, c()?];\n            if chars.next().is_some() {\n                return Err(\"too many perms\");\n            }\n            perms\n        };\n        let offset = hex64(offset_str)?;\n        let dev = if let Some((major, minor)) = dev_str.split_once(':') {\n            (hex(major)?, hex(minor)?)\n        } else {\n            return Err(\"Couldn't parse dev\");\n        };\n        let inode = hex(inode_str)?;\n        let pathname = pathname_str.into();\n\n        Ok(MapsEntry {\n            address,\n            perms,\n            offset,\n            dev,\n            inode,\n            pathname,\n        })\n    }",
  "mir": "fn <backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::FromStr>::from_str(_1: &str) -> core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> {\n    let mut _0: core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str>;\n    let  _2: &str;\n    let  _3: &str;\n    let mut _4: (&str, &str);\n    let mut _5: core::option::Option<(&str, &str)>;\n    let  _6: &str;\n    let mut _7: (&str, &str);\n    let mut _8: &str;\n    let mut _9: bool;\n    let mut _10: &str;\n    let  _11: &str;\n    let  _12: &str;\n    let mut _13: (&str, &str);\n    let mut _14: core::option::Option<(&str, &str)>;\n    let  _15: &str;\n    let mut _16: (&str, &str);\n    let mut _17: &str;\n    let mut _18: bool;\n    let mut _19: &str;\n    let  _20: &str;\n    let  _21: &str;\n    let mut _22: (&str, &str);\n    let mut _23: core::option::Option<(&str, &str)>;\n    let  _24: &str;\n    let mut _25: (&str, &str);\n    let mut _26: &str;\n    let mut _27: bool;\n    let mut _28: &str;\n    let  _29: &str;\n    let  _30: &str;\n    let mut _31: (&str, &str);\n    let mut _32: core::option::Option<(&str, &str)>;\n    let  _33: &str;\n    let mut _34: (&str, &str);\n    let mut _35: &str;\n    let mut _36: bool;\n    let mut _37: &str;\n    let  _38: &str;\n    let  _39: &str;\n    let mut _40: (&str, &str);\n    let mut _41: core::option::Option<(&str, &str)>;\n    let  _42: &str;\n    let mut _43: (&str, &str);\n    let mut _44: &str;\n    let mut _45: bool;\n    let mut _46: &str;\n    let  _47: &str;\n    let  _48: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22};\n    let  _49: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:128:21: 128:24};\n    let  _50: (usize, usize);\n    let mut _51: core::option::Option<(&str, &str)>;\n    let mut _52: isize;\n    let  _53: &str;\n    let  _54: &str;\n    let mut _55: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, usize>;\n    let mut _56: core::result::Result<usize, &str>;\n    let mut _57: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22};\n    let mut _58: (&str,);\n    let mut _59: isize;\n    let  _60: core::result::Result<core::convert::Infallible, &str>;\n    let  _61: usize;\n    let mut _62: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, usize>;\n    let mut _63: core::result::Result<usize, &str>;\n    let mut _64: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22};\n    let mut _65: (&str,);\n    let mut _66: isize;\n    let  _67: core::result::Result<core::convert::Infallible, &str>;\n    let  _68: usize;\n    let mut _69: &str;\n    let mut _70: core::str::Chars<'_>;\n    let mut _71: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27};\n    let mut _72: &mut core::str::Chars<'_>;\n    let  _73: [char; 4];\n    let mut _74: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, char>;\n    let mut _75: core::result::Result<char, &str>;\n    let mut _76: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27};\n    let mut _77: isize;\n    let  _78: core::result::Result<core::convert::Infallible, &str>;\n    let  _79: char;\n    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, char>;\n    let mut _81: core::result::Result<char, &str>;\n    let mut _82: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27};\n    let mut _83: isize;\n    let  _84: core::result::Result<core::convert::Infallible, &str>;\n    let  _85: char;\n    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, char>;\n    let mut _87: core::result::Result<char, &str>;\n    let mut _88: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27};\n    let mut _89: isize;\n    let  _90: core::result::Result<core::convert::Infallible, &str>;\n    let  _91: char;\n    let mut _92: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, char>;\n    let mut _93: core::result::Result<char, &str>;\n    let mut _94: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27};\n    let mut _95: isize;\n    let  _96: core::result::Result<core::convert::Infallible, &str>;\n    let  _97: char;\n    let mut _98: bool;\n    let mut _99: &core::option::Option<char>;\n    let  _100: core::option::Option<char>;\n    let mut _101: &mut core::str::Chars<'_>;\n    let mut _102: &str;\n    let mut _103: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, u64>;\n    let mut _104: core::result::Result<u64, &str>;\n    let mut _105: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:128:21: 128:24};\n    let mut _106: (&str,);\n    let mut _107: isize;\n    let  _108: core::result::Result<core::convert::Infallible, &str>;\n    let  _109: u64;\n    let  _110: (usize, usize);\n    let mut _111: core::option::Option<(&str, &str)>;\n    let mut _112: isize;\n    let  _113: &str;\n    let  _114: &str;\n    let mut _115: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, usize>;\n    let mut _116: core::result::Result<usize, &str>;\n    let mut _117: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22};\n    let mut _118: (&str,);\n    let mut _119: isize;\n    let  _120: core::result::Result<core::convert::Infallible, &str>;\n    let  _121: usize;\n    let mut _122: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, usize>;\n    let mut _123: core::result::Result<usize, &str>;\n    let mut _124: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22};\n    let mut _125: (&str,);\n    let mut _126: isize;\n    let  _127: core::result::Result<core::convert::Infallible, &str>;\n    let  _128: usize;\n    let mut _129: &str;\n    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, usize>;\n    let mut _131: core::result::Result<usize, &str>;\n    let mut _132: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22};\n    let mut _133: (&str,);\n    let mut _134: isize;\n    let  _135: core::result::Result<core::convert::Infallible, &str>;\n    let  _136: usize;\n    let  _137: ffi::os_str::OsString;\n    let mut _138: backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry;\n    debug s => _1;\n    debug range_str => _2;\n    debug s => _3;\n    debug perms_str => _11;\n    debug s => _12;\n    debug offset_str => _20;\n    debug s => _21;\n    debug dev_str => _29;\n    debug s => _30;\n    debug inode_str => _38;\n    debug s => _39;\n    debug pathname_str => _47;\n    debug hex => ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22};\n    debug hex64 => ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:128:21: 128:24};\n    debug address => _50;\n    debug start => _53;\n    debug limit => _54;\n    debug residual => _60;\n    debug val => _61;\n    debug residual => _67;\n    debug val => _68;\n    debug perms => _73;\n    debug chars => _70;\n    debug c => _71;\n    debug perms => _73;\n    debug residual => _78;\n    debug val => _79;\n    debug residual => _84;\n    debug val => _85;\n    debug residual => _90;\n    debug val => _91;\n    debug residual => _96;\n    debug val => _97;\n    debug offset => _109;\n    debug residual => _108;\n    debug val => _109;\n    debug dev => _110;\n    debug major => _113;\n    debug minor => _114;\n    debug residual => _120;\n    debug val => _121;\n    debug residual => _127;\n    debug val => _128;\n    debug inode => _136;\n    debug residual => _135;\n    debug val => _136;\n    debug pathname => _137;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _6 = core::str::<impl str>::trim_start(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = core::str::<impl str>::split_once::<char>(_6, ' ') -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = \"\";\n        _7 = (_1, move _8);\n        StorageDead(_8);\n        _4 = core::option::Option::<(&str, &str)>::unwrap_or(move _5, move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageDead(_5);\n        _2 = (_4.0: &str);\n        _3 = (_4.1: &str);\n        StorageDead(_4);\n        StorageLive(_9);\n        _9 = core::str::<impl str>::is_empty(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _9) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageLive(_10);\n        _10 = \"Couldn't find address\";\n        _0 = core::result::Result::Err(move _10);\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb109;\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_13);\n        StorageLive(_14);\n        _15 = core::str::<impl str>::trim_start(_3) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = core::str::<impl str>::split_once::<char>(_15, ' ') -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = \"\";\n        _16 = (_3, move _17);\n        StorageDead(_17);\n        _13 = core::option::Option::<(&str, &str)>::unwrap_or(move _14, move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        StorageDead(_14);\n        _11 = (_13.0: &str);\n        _12 = (_13.1: &str);\n        StorageDead(_13);\n        StorageLive(_18);\n        _18 = core::str::<impl str>::is_empty(_11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _18) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageLive(_19);\n        _19 = \"Couldn't find permissions\";\n        _0 = core::result::Result::Err(move _19);\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb108;\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageLive(_22);\n        StorageLive(_23);\n        _24 = core::str::<impl str>::trim_start(_12) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _23 = core::str::<impl str>::split_once::<char>(_24, ' ') -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = \"\";\n        _25 = (_12, move _26);\n        StorageDead(_26);\n        _22 = core::option::Option::<(&str, &str)>::unwrap_or(move _23, move _25) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageDead(_23);\n        _20 = (_22.0: &str);\n        _21 = (_22.1: &str);\n        StorageDead(_22);\n        StorageLive(_27);\n        _27 = core::str::<impl str>::is_empty(_20) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        switchInt(move _27) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        StorageLive(_28);\n        _28 = \"Couldn't find offset\";\n        _0 = core::result::Result::Err(move _28);\n        StorageDead(_28);\n        StorageDead(_27);\n        goto -> bb107;\n    }\n    bb18: {\n        StorageDead(_27);\n        StorageLive(_31);\n        StorageLive(_32);\n        _33 = core::str::<impl str>::trim_start(_21) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _32 = core::str::<impl str>::split_once::<char>(_33, ' ') -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = \"\";\n        _34 = (_21, move _35);\n        StorageDead(_35);\n        _31 = core::option::Option::<(&str, &str)>::unwrap_or(move _32, move _34) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_34);\n        StorageDead(_32);\n        _29 = (_31.0: &str);\n        _30 = (_31.1: &str);\n        StorageDead(_31);\n        StorageLive(_36);\n        _36 = core::str::<impl str>::is_empty(_29) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        switchInt(move _36) -> [0: bb24, otherwise: bb23];\n    }\n    bb23: {\n        StorageLive(_37);\n        _37 = \"Couldn't find dev\";\n        _0 = core::result::Result::Err(move _37);\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb106;\n    }\n    bb24: {\n        StorageDead(_36);\n        StorageLive(_40);\n        StorageLive(_41);\n        _42 = core::str::<impl str>::trim_start(_30) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        _41 = core::str::<impl str>::split_once::<char>(_42, ' ') -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = \"\";\n        _43 = (_30, move _44);\n        StorageDead(_44);\n        _40 = core::option::Option::<(&str, &str)>::unwrap_or(move _41, move _43) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_43);\n        StorageDead(_41);\n        _38 = (_40.0: &str);\n        _39 = (_40.1: &str);\n        StorageDead(_40);\n        StorageLive(_45);\n        _45 = core::str::<impl str>::is_empty(_38) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        switchInt(move _45) -> [0: bb30, otherwise: bb29];\n    }\n    bb29: {\n        StorageLive(_46);\n        _46 = \"Couldn't find inode\";\n        _0 = core::result::Result::Err(move _46);\n        StorageDead(_46);\n        StorageDead(_45);\n        goto -> bb105;\n    }\n    bb30: {\n        StorageDead(_45);\n        _47 = core::str::<impl str>::trim_start(_39) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageLive(_51);\n        _51 = core::str::<impl str>::split_once::<char>(_2, '-') -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _52 = discriminant(_51);\n        switchInt(move _52) -> [1: bb33, 0: bb45, otherwise: bb36];\n    }\n    bb33: {\n        _53 = (((_51 as variant#1).0: (&str, &str)).0: &str);\n        _54 = (((_51 as variant#1).0: (&str, &str)).1: &str);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &_48;\n        StorageLive(_58);\n        _58 = (_53);\n        _56 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22} as core::ops::Fn<(&str,)>>::call(move _57, move _58) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_58);\n        StorageDead(_57);\n        _55 = <core::result::Result<usize, &str> as core::ops::Try>::branch(move _56) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_56);\n        _59 = discriminant(_55);\n        switchInt(move _59) -> [0: bb37, 1: bb38, otherwise: bb36];\n    }\n    bb36: {\n        unreachable;\n    }\n    bb37: {\n        _61 = ((_55 as variant#0).0: usize);\n        StorageLive(_62);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = &_48;\n        StorageLive(_65);\n        _65 = (_54);\n        _63 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22} as core::ops::Fn<(&str,)>>::call(move _64, move _65) -> [return: bb40, unwind unreachable];\n    }\n    bb38: {\n        _60 = ((_55 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_60) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        goto -> bb103;\n    }\n    bb40: {\n        StorageDead(_65);\n        StorageDead(_64);\n        _62 = <core::result::Result<usize, &str> as core::ops::Try>::branch(move _63) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_63);\n        _66 = discriminant(_62);\n        switchInt(move _66) -> [0: bb42, 1: bb43, otherwise: bb36];\n    }\n    bb42: {\n        _68 = ((_62 as variant#0).0: usize);\n        _50 = (_61, _68);\n        StorageDead(_62);\n        StorageDead(_55);\n        StorageDead(_51);\n        StorageLive(_70);\n        _70 = core::str::<impl str>::chars(_11) -> [return: bb46, unwind unreachable];\n    }\n    bb43: {\n        _67 = ((_62 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_67) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_62);\n        goto -> bb103;\n    }\n    bb45: {\n        StorageDead(_51);\n        StorageLive(_69);\n        _69 = \"Couldn't parse address range\";\n        _0 = core::result::Result::Err(move _69);\n        StorageDead(_69);\n        goto -> bb104;\n    }\n    bb46: {\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = &mut _70;\n        _71 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27}(move _72);\n        StorageDead(_72);\n        StorageLive(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = &mut _71;\n        _75 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27} as core::ops::FnMut<()>>::call_mut(move _76, ()) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_76);\n        _74 = <core::result::Result<char, &str> as core::ops::Try>::branch(move _75) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_75);\n        _77 = discriminant(_74);\n        switchInt(move _77) -> [0: bb49, 1: bb50, otherwise: bb36];\n    }\n    bb49: {\n        _79 = ((_74 as variant#0).0: char);\n        StorageLive(_80);\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = &mut _71;\n        _81 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27} as core::ops::FnMut<()>>::call_mut(move _82, ()) -> [return: bb52, unwind unreachable];\n    }\n    bb50: {\n        _78 = ((_74 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_78) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        goto -> bb100;\n    }\n    bb52: {\n        StorageDead(_82);\n        _80 = <core::result::Result<char, &str> as core::ops::Try>::branch(move _81) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_81);\n        _83 = discriminant(_80);\n        switchInt(move _83) -> [0: bb54, 1: bb55, otherwise: bb36];\n    }\n    bb54: {\n        _85 = ((_80 as variant#0).0: char);\n        StorageLive(_86);\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = &mut _71;\n        _87 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27} as core::ops::FnMut<()>>::call_mut(move _88, ()) -> [return: bb57, unwind unreachable];\n    }\n    bb55: {\n        _84 = ((_80 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_84) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        goto -> bb99;\n    }\n    bb57: {\n        StorageDead(_88);\n        _86 = <core::result::Result<char, &str> as core::ops::Try>::branch(move _87) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_87);\n        _89 = discriminant(_86);\n        switchInt(move _89) -> [0: bb59, 1: bb60, otherwise: bb36];\n    }\n    bb59: {\n        _91 = ((_86 as variant#0).0: char);\n        StorageLive(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        _94 = &mut _71;\n        _93 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:137:25: 137:27} as core::ops::FnMut<()>>::call_mut(move _94, ()) -> [return: bb62, unwind unreachable];\n    }\n    bb60: {\n        _90 = ((_86 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_90) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        goto -> bb98;\n    }\n    bb62: {\n        StorageDead(_94);\n        _92 = <core::result::Result<char, &str> as core::ops::Try>::branch(move _93) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_93);\n        _95 = discriminant(_92);\n        switchInt(move _95) -> [0: bb64, 1: bb65, otherwise: bb36];\n    }\n    bb64: {\n        _97 = ((_92 as variant#0).0: char);\n        _73 = [_79, _85, _91, _97];\n        StorageDead(_92);\n        StorageDead(_86);\n        StorageDead(_80);\n        StorageDead(_74);\n        StorageLive(_98);\n        StorageLive(_99);\n        StorageLive(_100);\n        StorageLive(_101);\n        _101 = &mut _70;\n        _100 = <core::str::Chars<'_> as core::iter::Iterator>::next(move _101) -> [return: bb67, unwind unreachable];\n    }\n    bb65: {\n        _96 = ((_92 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_96) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_92);\n        goto -> bb98;\n    }\n    bb67: {\n        _99 = &_100;\n        StorageDead(_101);\n        _98 = core::option::Option::<char>::is_some(move _99) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        switchInt(move _98) -> [0: bb70, otherwise: bb69];\n    }\n    bb69: {\n        StorageDead(_100);\n        StorageDead(_99);\n        StorageLive(_102);\n        _102 = \"too many perms\";\n        _0 = core::result::Result::Err(move _102);\n        StorageDead(_102);\n        StorageDead(_98);\n        goto -> bb101;\n    }\n    bb70: {\n        StorageDead(_100);\n        StorageDead(_99);\n        StorageDead(_98);\n        StorageDead(_71);\n        StorageDead(_70);\n        StorageLive(_103);\n        StorageLive(_104);\n        StorageLive(_105);\n        _105 = &_49;\n        StorageLive(_106);\n        _106 = (_20);\n        _104 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:128:21: 128:24} as core::ops::Fn<(&str,)>>::call(move _105, move _106) -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        StorageDead(_106);\n        StorageDead(_105);\n        _103 = <core::result::Result<u64, &str> as core::ops::Try>::branch(move _104) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        StorageDead(_104);\n        _107 = discriminant(_103);\n        switchInt(move _107) -> [0: bb73, 1: bb74, otherwise: bb36];\n    }\n    bb73: {\n        _109 = ((_103 as variant#0).0: u64);\n        StorageDead(_103);\n        StorageLive(_111);\n        _111 = core::str::<impl str>::split_once::<char>(_29, ':') -> [return: bb76, unwind unreachable];\n    }\n    bb74: {\n        _108 = ((_103 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_108) -> [return: bb75, unwind unreachable];\n    }\n    bb75: {\n        StorageDead(_103);\n        goto -> bb97;\n    }\n    bb76: {\n        _112 = discriminant(_111);\n        switchInt(move _112) -> [1: bb77, 0: bb88, otherwise: bb36];\n    }\n    bb77: {\n        _113 = (((_111 as variant#1).0: (&str, &str)).0: &str);\n        _114 = (((_111 as variant#1).0: (&str, &str)).1: &str);\n        StorageLive(_115);\n        StorageLive(_116);\n        StorageLive(_117);\n        _117 = &_48;\n        StorageLive(_118);\n        _118 = (_113);\n        _116 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22} as core::ops::Fn<(&str,)>>::call(move _117, move _118) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        StorageDead(_118);\n        StorageDead(_117);\n        _115 = <core::result::Result<usize, &str> as core::ops::Try>::branch(move _116) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_116);\n        _119 = discriminant(_115);\n        switchInt(move _119) -> [0: bb80, 1: bb81, otherwise: bb36];\n    }\n    bb80: {\n        _121 = ((_115 as variant#0).0: usize);\n        StorageLive(_122);\n        StorageLive(_123);\n        StorageLive(_124);\n        _124 = &_48;\n        StorageLive(_125);\n        _125 = (_114);\n        _123 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22} as core::ops::Fn<(&str,)>>::call(move _124, move _125) -> [return: bb83, unwind unreachable];\n    }\n    bb81: {\n        _120 = ((_115 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_120) -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        goto -> bb95;\n    }\n    bb83: {\n        StorageDead(_125);\n        StorageDead(_124);\n        _122 = <core::result::Result<usize, &str> as core::ops::Try>::branch(move _123) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        StorageDead(_123);\n        _126 = discriminant(_122);\n        switchInt(move _126) -> [0: bb85, 1: bb86, otherwise: bb36];\n    }\n    bb85: {\n        _128 = ((_122 as variant#0).0: usize);\n        _110 = (_121, _128);\n        StorageDead(_122);\n        StorageDead(_115);\n        StorageDead(_111);\n        StorageLive(_130);\n        StorageLive(_131);\n        StorageLive(_132);\n        _132 = &_48;\n        StorageLive(_133);\n        _133 = (_38);\n        _131 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:127:19: 127:22} as core::ops::Fn<(&str,)>>::call(move _132, move _133) -> [return: bb89, unwind unreachable];\n    }\n    bb86: {\n        _127 = ((_122 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_127) -> [return: bb87, unwind unreachable];\n    }\n    bb87: {\n        StorageDead(_122);\n        goto -> bb95;\n    }\n    bb88: {\n        StorageDead(_111);\n        StorageLive(_129);\n        _129 = \"Couldn't parse dev\";\n        _0 = core::result::Result::Err(move _129);\n        StorageDead(_129);\n        goto -> bb96;\n    }\n    bb89: {\n        StorageDead(_133);\n        StorageDead(_132);\n        _130 = <core::result::Result<usize, &str> as core::ops::Try>::branch(move _131) -> [return: bb90, unwind unreachable];\n    }\n    bb90: {\n        StorageDead(_131);\n        _134 = discriminant(_130);\n        switchInt(move _134) -> [0: bb91, 1: bb92, otherwise: bb36];\n    }\n    bb91: {\n        _136 = ((_130 as variant#0).0: usize);\n        StorageDead(_130);\n        _137 = <&str as core::convert::Into<ffi::os_str::OsString>>::into(_47) -> [return: bb94, unwind unreachable];\n    }\n    bb92: {\n        _135 = ((_130 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_135) -> [return: bb93, unwind unreachable];\n    }\n    bb93: {\n        StorageDead(_130);\n        goto -> bb96;\n    }\n    bb94: {\n        StorageLive(_138);\n        _138 = MapsEntry(_50, _73, _109, _110, _136, _137);\n        _0 = core::result::Result::Ok(move _138);\n        StorageDead(_138);\n        goto -> bb110;\n    }\n    bb95: {\n        StorageDead(_115);\n        StorageDead(_111);\n        goto -> bb96;\n    }\n    bb96: {\n        goto -> bb97;\n    }\n    bb97: {\n        goto -> bb102;\n    }\n    bb98: {\n        StorageDead(_86);\n        goto -> bb99;\n    }\n    bb99: {\n        StorageDead(_80);\n        goto -> bb100;\n    }\n    bb100: {\n        StorageDead(_74);\n        goto -> bb101;\n    }\n    bb101: {\n        StorageDead(_71);\n        StorageDead(_70);\n        goto -> bb102;\n    }\n    bb102: {\n        goto -> bb104;\n    }\n    bb103: {\n        StorageDead(_55);\n        StorageDead(_51);\n        goto -> bb104;\n    }\n    bb104: {\n        goto -> bb105;\n    }\n    bb105: {\n        goto -> bb106;\n    }\n    bb106: {\n        goto -> bb107;\n    }\n    bb107: {\n        goto -> bb108;\n    }\n    bb108: {\n        goto -> bb109;\n    }\n    bb109: {\n        goto -> bb110;\n    }\n    bb110: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}