{
  "name": "sys::thread::unix::cgroups::find_mountpoint",
  "safe": true,
  "callees": {
    "fs::File::open_buffered": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to open a file in read-only mode with buffering.\n\n See the [`OpenOptions::open`] method, the [`BufReader`][io::BufReader] type,\n and the [`BufRead`][io::BufRead] trait for more details.\n\n If you only need to read the entire file contents,\n consider [`std::fs::read()`][self::read] or\n [`std::fs::read_to_string()`][self::read_to_string] instead.\n\n # Errors\n\n This function will return an error if `path` does not already exist,\n or if memory allocation fails for the new buffer.\n Other errors may also be returned according to [`OpenOptions::open`].\n\n # Examples\n\n ```no_run\n #![feature(file_buffered)]\n use std::fs::File;\n use std::io::BufRead;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open_buffered(\"foo.txt\")?;\n     assert!(f.capacity() > 0);\n     for (line, i) in f.lines().zip(1..) {\n         println!(\"{i:6}: {}\", line?);\n     }\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::buffered::bufreader::BufReader": "Constructor"
      }
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String` with at least the specified capacity.\n\n `String`s have an internal buffer to hold their data. The capacity is\n the length of that buffer, and can be queried with the [`capacity`]\n method. This method creates an empty `String`, but one with an initial\n buffer that can hold at least `capacity` bytes. This is useful when you\n may be appending a bunch of data to the `String`, reducing the number of\n reallocations it needs to do.\n\n [`capacity`]: String::capacity\n\n If the given capacity is `0`, no allocation will occur, and this method\n is identical to the [`new`] method.\n\n [`new`]: String::new\n\n # Panics\n\n Panics if the capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::with_capacity(10);\n\n // The String contains no chars, even though it has capacity for more\n assert_eq!(s.len(), 0);\n\n // These are all done without reallocating...\n let cap = s.capacity();\n for _ in 0..10 {\n     s.push('a');\n }\n\n assert_eq!(s.capacity(), cap);\n\n // ...but this may make the string reallocate\n s.push('a');\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Truncates this `String`, removing all contents.\n\n While this means the `String` will have a length of zero, it does not\n touch its capacity.\n\n # Examples\n\n ```\n let mut s = String::from(\"foo\");\n\n s.clear();\n\n assert!(s.is_empty());\n assert_eq!(0, s.len());\n assert_eq!(3, s.capacity());\n ```\n",
      "adt": {}
    },
    "io::BufRead::read_line": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes until a newline (the `0xA` byte) is reached, and append\n them to the provided `String` buffer.\n\n Previous content of the buffer will be preserved. To avoid appending to\n the buffer, you need to [`clear`] it first.\n\n This function will read bytes from the underlying stream until the\n newline delimiter (the `0xA` byte) or EOF is found. Once found, all bytes\n up to, and including, the delimiter (if found) will be appended to\n `buf`.\n\n If successful, this function will return the total number of bytes read.\n\n If this function returns [`Ok(0)`], the stream has reached EOF.\n\n This function is blocking and should be used carefully: it is possible for\n an attacker to continuously send bytes without ever sending a newline\n or EOF. You can use [`take`] to limit the maximum number of bytes read.\n\n [`Ok(0)`]: Ok\n [`clear`]: String::clear\n [`take`]: crate::io::Read::take\n\n # Errors\n\n This function has the same error semantics as [`read_until`] and will\n also return an error if the read bytes are not valid UTF-8. If an I/O\n error is encountered then `buf` may contain some bytes already read in\n the event that all data read so far was valid UTF-8.\n\n [`read_until`]: BufRead::read_until\n\n # Examples\n\n [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n this example, we use [`Cursor`] to read all the lines in a byte slice:\n\n ```\n use std::io::{self, BufRead};\n\n let mut cursor = io::Cursor::new(b\"foo\\nbar\");\n let mut buf = String::new();\n\n // cursor is at 'f'\n let num_bytes = cursor.read_line(&mut buf)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 4);\n assert_eq!(buf, \"foo\\n\");\n buf.clear();\n\n // cursor is at 'b'\n let num_bytes = cursor.read_line(&mut buf)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 3);\n assert_eq!(buf, \"bar\");\n buf.clear();\n\n // cursor is at EOF\n let num_bytes = cursor.read_line(&mut buf)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 0);\n assert_eq!(buf, \"\");\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "alloc_crate::string::String": "MutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::str::<impl str>::trim": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a string slice with leading and trailing whitespace removed.\n\n 'Whitespace' is defined according to the terms of the Unicode Derived\n Core Property `White_Space`, which includes newlines.\n\n # Examples\n\n ```\n let s = \"\\n Hello\\tworld\\t\\n\";\n\n assert_eq!(\"Hello\\tworld\", s.trim());\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::split": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over substrings of this string slice, separated by\n characters matched by a pattern.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n If there are no matches the full string slice is returned as the only\n item in the iterator.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Iterator behavior\n\n The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n allows a reverse search and forward/reverse search yields the same\n elements. This is true for, e.g., [`char`], but not for `&str`.\n\n If the pattern allows a reverse search but its results might differ\n from a forward search, the [`rsplit`] method can be used.\n\n [`rsplit`]: str::rsplit\n\n # Examples\n\n Simple patterns:\n\n ```\n let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n\n let v: Vec<&str> = \"\".split('X').collect();\n assert_eq!(v, [\"\"]);\n\n let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n\n let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n\n let v: Vec<&str> = \"AABBCC\".split(\"DD\").collect();\n assert_eq!(v, [\"AABBCC\"]);\n\n let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n\n let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n ```\n\n If the pattern is a slice of chars, split on each occurrence of any of the characters:\n\n ```\n let v: Vec<&str> = \"2020-11-03 23:59\".split(&['-', ' ', ':', '@'][..]).collect();\n assert_eq!(v, [\"2020\", \"11\", \"03\", \"23\", \"59\"]);\n ```\n\n A more complex pattern, using a closure:\n\n ```\n let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n ```\n\n If a string contains multiple contiguous separators, you will end up\n with empty strings in the output:\n\n ```\n let x = \"||||a||b|c\".to_string();\n let d: Vec<_> = x.split('|').collect();\n\n assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n ```\n\n Contiguous separators are separated by the empty string.\n\n ```\n let x = \"(///)\".to_string();\n let d: Vec<_> = x.split('/').collect();\n\n assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n ```\n\n Separators at the start or end of a string are neighbored\n by empty strings.\n\n ```\n let d: Vec<_> = \"010\".split(\"0\").collect();\n assert_eq!(d, &[\"\", \"1\", \"\"]);\n ```\n\n When the empty string is used as a separator, it separates\n every character in the string, along with the beginning\n and end of the string.\n\n ```\n let f: Vec<_> = \"rust\".split(\"\").collect();\n assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n ```\n\n Contiguous separators can lead to possibly surprising behavior\n when whitespace is used as the separator. This code is correct:\n\n ```\n let x = \"    a  b c\".to_string();\n let d: Vec<_> = x.split(' ').collect();\n\n assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n ```\n\n It does _not_ give you:\n\n ```,ignore\n assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n ```\n\n Use [`split_whitespace`] for this behavior.\n\n [`split_whitespace`]: str::split_whitespace\n",
      "adt": {}
    },
    "core::iter::Iterator::nth": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `n`th element of the iterator.\n\n Like most indexing operations, the count starts from zero, so `nth(0)`\n returns the first value, `nth(1)` the second, and so on.\n\n Note that all preceding elements, as well as the returned element, will be\n consumed from the iterator. That means that the preceding elements will be\n discarded, and also that calling `nth(0)` multiple times on the same iterator\n will return different elements.\n\n `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(1), Some(2));\n ```\n\n Calling `nth()` multiple times doesn't rewind the iterator:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.nth(1), Some(2));\n assert_eq!(iter.nth(1), None);\n ```\n\n Returning `None` if there are less than `n + 1` elements:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(10), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::DoubleEndedIterator::next_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes and returns an element from the end of the iterator.\n\n Returns `None` when there are no more elements.\n\n The [trait-level] docs contain more details.\n\n [trait-level]: DoubleEndedIterator\n\n # Examples\n\n Basic usage:\n\n ```\n let numbers = vec![1, 2, 3, 4, 5, 6];\n\n let mut iter = numbers.iter();\n\n assert_eq!(Some(&1), iter.next());\n assert_eq!(Some(&6), iter.next_back());\n assert_eq!(Some(&5), iter.next_back());\n assert_eq!(Some(&2), iter.next());\n assert_eq!(Some(&3), iter.next());\n assert_eq!(Some(&4), iter.next());\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next_back());\n ```\n\n # Remarks\n\n The elements yielded by `DoubleEndedIterator`'s methods may differ from\n the ones yielded by [`Iterator`]'s methods:\n\n ```\n let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];\n let uniq_by_fst_comp = || {\n     let mut seen = std::collections::HashSet::new();\n     vec.iter().copied().filter(move |x| seen.insert(x.0))\n };\n\n assert_eq!(uniq_by_fst_comp().last(), Some((2, 'a')));\n assert_eq!(uniq_by_fst_comp().next_back(), Some((2, 'b')));\n\n assert_eq!(\n     uniq_by_fst_comp().fold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(1, 'a'), (2, 'a')]\n );\n assert_eq!(\n     uniq_by_fst_comp().rfold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(2, 'b'), (1, 'c')]\n );\n ```\n",
      "adt": {}
    },
    "core::iter::DoubleEndedIterator::nth_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `n`th element from the end of the iterator.\n\n This is essentially the reversed version of [`Iterator::nth()`].\n Although like most indexing operations, the count starts from zero, so\n `nth_back(0)` returns the first value from the end, `nth_back(1)` the\n second, and so on.\n\n Note that all elements between the end and the returned element will be\n consumed, including the returned element. This also means that calling\n `nth_back(0)` multiple times on the same iterator will return different\n elements.\n\n `nth_back()` will return [`None`] if `n` is greater than or equal to the\n length of the iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().nth_back(2), Some(&1));\n ```\n\n Calling `nth_back()` multiple times doesn't rewind the iterator:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter();\n\n assert_eq!(iter.nth_back(1), Some(&2));\n assert_eq!(iter.nth_back(1), None);\n ```\n\n Returning `None` if there are less than `n + 1` elements:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().nth_back(10), None);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "core::iter::Iterator::any": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests if any element of the iterator matches a predicate.\n\n `any()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then so does `any()`. If they all return `false`, it\n returns `false`.\n\n `any()` is short-circuiting; in other words, it will stop processing\n as soon as it finds a `true`, given that no matter what else happens,\n the result will also be `true`.\n\n An empty iterator returns `false`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert!(a.into_iter().any(|x| x > 0));\n\n assert!(!a.into_iter().any(|x| x > 5));\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert!(iter.any(|x| x != 2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(2));\n ```\n",
      "adt": {}
    },
    "path::Path::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Directly wraps a string slice as a `Path` slice.\n\n This is a cost-free conversion.\n\n # Examples\n\n ```\n use std::path::Path;\n\n Path::new(\"foo.txt\");\n ```\n\n You can create `Path`s from `String`s, or even other `Path`s:\n\n ```\n use std::path::Path;\n\n let string = String::from(\"foo.txt\");\n let from_string = Path::new(&string);\n let from_path = Path::new(&from_string);\n assert_eq!(from_string, from_path);\n ```\n",
      "adt": {}
    },
    "path::Path::strip_prefix": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a path that, when joined onto `base`, yields `self`.\n\n # Errors\n\n If `base` is not a prefix of `self` (i.e., [`starts_with`]\n returns `false`), returns [`Err`].\n\n [`starts_with`]: Path::starts_with\n\n # Examples\n\n ```\n use std::path::{Path, PathBuf};\n\n let path = Path::new(\"/test/haha/foo.txt\");\n\n assert_eq!(path.strip_prefix(\"/\"), Ok(Path::new(\"test/haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test\"), Ok(Path::new(\"haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\n assert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\n\n assert!(path.strip_prefix(\"test\").is_err());\n assert!(path.strip_prefix(\"/te\").is_err());\n assert!(path.strip_prefix(\"/haha\").is_err());\n\n let prefix = PathBuf::from(\"/test/\");\n assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "path::Path": "ImmutableAsArgument"
      }
    },
    "path::Path::starts_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether `base` is a prefix of `self`.\n\n Only considers whole path components to match.\n\n # Examples\n\n ```\n use std::path::Path;\n\n let path = Path::new(\"/etc/passwd\");\n\n assert!(path.starts_with(\"/etc\"));\n assert!(path.starts_with(\"/etc/\"));\n assert!(path.starts_with(\"/etc/passwd\"));\n assert!(path.starts_with(\"/etc/passwd/\")); // extra slash is okay\n assert!(path.starts_with(\"/etc/passwd///\")); // multiple extra slashes are okay\n\n assert!(!path.starts_with(\"/e\"));\n assert!(!path.starts_with(\"/etc/passwd.txt\"));\n\n assert!(!Path::new(\"/etc/foo.rs\").starts_with(\"/etc/foo\"));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "alloc_crate::borrow::ToOwned::to_owned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates owned data from borrowed data, usually by cloning.\n\n # Examples\n\n Basic usage:\n\n ```\n let s: &str = \"a\";\n let ss: String = s.to_owned();\n\n let v: &[i32] = &[1, 2];\n let vv: Vec<i32> = v.to_owned();\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3769, kind: RigidTy(Adt(AdtDef(DefId { id: 5999, name: \"io::buffered::bufreader::BufReader\" }), GenericArgs([Type(Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2754, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2756, kind: RigidTy(Adt(AdtDef(DefId { id: 5564, name: \"path::Path\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "io::buffered::bufreader::BufReader": [
      "Plain",
      "MutRef"
    ],
    "alloc_crate::string::String": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::str::Split": [
      "Plain",
      "MutRef"
    ],
    "path::Path": [
      "Ref"
    ],
    "alloc_crate::borrow::Cow": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::thread::unix::cgroups::find_mountpoint"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:817:5: 853:6",
  "src": "fn find_mountpoint(group_path: &Path) -> Option<(Cow<'static, str>, &Path)> {\n        let mut reader = File::open_buffered(\"/proc/self/mountinfo\").ok()?;\n        let mut line = String::with_capacity(256);\n        loop {\n            line.clear();\n            if reader.read_line(&mut line).ok()? == 0 {\n                break;\n            }\n\n            let line = line.trim();\n            let mut items = line.split(' ');\n\n            let sub_path = items.nth(3)?;\n            let mount_point = items.next()?;\n            let mount_opts = items.next_back()?;\n            let filesystem_type = items.nth_back(1)?;\n\n            if filesystem_type != \"cgroup\" || !mount_opts.split(',').any(|opt| opt == \"cpu\") {\n                // not a cgroup / not a cpu-controller\n                continue;\n            }\n\n            let sub_path = Path::new(sub_path).strip_prefix(\"/\").ok()?;\n\n            if !group_path.starts_with(sub_path) {\n                // this is a bind-mount and the bound subdirectory\n                // does not contain the cgroup this process belongs to\n                continue;\n            }\n\n            let trimmed_group_path = group_path.strip_prefix(sub_path).ok()?;\n\n            return Some((Cow::Owned(mount_point.to_owned()), trimmed_group_path));\n        }\n\n        None\n    }",
  "mir": "fn sys::thread::unix::cgroups::find_mountpoint(_1: &path::Path) -> core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> {\n    let mut _0: core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)>;\n    let mut _2: io::buffered::bufreader::BufReader<fs::File>;\n    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, io::buffered::bufreader::BufReader<fs::File>>;\n    let mut _4: core::option::Option<io::buffered::bufreader::BufReader<fs::File>>;\n    let mut _5: core::result::Result<io::buffered::bufreader::BufReader<fs::File>, io::error::Error>;\n    let mut _6: isize;\n    let  _7: io::buffered::bufreader::BufReader<fs::File>;\n    let mut _8: alloc_crate::string::String;\n    let  _9: ();\n    let mut _10: &mut alloc_crate::string::String;\n    let mut _11: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;\n    let mut _12: core::option::Option<usize>;\n    let mut _13: core::result::Result<usize, io::error::Error>;\n    let mut _14: &mut io::buffered::bufreader::BufReader<fs::File>;\n    let mut _15: &mut alloc_crate::string::String;\n    let mut _16: isize;\n    let  _17: usize;\n    let  _18: &str;\n    let  _19: &str;\n    let mut _20: &alloc_crate::string::String;\n    let mut _21: core::str::Split<'_, char>;\n    let mut _22: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &str>;\n    let mut _23: core::option::Option<&str>;\n    let mut _24: &mut core::str::Split<'_, char>;\n    let mut _25: isize;\n    let  _26: &str;\n    let mut _27: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &str>;\n    let mut _28: core::option::Option<&str>;\n    let mut _29: &mut core::str::Split<'_, char>;\n    let mut _30: isize;\n    let  _31: &str;\n    let mut _32: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &str>;\n    let mut _33: core::option::Option<&str>;\n    let mut _34: &mut core::str::Split<'_, char>;\n    let mut _35: isize;\n    let  _36: &str;\n    let  _37: &str;\n    let mut _38: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &str>;\n    let mut _39: core::option::Option<&str>;\n    let mut _40: &mut core::str::Split<'_, char>;\n    let mut _41: isize;\n    let  _42: &str;\n    let mut _43: bool;\n    let mut _44: &&str;\n    let mut _45: &&str;\n    let mut _46: bool;\n    let mut _47: &mut core::str::Split<'_, char>;\n    let mut _48: core::str::Split<'_, char>;\n    let mut _49: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &path::Path>;\n    let mut _50: core::option::Option<&path::Path>;\n    let mut _51: core::result::Result<&path::Path, path::StripPrefixError>;\n    let  _52: &path::Path;\n    let mut _53: isize;\n    let  _54: &path::Path;\n    let mut _55: bool;\n    let mut _56: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &path::Path>;\n    let mut _57: core::option::Option<&path::Path>;\n    let mut _58: core::result::Result<&path::Path, path::StripPrefixError>;\n    let mut _59: isize;\n    let  _60: &path::Path;\n    let mut _61: (alloc_crate::borrow::Cow<'_, str>, &path::Path);\n    let mut _62: alloc_crate::borrow::Cow<'_, str>;\n    let mut _63: alloc_crate::string::String;\n    debug group_path => _1;\n    debug reader => _2;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _7;\n    debug line => _8;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _17;\n    debug line => _18;\n    debug items => _21;\n    debug sub_path => _26;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _26;\n    debug mount_point => _31;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _31;\n    debug mount_opts => _36;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _36;\n    debug filesystem_type => _37;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _42;\n    debug sub_path => _54;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _54;\n    debug trimmed_group_path => _60;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _60;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = fs::File::open_buffered::<&str>(\"/proc/self/mountinfo\") -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = core::result::Result::<io::buffered::bufreader::BufReader<fs::File>, io::error::Error>::ok(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = <core::option::Option<io::buffered::bufreader::BufReader<fs::File>> as core::ops::Try>::branch(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        StorageLive(_7);\n        _7 = move ((_3 as variant#0).0: io::buffered::bufreader::BufReader<fs::File>);\n        _2 = move _7;\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageLive(_8);\n        _8 = alloc_crate::string::String::with_capacity(256_usize) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_3);\n        goto -> bb77;\n    }\n    bb8: {\n        StorageLive(_10);\n        _10 = &mut _8;\n        _9 = alloc_crate::string::String::clear(move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &mut _2;\n        _15 = &mut _8;\n        _13 = <io::buffered::bufreader::BufReader<fs::File> as io::BufRead>::read_line(move _14, _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        _12 = core::result::Result::<usize, io::error::Error>::ok(move _13) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        _11 = <core::option::Option<usize> as core::ops::Try>::branch(move _12) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_12);\n        _16 = discriminant(_11);\n        switchInt(move _16) -> [0: bb13, 1: bb14, otherwise: bb4];\n    }\n    bb13: {\n        _17 = ((_11 as variant#0).0: usize);\n        switchInt(_17) -> [0: bb16, otherwise: bb17];\n    }\n    bb14: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_11);\n        goto -> bb75;\n    }\n    bb16: {\n        StorageDead(_11);\n        _0 = core::option::Option::None;\n        drop(_8) -> [return: bb67, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_11);\n        StorageLive(_20);\n        _20 = &_8;\n        _19 = <alloc_crate::string::String as core::ops::Deref>::deref(move _20) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_20);\n        _18 = core::str::<impl str>::trim(_19) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageLive(_21);\n        _21 = core::str::<impl str>::split::<char>(_18, ' ') -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &mut _21;\n        _23 = <core::str::Split<'_, char> as core::iter::Iterator>::nth(move _24, 3_usize) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_24);\n        _22 = <core::option::Option<&str> as core::ops::Try>::branch(move _23) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_23);\n        _25 = discriminant(_22);\n        switchInt(move _25) -> [0: bb23, 1: bb24, otherwise: bb4];\n    }\n    bb23: {\n        _26 = ((_22 as variant#0).0: &str);\n        StorageDead(_22);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &mut _21;\n        _28 = <core::str::Split<'_, char> as core::iter::Iterator>::next(move _29) -> [return: bb26, unwind unreachable];\n    }\n    bb24: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_22);\n        goto -> bb74;\n    }\n    bb26: {\n        StorageDead(_29);\n        _27 = <core::option::Option<&str> as core::ops::Try>::branch(move _28) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_28);\n        _30 = discriminant(_27);\n        switchInt(move _30) -> [0: bb28, 1: bb29, otherwise: bb4];\n    }\n    bb28: {\n        _31 = ((_27 as variant#0).0: &str);\n        StorageDead(_27);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut _21;\n        _33 = <core::str::Split<'_, char> as core::iter::DoubleEndedIterator>::next_back(move _34) -> [return: bb31, unwind unreachable];\n    }\n    bb29: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_27);\n        goto -> bb73;\n    }\n    bb31: {\n        StorageDead(_34);\n        _32 = <core::option::Option<&str> as core::ops::Try>::branch(move _33) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_33);\n        _35 = discriminant(_32);\n        switchInt(move _35) -> [0: bb33, 1: bb34, otherwise: bb4];\n    }\n    bb33: {\n        _36 = ((_32 as variant#0).0: &str);\n        StorageDead(_32);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &mut _21;\n        _39 = <core::str::Split<'_, char> as core::iter::DoubleEndedIterator>::nth_back(move _40, 1_usize) -> [return: bb36, unwind unreachable];\n    }\n    bb34: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_32);\n        goto -> bb72;\n    }\n    bb36: {\n        StorageDead(_40);\n        _38 = <core::option::Option<&str> as core::ops::Try>::branch(move _39) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_39);\n        _41 = discriminant(_38);\n        switchInt(move _41) -> [0: bb38, 1: bb39, otherwise: bb4];\n    }\n    bb38: {\n        StorageLive(_42);\n        _42 = ((_38 as variant#0).0: &str);\n        _37 = _42;\n        StorageDead(_42);\n        StorageDead(_38);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &_37;\n        StorageLive(_45);\n        _45 = sys::thread::unix::cgroups::find_mountpoint::promoted[0];\n        _43 = <&str as core::cmp::PartialEq>::ne(move _44, move _45) -> [return: bb41, unwind unreachable];\n    }\n    bb39: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_38);\n        goto -> bb71;\n    }\n    bb41: {\n        switchInt(move _43) -> [0: bb43, otherwise: bb42];\n    }\n    bb42: {\n        StorageDead(_45);\n        StorageDead(_44);\n        goto -> bb65;\n    }\n    bb43: {\n        StorageDead(_45);\n        StorageDead(_44);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = core::str::<impl str>::split::<char>(_36, ',') -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _47 = &mut _48;\n        _46 = <core::str::Split<'_, char> as core::iter::Iterator>::any::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:834:74: 834:79}>(move _47, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:834:74: 834:79}) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        switchInt(move _46) -> [0: bb47, otherwise: bb46];\n    }\n    bb46: {\n        StorageDead(_47);\n        StorageDead(_48);\n        StorageDead(_46);\n        StorageDead(_43);\n        StorageLive(_49);\n        StorageLive(_50);\n        StorageLive(_51);\n        _52 = path::Path::new::<str>(_26) -> [return: bb48, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_47);\n        StorageDead(_48);\n        goto -> bb65;\n    }\n    bb48: {\n        _51 = path::Path::strip_prefix::<&str>(_52, \"/\") -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _50 = core::result::Result::<&path::Path, path::StripPrefixError>::ok(move _51) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_51);\n        _49 = <core::option::Option<&path::Path> as core::ops::Try>::branch(move _50) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_50);\n        _53 = discriminant(_49);\n        switchInt(move _53) -> [0: bb52, 1: bb53, otherwise: bb4];\n    }\n    bb52: {\n        _54 = ((_49 as variant#0).0: &path::Path);\n        StorageDead(_49);\n        StorageLive(_55);\n        _55 = path::Path::starts_with::<&path::Path>(_1, _54) -> [return: bb55, unwind unreachable];\n    }\n    bb53: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_49);\n        goto -> bb70;\n    }\n    bb55: {\n        switchInt(move _55) -> [0: bb57, otherwise: bb56];\n    }\n    bb56: {\n        StorageDead(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = path::Path::strip_prefix::<&path::Path>(_1, _54) -> [return: bb58, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_55);\n        goto -> bb66;\n    }\n    bb58: {\n        _57 = core::result::Result::<&path::Path, path::StripPrefixError>::ok(move _58) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_58);\n        _56 = <core::option::Option<&path::Path> as core::ops::Try>::branch(move _57) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_57);\n        _59 = discriminant(_56);\n        switchInt(move _59) -> [0: bb61, 1: bb62, otherwise: bb4];\n    }\n    bb61: {\n        _60 = ((_56 as variant#0).0: &path::Path);\n        StorageDead(_56);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = <str as alloc_crate::borrow::ToOwned>::to_owned(_31) -> [return: bb64, unwind unreachable];\n    }\n    bb62: {\n        _0 = <core::option::Option<(alloc_crate::borrow::Cow<'_, str>, &path::Path)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_56);\n        goto -> bb69;\n    }\n    bb64: {\n        _62 = alloc_crate::borrow::Cow::Owned(move _63);\n        StorageDead(_63);\n        _61 = (move _62, _60);\n        StorageDead(_62);\n        _0 = core::option::Option::Some(move _61);\n        StorageDead(_61);\n        goto -> bb69;\n    }\n    bb65: {\n        StorageDead(_46);\n        StorageDead(_43);\n        goto -> bb66;\n    }\n    bb66: {\n        StorageDead(_37);\n        StorageDead(_21);\n        goto -> bb8;\n    }\n    bb67: {\n        StorageDead(_8);\n        drop(_2) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_2);\n        goto -> bb78;\n    }\n    bb69: {\n        goto -> bb70;\n    }\n    bb70: {\n        goto -> bb71;\n    }\n    bb71: {\n        StorageDead(_37);\n        goto -> bb72;\n    }\n    bb72: {\n        goto -> bb73;\n    }\n    bb73: {\n        goto -> bb74;\n    }\n    bb74: {\n        StorageDead(_21);\n        goto -> bb75;\n    }\n    bb75: {\n        drop(_8) -> [return: bb76, unwind unreachable];\n    }\n    bb76: {\n        StorageDead(_8);\n        drop(_2) -> [return: bb77, unwind unreachable];\n    }\n    bb77: {\n        StorageDead(_2);\n        goto -> bb78;\n    }\n    bb78: {\n        return;\n    }\n}\n",
  "doc": " Scan mountinfo for cgroup v1 mountpoint with a cpu controller\n\n If the cgroupfs is a bind mount then `group_path` is adjusted to skip\n over the already-included prefix\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}