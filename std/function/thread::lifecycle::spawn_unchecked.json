{
  "name": "thread::lifecycle::spawn_unchecked",
  "safe": false,
  "callees": {
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    },
    "thread::id::ThreadId::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "thread::id::ThreadId": "Constructor"
      }
    },
    "thread::thread::Thread::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "thread::thread::Thread": "Constructor"
      }
    },
    "core::default::Default::default": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the \"default value\" for a type.\n\n Default values are often some kind of initial value, identity value, or anything else that\n may make sense as a default.\n\n # Examples\n\n Using built-in default values:\n\n ```\n let i: i8 = Default::default();\n let (x, y): (Option<String>, f64) = Default::default();\n let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();\n ```\n\n Making your own:\n\n ```\n # #[allow(dead_code)]\n enum Kind {\n     A,\n     B,\n     C,\n }\n\n impl Default for Kind {\n     fn default() -> Self { Kind::A }\n }\n ```\n",
      "adt": {}
    },
    "thread::spawnhook::run_spawn_hooks": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Runs all the spawn hooks.\n\n Called on the parent thread.\n\n Returns the functions to be called on the newly spawned thread.\n",
      "adt": {
        "thread::thread::Thread": "ImmutableAsArgument",
        "thread::spawnhook::ChildSpawnHooks": "Constructor"
      }
    },
    "core::cell::UnsafeCell::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new instance of `UnsafeCell` which will wrap the specified\n value.\n\n All access to the inner value through `&UnsafeCell<T>` requires `unsafe` code.\n\n # Examples\n\n ```\n use std::cell::UnsafeCell;\n\n let uc = UnsafeCell::new(5);\n ```\n",
      "adt": {}
    },
    "alloc_crate::sync::Arc::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Arc<T>`.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "thread::lifecycle::spawn_unchecked::MaybeDangling::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "thread::lifecycle::spawn_unchecked::MaybeDangling": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "thread::scoped::ScopeData::increment_num_running_threads": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "thread::scoped::ScopeData": "ImmutableAsArgument"
      }
    },
    "alloc_crate::boxed::Box::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates memory on the heap and then places `x` into it.\n\n This doesn't actually allocate if `T` is zero-sized.\n\n # Examples\n\n ```\n let five = Box::new(5);\n ```\n",
      "adt": {}
    },
    "alloc_crate::boxed::Box::<T>::into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the `Box`, returning a wrapped raw pointer.\n\n The pointer will be properly aligned and non-null.\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Box`. In particular, the\n caller should properly destroy `T` and release the memory, taking\n into account the [memory layout] used by `Box`. The easiest way to\n do this is to convert the raw pointer back into a `Box` with the\n [`Box::from_raw`] function, allowing the `Box` destructor to perform\n the cleanup.\n\n Note: this is an associated function, which means that you have\n to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n is so that there is no conflict with a method on the inner type.\n\n # Examples\n Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n for automatic cleanup:\n ```\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n let x = unsafe { Box::from_raw(ptr) };\n ```\n Manual cleanup by explicitly running the destructor and deallocating\n the memory:\n ```\n use std::alloc::{dealloc, Layout};\n use std::ptr;\n\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n unsafe {\n     ptr::drop_in_place(ptr);\n     dealloc(ptr as *mut u8, Layout::new::<String>());\n }\n ```\n Note: This is equivalent to the following:\n ```\n let x = Box::new(String::from(\"Hello\"));\n let ptr = Box::into_raw(x);\n unsafe {\n     drop(Box::from_raw(ptr));\n }\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {}
    },
    "alloc_crate::boxed::Box::<T>::from_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a box from a raw pointer.\n\n After calling this function, the raw pointer is owned by the\n resulting `Box`. Specifically, the `Box` destructor will call\n the destructor of `T` and free the allocated memory. For this\n to be safe, the memory must have been allocated in accordance\n with the [memory layout] used by `Box` .\n\n # Safety\n\n This function is unsafe because improper use may lead to\n memory problems. For example, a double-free may occur if the\n function is called twice on the same raw pointer.\n\n The raw pointer must point to a block of memory allocated by the global allocator.\n\n The safety conditions are described in the [memory layout] section.\n\n # Examples\n\n Recreate a `Box` which was previously converted to a raw pointer\n using [`Box::into_raw`]:\n ```\n let x = Box::new(5);\n let ptr = Box::into_raw(x);\n let x = unsafe { Box::from_raw(ptr) };\n ```\n Manually create a `Box` from scratch by using the global allocator:\n ```\n use std::alloc::{alloc, Layout};\n\n unsafe {\n     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n     // In general .write is required to avoid attempting to destruct\n     // the (uninitialized) previous contents of `ptr`, though for this\n     // simple example `*ptr = 5` would have worked as well.\n     ptr.write(5);\n     let x = Box::from_raw(ptr);\n }\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {}
    },
    "sys::thread::unix::Thread::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "sys::thread::unix::Thread": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 506, kind: RigidTy(Adt(AdtDef(DefId { id: 4653, name: \"alloc_crate::sync::Arc\" }), GenericArgs([Type(Ty { id: 738, kind: RigidTy(Adt(AdtDef(DefId { id: 4670, name: \"thread::scoped::ScopeData\" }), GenericArgs([]))) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])"
    ],
    "thread::id::ThreadId": [
      "Plain"
    ],
    "thread::thread::Thread": [
      "Plain",
      "Ref"
    ],
    "thread::spawnhook::ChildSpawnHooks": [
      "Plain"
    ],
    "core::cell::UnsafeCell": [
      "Plain"
    ],
    "thread::lifecycle::Packet": [
      "Plain",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "alloc_crate::sync::Arc": [
      "Plain",
      "Ref"
    ],
    "thread::lifecycle::spawn_unchecked::MaybeDangling": [
      "Plain"
    ],
    "thread::scoped::ScopeData": [
      "Ref"
    ],
    "alloc_crate::boxed::Box": [
      "Plain"
    ],
    "thread::lifecycle::ThreadInit": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 680, kind: RigidTy(Adt(AdtDef(DefId { id: 4638, name: \"sys::thread::unix::Thread\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "sys::thread::unix::Thread": [
      "Plain"
    ],
    "thread::lifecycle::JoinInner": [
      "Plain"
    ]
  },
  "path": 4497,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:18:1: 137:2",
  "src": "pub(super) unsafe fn spawn_unchecked<'scope, F, T>(\n    name: Option<String>,\n    stack_size: Option<usize>,\n    no_hooks: bool,\n    scope_data: Option<Arc<ScopeData>>,\n    f: F,\n) -> io::Result<JoinInner<'scope, T>>\nwhere\n    F: FnOnce() -> T,\n    F: Send,\n    T: Send,\n{\n    let stack_size = stack_size.unwrap_or_else(|| {\n        static MIN: Atomic<usize> = AtomicUsize::new(0);\n\n        match MIN.load(Ordering::Relaxed) {\n            0 => {}\n            n => return n - 1,\n        }\n\n        let amt = env::var_os(\"RUST_MIN_STACK\")\n            .and_then(|s| s.to_str().and_then(|s| s.parse().ok()))\n            .unwrap_or(imp::DEFAULT_MIN_STACK_SIZE);\n\n        // 0 is our sentinel value, so ensure that we'll never see 0 after\n        // initialization has run\n        MIN.store(amt + 1, Ordering::Relaxed);\n        amt\n    });\n\n    let id = ThreadId::new();\n    let thread = Thread::new(id, name);\n\n    let hooks = if no_hooks {\n        spawnhook::ChildSpawnHooks::default()\n    } else {\n        spawnhook::run_spawn_hooks(&thread)\n    };\n\n    let my_packet: Arc<Packet<'scope, T>> =\n        Arc::new(Packet { scope: scope_data, result: UnsafeCell::new(None), _marker: PhantomData });\n    let their_packet = my_packet.clone();\n\n    // Pass `f` in `MaybeUninit` because actually that closure might *run longer than the lifetime of `F`*.\n    // See <https://github.com/rust-lang/rust/issues/101983> for more details.\n    // To prevent leaks we use a wrapper that drops its contents.\n    #[repr(transparent)]\n    struct MaybeDangling<T>(MaybeUninit<T>);\n    impl<T> MaybeDangling<T> {\n        fn new(x: T) -> Self {\n            MaybeDangling(MaybeUninit::new(x))\n        }\n        fn into_inner(self) -> T {\n            // Make sure we don't drop.\n            let this = ManuallyDrop::new(self);\n            // SAFETY: we are always initialized.\n            unsafe { this.0.assume_init_read() }\n        }\n    }\n    impl<T> Drop for MaybeDangling<T> {\n        fn drop(&mut self) {\n            // SAFETY: we are always initialized.\n            unsafe { self.0.assume_init_drop() };\n        }\n    }\n\n    let f = MaybeDangling::new(f);\n\n    // The entrypoint of the Rust thread, after platform-specific thread\n    // initialization is done.\n    let rust_start = move || {\n        let f = f.into_inner();\n        let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n            crate::sys::backtrace::__rust_begin_short_backtrace(|| hooks.run());\n            crate::sys::backtrace::__rust_begin_short_backtrace(f)\n        }));\n        // SAFETY: `their_packet` as been built just above and moved by the\n        // closure (it is an Arc<...>) and `my_packet` will be stored in the\n        // same `JoinInner` as this closure meaning the mutation will be\n        // safe (not modify it and affect a value far away).\n        unsafe { *their_packet.result.get() = Some(try_result) };\n        // Here `their_packet` gets dropped, and if this is the last `Arc` for that packet that\n        // will call `decrement_num_running_threads` and therefore signal that this thread is\n        // done.\n        drop(their_packet);\n        // Here, the lifetime `'scope` can end. `main` keeps running for a bit\n        // after that before returning itself.\n    };\n\n    if let Some(scope_data) = &my_packet.scope {\n        scope_data.increment_num_running_threads();\n    }\n\n    // SAFETY: dynamic size and alignment of the Box remain the same. See below for why the\n    // lifetime change is justified.\n    let rust_start = unsafe {\n        Box::from_raw(Box::into_raw(Box::new(rust_start)) as *mut (dyn FnOnce() + Send + 'static))\n    };\n\n    let init = Box::new(ThreadInit { handle: thread.clone(), rust_start });\n\n    Ok(JoinInner {\n        // SAFETY:\n        //\n        // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n        // through FFI or otherwise used with low-level threading primitives that have no\n        // notion of or way to enforce lifetimes.\n        //\n        // As mentioned in the `Safety` section of this function's documentation, the caller of\n        // this function needs to guarantee that the passed-in lifetime is sufficiently long\n        // for the lifetime of the thread.\n        //\n        // Similarly, the `sys` implementation must guarantee that no references to the closure\n        // exist after the thread has terminated, which is signaled by `Thread::join`\n        // returning.\n        native: unsafe { imp::Thread::new(stack_size, init)? },\n        thread,\n        packet: my_packet,\n    })\n}",
  "mir": "fn thread::lifecycle::spawn_unchecked(_1: core::option::Option<alloc_crate::string::String>, _2: core::option::Option<usize>, _3: bool, _4: core::option::Option<alloc_crate::sync::Arc<thread::scoped::ScopeData>>, _5: F) -> core::result::Result<thread::lifecycle::JoinInner<'_, T>, io::error::Error> {\n    let mut _0: core::result::Result<thread::lifecycle::JoinInner<'_, T>, io::error::Error>;\n    let  _6: usize;\n    let  _7: thread::id::ThreadId;\n    let  _8: thread::thread::Thread;\n    let  _9: thread::spawnhook::ChildSpawnHooks;\n    let  _10: &thread::thread::Thread;\n    let  _11: alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>>;\n    let mut _12: thread::lifecycle::Packet<'_, T>;\n    let mut _13: core::cell::UnsafeCell<core::option::Option<core::result::Result<T, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>>>;\n    let mut _14: core::option::Option<core::result::Result<T, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>>;\n    let  _15: alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>>;\n    let mut _16: &alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>>;\n    let  _17: thread::lifecycle::spawn_unchecked::MaybeDangling<F>;\n    let  _18: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:88:22: 88:29};\n    let mut _19: &core::option::Option<alloc_crate::sync::Arc<thread::scoped::ScopeData>>;\n    let  _20: &thread::lifecycle::Packet<'_, T>;\n    let mut _21: &alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>>;\n    let mut _22: isize;\n    let  _23: &alloc_crate::sync::Arc<thread::scoped::ScopeData>;\n    let  _24: ();\n    let  _25: &thread::scoped::ScopeData;\n    let mut _26: alloc_crate::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>;\n    let mut _27: *mut dyn core::ops::FnOnce() + core::marker::Send;\n    let mut _28: *mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:88:22: 88:29};\n    let mut _29: alloc_crate::boxed::Box<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:88:22: 88:29}>;\n    let  _30: alloc_crate::boxed::Box<thread::lifecycle::ThreadInit>;\n    let mut _31: thread::lifecycle::ThreadInit;\n    let mut _32: thread::thread::Thread;\n    let mut _33: &thread::thread::Thread;\n    let mut _34: thread::lifecycle::JoinInner<'_, T>;\n    let mut _35: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, sys::thread::unix::Thread>;\n    let mut _36: core::result::Result<sys::thread::unix::Thread, io::error::Error>;\n    let mut _37: isize;\n    let  _38: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _39: sys::thread::unix::Thread;\n    let mut _40: thread::thread::Thread;\n    let mut _41: alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>>;\n    debug name => _1;\n    debug stack_size => _2;\n    debug no_hooks => _3;\n    debug scope_data => _4;\n    debug f => _5;\n    debug stack_size => _6;\n    debug id => _7;\n    debug thread => _8;\n    debug hooks => _9;\n    debug my_packet => _11;\n    debug their_packet => _15;\n    debug f => _17;\n    debug rust_start => _18;\n    debug scope_data => _23;\n    debug rust_start => _26;\n    debug init => _30;\n    debug residual => _38;\n    debug val => _39;\n    bb0: {\n        _6 = core::option::Option::<usize>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:30:48: 30:50}>(_2, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:30:48: 30:50}) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = thread::id::ThreadId::new() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_8);\n        _8 = thread::thread::Thread::new(_7, _1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_9);\n        switchInt(_3) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        _9 = <thread::spawnhook::ChildSpawnHooks as core::default::Default>::default() -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _10 = &_8;\n        _9 = thread::spawnhook::run_spawn_hooks(_10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = core::option::Option::None;\n        _13 = core::cell::UnsafeCell::<core::option::Option<core::result::Result<T, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>>>::new(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        _12 = Packet(_4, move _13, core::marker::PhantomData::<core::option::Option<&thread::scoped::ScopeData>>);\n        StorageDead(_13);\n        _11 = alloc_crate::sync::Arc::<thread::lifecycle::Packet<'_, T>>::new(move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_11;\n        _15 = <alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>> as core::clone::Clone>::clone(move _16) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        StorageLive(_17);\n        _17 = thread::lifecycle::spawn_unchecked::MaybeDangling::<F>::new(_5) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _18 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:88:22: 88:29}(move _17, move _9, move _15);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_11;\n        _20 = <alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>> as core::ops::Deref>::deref(move _21) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_21);\n        _19 = &((*_20).0: core::option::Option<alloc_crate::sync::Arc<thread::scoped::ScopeData>>);\n        _22 = discriminant((*_19));\n        switchInt(move _22) -> [1: bb13, 0: bb16, otherwise: bb25];\n    }\n    bb13: {\n        _23 = &(((*_19) as variant#1).0: alloc_crate::sync::Arc<thread::scoped::ScopeData>);\n        _25 = <alloc_crate::sync::Arc<thread::scoped::ScopeData> as core::ops::Deref>::deref(_23) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _24 = thread::scoped::ScopeData::increment_num_running_threads(_25) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = alloc_crate::boxed::Box::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:88:22: 88:29}>::new(_18) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _28 = alloc_crate::boxed::Box::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:88:22: 88:29}>::into_raw(move _29) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _27 = move _28 as *mut dyn core::ops::FnOnce() + core::marker::Send;\n        StorageDead(_29);\n        StorageDead(_28);\n        _26 = alloc_crate::boxed::Box::<dyn core::ops::FnOnce() + core::marker::Send>::from_raw(_27) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_8;\n        _32 = <thread::thread::Thread as core::clone::Clone>::clone(move _33) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_33);\n        _31 = ThreadInit(move _32, _26);\n        StorageDead(_32);\n        _30 = alloc_crate::boxed::Box::<thread::lifecycle::ThreadInit>::new(move _31) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_31);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = sys::thread::unix::Thread::new(_6, _30) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _35 = <core::result::Result<sys::thread::unix::Thread, io::error::Error> as core::ops::Try>::branch(move _36) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_36);\n        _37 = discriminant(_35);\n        switchInt(move _37) -> [0: bb26, 1: bb27, otherwise: bb25];\n    }\n    bb25: {\n        unreachable;\n    }\n    bb26: {\n        _39 = move ((_35 as variant#0).0: sys::thread::unix::Thread);\n        StorageDead(_35);\n        StorageLive(_40);\n        _40 = move _8;\n        StorageLive(_41);\n        _41 = move _11;\n        _34 = JoinInner(_39, move _40, move _41);\n        StorageDead(_41);\n        StorageDead(_40);\n        _0 = core::result::Result::Ok(move _34);\n        StorageDead(_34);\n        StorageDead(_17);\n        StorageDead(_15);\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb31;\n    }\n    bb27: {\n        _38 = move ((_35 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<thread::lifecycle::JoinInner<'_, T>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_38) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_17);\n        StorageDead(_15);\n        drop(_11) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_11);\n        StorageDead(_9);\n        drop(_8) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_8);\n        goto -> bb31;\n    }\n    bb31: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}