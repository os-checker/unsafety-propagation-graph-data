{
  "name": "panic::resume_unwind",
  "safe": true,
  "callees": {
    "panicking::resume_unwind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This is the entry point for `resume_unwind`.\n It just forwards the payload to the panic runtime.\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::boxed::Box": [
      "Plain"
    ]
  },
  "path": 2270,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:390:1: 392:2",
  "src": "pub fn resume_unwind(payload: Box<dyn Any + Send>) -> ! {\n    panicking::resume_unwind(payload)\n}",
  "mir": "fn panic::resume_unwind(_1: alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>) -> ! {\n    let mut _0: !;\n    debug payload => _1;\n    bb0: {\n        _0 = panicking::resume_unwind(_1) -> unwind unreachable;\n    }\n}\n",
  "doc": " Triggers a panic without invoking the panic hook.\n\n This is designed to be used in conjunction with [`catch_unwind`] to, for\n example, carry a panic across a layer of C code.\n\n # Notes\n\n Note that panics in Rust are not always implemented via unwinding, but they\n may be implemented by aborting the process. If this function is called when\n panics are implemented this way then this function will abort the process,\n not trigger an unwind.\n\n # Examples\n\n ```should_panic\n use std::panic;\n\n let result = panic::catch_unwind(|| {\n     if 1 != 2 {\n         panic!(\"oh no!\");\n     }\n });\n\n if let Err(err) = result {\n     panic::resume_unwind(err);\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}