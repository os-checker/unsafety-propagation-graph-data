{
  "name": "os::unix::fs::FileExt::write_all_at",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "os::unix::fs::FileExt::write_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a number of bytes starting from a given offset.\n\n Returns the number of bytes written.\n\n The offset is relative to the start of the file and thus independent\n from the current cursor.\n\n The current file cursor is not affected by this function.\n\n When writing beyond the end of the file, the file is appropriately\n extended and the intermediate bytes are initialized with the value 0.\n\n Note that similar to [`File::write`], it is not an error to return a\n short write.\n\n # Bug\n On some systems, `write_at` utilises [`pwrite64`] to write to files.\n However, this syscall has a [bug] where files opened with the `O_APPEND`\n flag fail to respect the offset parameter, always appending to the end\n of the file instead.\n\n It is possible to inadvertently set this flag, like in the example below.\n Therefore, it is important to be vigilant while changing options to mitigate\n unexpected behavior.\n\n ```no_run\n use std::fs::File;\n use std::io;\n use std::os::unix::prelude::FileExt;\n\n fn main() -> io::Result<()> {\n     // Open a file with the append option (sets the `O_APPEND` flag)\n     let file = File::options().append(true).open(\"foo.txt\")?;\n\n     // We attempt to write at offset 10; instead appended to EOF\n     file.write_at(b\"sushi\", 10)?;\n\n     // foo.txt is 5 bytes long instead of 15\n     Ok(())\n }\n ```\n\n [`File::write`]: fs::File::write\n [`pwrite64`]: https://man7.org/linux/man-pages/man2/pwrite.2.html\n [bug]: https://man7.org/linux/man-pages/man2/pwrite.2.html#BUGS\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io;\n use std::os::unix::prelude::FileExt;\n\n fn main() -> io::Result<()> {\n     let file = File::create(\"foo.txt\")?;\n\n     // We now write at the offset 10.\n     file.write_at(b\"sushi\", 10)?;\n     Ok(())\n }\n ```\n",
      "adt": {}
    },
    "io::error::Error::is_interrupted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "io::error::Error": [
      "Ref",
      "Plain"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ]
  },
  "path": "os::unix::fs::FileExt::write_all_at",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/fs.rs:330:5: 345:6",
  "src": "fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n        while !buf.is_empty() {\n            match self.write_at(buf, offset) {\n                Ok(0) => {\n                    return Err(io::Error::WRITE_ALL_EOF);\n                }\n                Ok(n) => {\n                    buf = &buf[n..];\n                    offset += n as u64\n                }\n                Err(ref e) if e.is_interrupted() => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }",
  "mir": "fn os::unix::fs::FileExt::write_all_at(_1: &Self, _2: &[u8], _3: u64) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _4: bool;\n    let mut _5: &[u8];\n    let mut _6: core::result::Result<usize, io::error::Error>;\n    let mut _7: &[u8];\n    let mut _8: u64;\n    let mut _9: isize;\n    let  _10: usize;\n    let  _11: &[u8];\n    let mut _12: &[u8];\n    let mut _13: core::ops::RangeFrom<usize>;\n    let mut _14: u64;\n    let mut _15: (u64, bool);\n    let  _16: &io::error::Error;\n    let  _17: &&io::error::Error;\n    let mut _18: bool;\n    let  _19: io::error::Error;\n    let mut _20: &io::error::Error;\n    let mut _21: bool;\n    let mut _22: isize;\n    debug self => _1;\n    debug buf => _2;\n    debug offset => _3;\n    debug n => _10;\n    debug e => _16;\n    debug e => _17;\n    debug e => _19;\n    bb0: {\n        _21 = false;\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = _2;\n        _4 = core::slice::<impl [u8]>::is_empty(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _4) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = core::result::Result::Ok(());\n        goto -> bb17;\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _2;\n        StorageLive(_8);\n        _8 = _3;\n        _6 = <Self as os::unix::fs::FileExt>::write_at(_1, move _7, move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _21 = true;\n        StorageDead(_8);\n        StorageDead(_7);\n        _9 = discriminant(_6);\n        switchInt(move _9) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        switchInt(((_6 as variant#0).0: usize)) -> [0: bb10, otherwise: bb9];\n    }\n    bb8: {\n        StorageLive(_17);\n        StorageLive(_16);\n        _16 = &((_6 as variant#1).0: io::error::Error);\n        _17 = &_16;\n        StorageLive(_18);\n        _20 = (*_17);\n        _18 = io::error::Error::is_interrupted(_20) -> [return: bb13, unwind unreachable];\n    }\n    bb9: {\n        _10 = ((_6 as variant#0).0: usize);\n        StorageLive(_12);\n        _12 = _2;\n        StorageLive(_13);\n        _13 = RangeFrom(_10);\n        _11 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(move _12, move _13) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        _0 = core::result::Result::Err(io::error::Error::WRITE_ALL_EOF);\n        goto -> bb16;\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _2 = _11;\n        StorageLive(_14);\n        _14 = _10 as u64;\n        _15 = CheckedAdd(_3, _14);\n        assert(!move (_15.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _3, move _14) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _3 = move (_15.0: u64);\n        StorageDead(_14);\n        goto -> bb21;\n    }\n    bb13: {\n        switchInt(move _18) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageDead(_17);\n        goto -> bb21;\n    }\n    bb15: {\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageDead(_17);\n        _21 = false;\n        _19 = move ((_6 as variant#1).0: io::error::Error);\n        _0 = core::result::Result::Err(_19);\n        goto -> bb16;\n    }\n    bb16: {\n        _21 = false;\n        StorageDead(_6);\n        StorageDead(_4);\n        goto -> bb17;\n    }\n    bb17: {\n        return;\n    }\n    bb18: {\n        _21 = false;\n        StorageDead(_6);\n        StorageDead(_4);\n        goto -> bb1;\n    }\n    bb19: {\n        switchInt(_21) -> [0: bb18, otherwise: bb20];\n    }\n    bb20: {\n        drop(((_6 as variant#1).0: io::error::Error)) -> [return: bb18, unwind unreachable];\n    }\n    bb21: {\n        _22 = discriminant(_6);\n        switchInt(move _22) -> [1: bb19, 0: bb18, otherwise: bb6];\n    }\n}\n",
  "doc": " Attempts to write an entire buffer starting from a given offset.\n\n The offset is relative to the start of the file and thus independent\n from the current cursor.\n\n The current file cursor is not affected by this function.\n\n This method will continuously call [`write_at`] until there is no more data\n to be written or an error of non-[`io::ErrorKind::Interrupted`] kind is\n returned. This method will not return until the entire buffer has been\n successfully written or such an error occurs. The first error that is\n not of [`io::ErrorKind::Interrupted`] kind generated from this method will be\n returned.\n\n # Errors\n\n This function will return the first error of\n non-[`io::ErrorKind::Interrupted`] kind that [`write_at`] returns.\n\n [`write_at`]: FileExt::write_at\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io;\n use std::os::unix::prelude::FileExt;\n\n fn main() -> io::Result<()> {\n     let file = File::open(\"foo.txt\")?;\n\n     // We now write at the offset 10.\n     file.write_all_at(b\"sushi\", 10)?;\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}