{
  "name": "<&io::stdio::Stdin as io::Read>::read_exact",
  "safe": true,
  "callees": {
    "io::stdio::Stdin::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Locks this handle to the standard input stream, returning a readable\n guard.\n\n The lock is released when the returned lock goes out of scope. The\n returned guard also implements the [`Read`] and [`BufRead`] traits for\n accessing the underlying data.\n\n # Examples\n\n ```no_run\n use std::io::{self, BufRead};\n\n fn main() -> io::Result<()> {\n     let mut buffer = String::new();\n     let stdin = io::stdin();\n     let mut handle = stdin.lock();\n\n     handle.read_line(&mut buffer)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::stdio::Stdin": "ImmutableAsArgument",
        "io::stdio::StdinLock": "Constructor"
      }
    },
    "io::Read::read_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the exact number of bytes required to fill `buf`.\n\n This function reads as many bytes as necessary to completely fill the\n specified buffer `buf`.\n\n *Implementations* of this method can make no assumptions about the contents of `buf` when\n this function is called. It is recommended that implementations only write data to `buf`\n instead of reading its contents. The documentation on [`read`] has a more detailed\n explanation of this subject.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If this function encounters an \"end of file\" before completely filling\n the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n The contents of `buf` are unspecified in this case.\n\n If any other read error is encountered then this function immediately\n returns. The contents of `buf` are unspecified in this case.\n\n If this function returns an error, it is unspecified how many bytes it\n has read, but it will never read more than would be necessary to\n completely fill the buffer.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read`]: Read::read\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = [0; 10];\n\n     // read exactly 10 bytes\n     f.read_exact(&mut buffer)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "io::stdio::Stdin": [
      "Ref"
    ],
    "io::stdio::StdinLock": [
      "Plain",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<&io::stdio::Stdin as io::Read>::read_exact"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:494:5: 496:6",
  "src": "fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        self.lock().read_exact(buf)\n    }",
  "mir": "fn <&io::stdio::Stdin as io::Read>::read_exact(_1: &mut &io::stdio::Stdin, _2: &mut [u8]) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: &mut io::stdio::StdinLock<'_>;\n    let mut _4: io::stdio::StdinLock<'_>;\n    let mut _5: &io::stdio::Stdin;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = (*_1);\n        _4 = io::stdio::Stdin::lock(_5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &mut _4;\n        _0 = <io::stdio::StdinLock<'_> as io::Read>::read_exact(move _3, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        drop(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}