{
  "name": "sys::os_str::bytes::Buf::leak",
  "safe": true,
  "callees": {
    "alloc_crate::vec::Vec::<T, A>::leak": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes and leaks the `Vec`, returning a mutable reference to the contents,\n `&'a mut [T]`.\n\n Note that the type `T` must outlive the chosen lifetime `'a`. If the type\n has only static references, or none at all, then this may be chosen to be\n `'static`.\n\n As of Rust 1.57, this method does not reallocate or shrink the `Vec`,\n so the leaked allocation may include unused capacity that is not part\n of the returned slice.\n\n This function is mainly useful for data that lives for the remainder of\n the program's life. Dropping the returned reference will cause a memory\n leak.\n\n # Examples\n\n Simple usage:\n\n ```\n let x = vec![1, 2, 3];\n let static_ref: &'static mut [usize] = x.leak();\n static_ref[0] += 1;\n assert_eq!(static_ref, &[2, 2, 3]);\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # drop(unsafe { Box::from_raw(static_ref) });\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Plain"
    ],
    "sys::os_str::bytes::Buf": [
      "Unknown([Field(0, Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Plain"
    ],
    "sys::os_str::bytes::Slice": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::os_str::bytes::Buf::leak"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/os_str/bytes.rs:194:5: 196:6",
  "src": "pub fn leak<'a>(self) -> &'a mut Slice {\n        unsafe { mem::transmute(self.inner.leak()) }\n    }",
  "mir": "fn sys::os_str::bytes::Buf::leak(_1: sys::os_str::bytes::Buf) -> &mut sys::os_str::bytes::Slice {\n    let mut _0: &mut sys::os_str::bytes::Slice;\n    let mut _2: &mut [u8];\n    let mut _3: alloc_crate::vec::Vec<u8>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = move (_1.0: alloc_crate::vec::Vec<u8>);\n        _2 = alloc_crate::vec::Vec::<u8>::leak::<'_>(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = move _2 as &mut sys::os_str::bytes::Slice;\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}