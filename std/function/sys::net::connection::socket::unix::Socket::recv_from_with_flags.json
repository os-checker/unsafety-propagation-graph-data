{
  "name": "sys::net::connection::socket::unix::Socket::recv_from_with_flags",
  "safe": true,
  "callees": {
    "core::mem::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {}
    },
    "core::mem::size_of_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the pointed-to value in bytes.\n\n This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no\n statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n then `size_of_val` can be used to get the dynamically-known size.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n\n # Examples\n\n ```\n assert_eq!(4, size_of_val(&5i32));\n\n let x: [u8; 13] = [0; 13];\n let y: &[u8] = &x;\n assert_eq!(13, size_of_val(y));\n ```\n\n [`size_of::<T>()`]: size_of\n",
      "adt": {}
    },
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "libc::recvfrom": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n Writing to memory that this pointer (non-transitively) points to is undefined behavior\n (except inside an `UnsafeCell<T>`).\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n let x_vec = unsafe { &*x.as_ptr() };\n assert_eq!(x_vec.len(), 3);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &*x.as_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "sys::net::connection::socket::socket_addr_from_c": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the C socket address stored in `storage` to a Rust `SocketAddr`.\n\n # Safety\n * `storage` must contain a valid C socket address whose length is no larger\n   than `len`.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "core::net::SocketAddr": "Constructor"
      }
    }
  },
  "adts": {
    "core::mem::MaybeUninit": [
      "Plain",
      "Ref"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12, kind: RigidTy(Int(Isize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7336, kind: RigidTy(Adt(AdtDef(DefId { id: 7705, name: \"core::net::SocketAddr\" }), GenericArgs([]))) })])"
    ],
    "core::net::SocketAddr": [
      "Plain"
    ]
  },
  "path": 3701,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/net/connection/socket/unix.rs:326:5: 348:6",
  "src": "fn recv_from_with_flags(\n        &self,\n        buf: &mut [u8],\n        flags: c_int,\n    ) -> io::Result<(usize, SocketAddr)> {\n        // The `recvfrom` function will fill in the storage with the address,\n        // so we don't need to zero it here.\n        // reference: https://linux.die.net/man/2/recvfrom\n        let mut storage: mem::MaybeUninit<libc::sockaddr_storage> = mem::MaybeUninit::uninit();\n        let mut addrlen = size_of_val(&storage) as libc::socklen_t;\n\n        let n = cvt(unsafe {\n            libc::recvfrom(\n                self.as_raw_fd(),\n                buf.as_mut_ptr() as *mut c_void,\n                buf.len(),\n                flags,\n                (&raw mut storage) as *mut _,\n                &mut addrlen,\n            )\n        })?;\n        Ok((n as usize, unsafe { socket_addr_from_c(storage.as_ptr(), addrlen as usize)? }))\n    }",
  "mir": "fn sys::net::connection::socket::unix::Socket::recv_from_with_flags(_1: &sys::net::connection::socket::unix::Socket, _2: &mut [u8], _3: i32) -> core::result::Result<(usize, core::net::SocketAddr), io::error::Error> {\n    let mut _0: core::result::Result<(usize, core::net::SocketAddr), io::error::Error>;\n    let mut _4: core::mem::MaybeUninit<libc::sockaddr_storage>;\n    let mut _5: u32;\n    let mut _6: usize;\n    let  _7: &core::mem::MaybeUninit<libc::sockaddr_storage>;\n    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, isize>;\n    let mut _9: core::result::Result<isize, io::error::Error>;\n    let mut _10: isize;\n    let mut _11: i32;\n    let mut _12: *mut libc::c_void;\n    let mut _13: *mut u8;\n    let mut _14: usize;\n    let mut _15: &[u8];\n    let mut _16: *mut libc::sockaddr;\n    let mut _17: *mut core::mem::MaybeUninit<libc::sockaddr_storage>;\n    let mut _18: *mut u32;\n    let mut _19: &mut u32;\n    let mut _20: isize;\n    let  _21: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _22: isize;\n    let mut _23: (usize, core::net::SocketAddr);\n    let mut _24: usize;\n    let mut _25: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, core::net::SocketAddr>;\n    let mut _26: core::result::Result<core::net::SocketAddr, io::error::Error>;\n    let mut _27: *const libc::sockaddr_storage;\n    let mut _28: &core::mem::MaybeUninit<libc::sockaddr_storage>;\n    let mut _29: usize;\n    let mut _30: u32;\n    let mut _31: isize;\n    let  _32: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _33: core::net::SocketAddr;\n    debug self => _1;\n    debug buf => _2;\n    debug flags => _3;\n    debug storage => _4;\n    debug addrlen => _5;\n    debug n => _22;\n    debug residual => _21;\n    debug val => _22;\n    debug residual => _32;\n    debug val => _33;\n    bb0: {\n        StorageLive(_4);\n        _4 = core::mem::MaybeUninit::<libc::sockaddr_storage>::uninit() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _7 = &_4;\n        _6 = core::mem::size_of_val::<core::mem::MaybeUninit<libc::sockaddr_storage>>(_7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = move _6 as u32;\n        StorageDead(_6);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = <sys::net::connection::socket::unix::Socket as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = core::slice::<impl [u8]>::as_mut_ptr(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _12 = move _13 as *mut libc::c_void;\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(*_2);\n        _14 = PtrMetadata(move _15);\n        StorageDead(_15);\n        StorageLive(_17);\n        _17 = &raw mut _4;\n        _16 = move _17 as *mut libc::sockaddr;\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _5;\n        _18 = &raw mut (*_19);\n        _10 = libc::recvfrom(move _11, move _12, move _14, _3, _16, move _18) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = sys::pal::unix::cvt::<isize>(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        _8 = <core::result::Result<isize, io::error::Error> as core::ops::Try>::branch(move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        _20 = discriminant(_8);\n        switchInt(move _20) -> [0: bb9, 1: bb10, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        _22 = ((_8 as variant#0).0: isize);\n        StorageDead(_8);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = _22 as usize;\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = &_4;\n        _27 = core::mem::MaybeUninit::<libc::sockaddr_storage>::as_ptr(move _28) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _21 = move ((_8 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(usize, core::net::SocketAddr), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_21) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_8);\n        goto -> bb18;\n    }\n    bb12: {\n        StorageDead(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = _5;\n        _29 = move _30 as usize;\n        StorageDead(_30);\n        _26 = sys::net::connection::socket::socket_addr_from_c(move _27, move _29) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_29);\n        StorageDead(_27);\n        _25 = <core::result::Result<core::net::SocketAddr, io::error::Error> as core::ops::Try>::branch(move _26) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_26);\n        _31 = discriminant(_25);\n        switchInt(move _31) -> [0: bb15, 1: bb16, otherwise: bb8];\n    }\n    bb15: {\n        _33 = ((_25 as variant#0).0: core::net::SocketAddr);\n        StorageDead(_25);\n        _23 = (move _24, _33);\n        StorageDead(_24);\n        _0 = core::result::Result::Ok(move _23);\n        StorageDead(_23);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb19;\n    }\n    bb16: {\n        _32 = move ((_25 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(usize, core::net::SocketAddr), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_32) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}