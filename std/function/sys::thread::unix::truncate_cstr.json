{
  "name": "sys::thread::unix::truncate_cstr",
  "safe": true,
  "callees": {
    "core::ffi::CStr::to_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this C string to a byte slice.\n\n The returned slice will **not** contain the trailing nul terminator that this C\n string has.\n\n > **Note**: This method is currently implemented as a constant-time\n > cast, but it is planned to alter its definition in the future to\n > perform the length calculation whenever this method is called.\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_bytes(), b\"foo\");\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::ops::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::iter::Iterator::zip": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " 'Zips up' two iterators into a single iterator of pairs.\n\n `zip()` returns a new iterator that will iterate over two other\n iterators, returning a tuple where the first element comes from the\n first iterator, and the second element comes from the second iterator.\n\n In other words, it zips two iterators together, into a single one.\n\n If either iterator returns [`None`], [`next`] from the zipped iterator\n will return [`None`].\n If the zipped iterator has no more elements to return then each further attempt to advance\n it will first try to advance the first iterator at most one time and if it still yielded an item\n try to advance the second iterator at most one time.\n\n To 'undo' the result of zipping up two iterators, see [`unzip`].\n\n [`unzip`]: Iterator::unzip\n\n # Examples\n\n Basic usage:\n\n ```\n let s1 = \"abc\".chars();\n let s2 = \"def\".chars();\n\n let mut iter = s1.zip(s2);\n\n assert_eq!(iter.next(), Some(('a', 'd')));\n assert_eq!(iter.next(), Some(('b', 'e')));\n assert_eq!(iter.next(), Some(('c', 'f')));\n assert_eq!(iter.next(), None);\n ```\n\n Since the argument to `zip()` uses [`IntoIterator`], we can pass\n anything that can be converted into an [`Iterator`], not just an\n [`Iterator`] itself. For example, arrays (`[T]`) implement\n [`IntoIterator`], and so can be passed to `zip()` directly:\n\n ```\n let a1 = [1, 2, 3];\n let a2 = [4, 5, 6];\n\n let mut iter = a1.into_iter().zip(a2);\n\n assert_eq!(iter.next(), Some((1, 4)));\n assert_eq!(iter.next(), Some((2, 5)));\n assert_eq!(iter.next(), Some((3, 6)));\n assert_eq!(iter.next(), None);\n ```\n\n `zip()` is often used to zip an infinite iterator to a finite one.\n This works because the finite iterator will eventually return [`None`],\n ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate`]:\n\n ```\n let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n\n let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n\n assert_eq!((0, 'f'), enumerate[0]);\n assert_eq!((0, 'f'), zipper[0]);\n\n assert_eq!((1, 'o'), enumerate[1]);\n assert_eq!((1, 'o'), zipper[1]);\n\n assert_eq!((2, 'o'), enumerate[2]);\n assert_eq!((2, 'o'), zipper[2]);\n ```\n\n If both iterators have roughly equivalent syntax, it may be more readable to use [`zip`]:\n\n ```\n use std::iter::zip;\n\n let a = [1, 2, 3];\n let b = [2, 3, 4];\n\n let mut zipped = zip(\n     a.into_iter().map(|x| x * 2).skip(1),\n     b.into_iter().map(|x| x * 2).skip(1),\n );\n\n assert_eq!(zipped.next(), Some((4, 6)));\n assert_eq!(zipped.next(), Some((6, 8)));\n assert_eq!(zipped.next(), None);\n ```\n\n compared to:\n\n ```\n # let a = [1, 2, 3];\n # let b = [2, 3, 4];\n #\n let mut zipped = a\n     .into_iter()\n     .map(|x| x * 2)\n     .skip(1)\n     .zip(b.into_iter().map(|x| x * 2).skip(1));\n #\n # assert_eq!(zipped.next(), Some((4, 6)));\n # assert_eq!(zipped.next(), Some((6, 8)));\n # assert_eq!(zipped.next(), None);\n ```\n\n [`enumerate`]: Iterator::enumerate\n [`next`]: Iterator::next\n [`zip`]: crate::iter::zip\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ffi::CStr": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::iter::Zip": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17421, kind: RigidTy(Tuple([Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 4536, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Mut)) }])) }), Field(0, Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17421, kind: RigidTy(Tuple([Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 4536, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Mut)) }])) }), Field(1, Ty { id: 4536, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Mut)) })])"
    ]
  },
  "path": 4354,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:393:1: 399:2",
  "src": "fn truncate_cstr<const MAX_WITH_NUL: usize>(cstr: &CStr) -> [libc::c_char; MAX_WITH_NUL] {\n    let mut result = [0; MAX_WITH_NUL];\n    for (src, dst) in cstr.to_bytes().iter().zip(&mut result[..MAX_WITH_NUL - 1]) {\n        *dst = *src as libc::c_char;\n    }\n    result\n}",
  "mir": "fn sys::thread::unix::truncate_cstr(_1: &core::ffi::CStr) -> [u8; MAX_WITH_NUL] {\n    let mut _0: [u8; MAX_WITH_NUL];\n    let mut _2: [u8; MAX_WITH_NUL];\n    let mut _3: core::iter::Zip<core::slice::Iter<'_, u8>, core::slice::IterMut<'_, u8>>;\n    let mut _4: core::iter::Zip<core::slice::Iter<'_, u8>, core::slice::IterMut<'_, u8>>;\n    let mut _5: core::slice::Iter<'_, u8>;\n    let  _6: &[u8];\n    let mut _7: &mut [u8];\n    let mut _8: &mut [u8; MAX_WITH_NUL];\n    let mut _9: core::ops::RangeTo<usize>;\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let mut _12: core::iter::Zip<core::slice::Iter<'_, u8>, core::slice::IterMut<'_, u8>>;\n    let mut _13: core::option::Option<(&u8, &mut u8)>;\n    let mut _14: &mut core::iter::Zip<core::slice::Iter<'_, u8>, core::slice::IterMut<'_, u8>>;\n    let mut _15: isize;\n    let  _16: &u8;\n    let  _17: &mut u8;\n    let mut _18: u8;\n    debug cstr => _1;\n    debug result => _2;\n    debug iter => _12;\n    debug src => _16;\n    debug dst => _17;\n    bb0: {\n        StorageLive(_2);\n        _2 = [0_u8; MAX_WITH_NUL];\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _6 = core::ffi::CStr::to_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = core::slice::<impl [u8]>::iter(_6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_8);\n        _8 = &mut _2;\n        StorageLive(_9);\n        StorageLive(_10);\n        _11 = CheckedSub(MAX_WITH_NUL, 1_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} - {}`, which would overflow\", MAX_WITH_NUL, 1_usize) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _10 = move (_11.0: usize);\n        _9 = RangeTo(move _10);\n        StorageDead(_10);\n        _7 = <[u8; MAX_WITH_NUL] as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut(move _8, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageDead(_8);\n        _4 = <core::slice::Iter<'_, u8> as core::iter::Iterator>::zip::<&mut [u8]>(move _5, _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        _3 = <core::iter::Zip<core::slice::Iter<'_, u8>, core::slice::IterMut<'_, u8>> as core::iter::IntoIterator>::into_iter(move _4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageLive(_12);\n        _12 = move _3;\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_13);\n        _14 = &mut _12;\n        _13 = <core::iter::Zip<core::slice::Iter<'_, u8>, core::slice::IterMut<'_, u8>> as core::iter::Iterator>::next(_14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _15 = discriminant(_13);\n        switchInt(move _15) -> [0: bb11, 1: bb10, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        StorageLive(_16);\n        _16 = (((_13 as variant#1).0: (&u8, &mut u8)).0: &u8);\n        StorageLive(_17);\n        _17 = move (((_13 as variant#1).0: (&u8, &mut u8)).1: &mut u8);\n        StorageLive(_18);\n        _18 = (*_16);\n        (*_17) = move _18;\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_13);\n        goto -> bb7;\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_3);\n        _0 = _2;\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}