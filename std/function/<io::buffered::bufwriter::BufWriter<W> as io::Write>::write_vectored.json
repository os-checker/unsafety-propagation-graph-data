{
  "name": "<io::buffered::bufwriter::BufWriter<W> as io::Write>::write_vectored",
  "safe": true,
  "callees": {
    "io::buffered::bufwriter::BufWriter::<W>::get_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a reference to the underlying writer.\n\n # Examples\n\n ```no_run\n use std::io::BufWriter;\n use std::net::TcpStream;\n\n let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n\n // we can use reference just like buffer\n let reference = buffer.get_ref();\n ```\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "ImmutableAsArgument"
      }
    },
    "io::Write::is_write_vectored": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if this `Write`r has an efficient [`write_vectored`]\n implementation.\n\n If a `Write`r does not override the default [`write_vectored`]\n implementation, code using it may want to avoid the method all together\n and coalesce writes into a single buffer for higher performance.\n\n The default implementation returns `false`.\n\n [`write_vectored`]: Write::write_vectored\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::num::<impl usize>::saturating_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer addition. Computes `self + rhs`, saturating at\n the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::spare_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "ImmutableAsArgument"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the vector contains no elements.\n\n # Examples\n\n ```\n let mut v = Vec::new();\n assert!(v.is_empty());\n\n v.push(1);\n assert!(!v.is_empty());\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total number of elements the vector can hold without\n reallocating.\n\n # Examples\n\n ```\n let mut vec: Vec<i32> = Vec::with_capacity(10);\n vec.push(42);\n assert!(vec.capacity() >= 10);\n ```\n\n A vector with zero-sized elements will always have a capacity of usize::MAX:\n\n ```\n #[derive(Clone)]\n struct ZeroSized;\n\n fn main() {\n     assert_eq!(std::mem::size_of::<ZeroSized>(), 0);\n     let v = vec![ZeroSized; 0];\n     assert_eq!(v.capacity(), usize::MAX);\n }\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the underlying writer.\n\n It is inadvisable to directly write to the underlying writer.\n\n # Examples\n\n ```no_run\n use std::io::BufWriter;\n use std::net::TcpStream;\n\n let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n\n // we can use reference just like buffer\n let reference = buffer.get_mut();\n ```\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    },
    "io::Write::write_vectored": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Like [`write`], except that it writes from a slice of buffers.\n\n Data is copied from each buffer in order, with the final buffer\n read from possibly being only partially consumed. This method must\n behave as a call to [`write`] with the buffers concatenated would.\n\n The default implementation calls [`write`] with either the first nonempty\n buffer provided, or an empty one if none exists.\n\n # Examples\n\n ```no_run\n use std::io::IoSlice;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let data1 = [1; 8];\n     let data2 = [15; 8];\n     let io_slice1 = IoSlice::new(&data1);\n     let io_slice2 = IoSlice::new(&data2);\n\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // Writes some prefix of the byte string, not necessarily all of it.\n     buffer.write_vectored(&[io_slice1, io_slice2])?;\n     Ok(())\n }\n ```\n\n [`write`]: Write::write\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::iter::Iterator::for_each": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls a closure on each element of an iterator.\n\n This is equivalent to using a [`for`] loop on the iterator, although\n `break` and `continue` are not possible from a closure. It's generally\n more idiomatic to use a `for` loop, but `for_each` may be more legible\n when processing items at the end of longer iterator chains. In some\n cases `for_each` may also be faster than a loop, because it will use\n internal iteration on adapters like `Chain`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n use std::sync::mpsc::channel;\n\n let (tx, rx) = channel();\n (0..5).map(|x| x * 2 + 1)\n       .for_each(move |x| tx.send(x).unwrap());\n\n let v: Vec<_> = rx.iter().collect();\n assert_eq!(v, vec![1, 3, 5, 7, 9]);\n ```\n\n For such a small example, a `for` loop may be cleaner, but `for_each`\n might be preferable to keep a functional style with longer iterators:\n\n ```\n (0..5).flat_map(|x| (x * 100)..(x * 110))\n       .enumerate()\n       .filter(|&(i, x)| (i + x) % 3 == 0)\n       .for_each(|(i, x)| println!(\"{i}:{x}\"));\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::by_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a \"by reference\" adapter for this instance of `Iterator`.\n\n Consuming method calls (direct or indirect calls to `next`)\n on the \"by reference\" adapter will consume the original iterator,\n but ownership-taking methods (those with a `self` parameter)\n only take ownership of the \"by reference\" iterator.\n\n This is useful for applying ownership-taking methods\n (such as `take` in the example below)\n without giving up ownership of the original iterator,\n so you can use the original iterator afterwards.\n\n Uses [`impl<I: Iterator + ?Sized> Iterator for &mut I { type Item = I::Item; ...}`](https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html#impl-Iterator-for-%26mut+I).\n\n # Examples\n\n ```\n let mut words = [\"hello\", \"world\", \"of\", \"Rust\"].into_iter();\n\n // Take the first two words.\n let hello_world: Vec<_> = words.by_ref().take(2).collect();\n assert_eq!(hello_world, vec![\"hello\", \"world\"]);\n\n // Collect the rest of the words.\n // We can only do this because we used `by_ref` earlier.\n let of_rust: Vec<_> = words.collect();\n assert_eq!(of_rust, vec![\"of\", \"Rust\"]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator that satisfies a predicate.\n\n `find()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then `find()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `find()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `find()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n If you need the index of the element, see [`position()`].\n\n [`Some(element)`]: Some\n [`position()`]: Iterator::position\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().find(|&x| x == 2), Some(2));\n assert_eq!(a.into_iter().find(|&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.find(|&x| x == 2), Some(2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n\n Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n",
      "adt": {}
    },
    "io::Write::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a buffer into this writer, returning how many bytes were written.\n\n This function will attempt to write the entire contents of `buf`, but\n the entire write might not succeed, or the write may also generate an\n error. Typically, a call to `write` represents one attempt to write to\n any wrapped object.\n\n Calls to `write` are not guaranteed to block waiting for data to be\n written, and a write which would otherwise block can be indicated through\n an [`Err`] variant.\n\n If this method consumed `n > 0` bytes of `buf` it must return [`Ok(n)`].\n If the return value is `Ok(n)` then `n` must satisfy `n <= buf.len()`.\n A return value of `Ok(0)` typically means that the underlying object is\n no longer able to accept bytes and will likely not be able to in the\n future as well, or that the buffer provided is empty.\n\n # Errors\n\n Each call to `write` may generate an I/O error indicating that the\n operation could not be completed. If an error is returned then no bytes\n in the buffer were written to this writer.\n\n It is **not** considered an error if the entire buffer could not be\n written to this writer.\n\n An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n write operation should be retried if there is nothing else to do.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // Writes some prefix of the byte string, not necessarily all of it.\n     buffer.write(b\"some bytes\")?;\n     Ok(())\n }\n ```\n\n [`Ok(n)`]: Ok\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::write_to_buffer_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {
    "io::buffered::bufwriter::BufWriter": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4824, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 3938, kind: RigidTy(Adt(AdtDef(DefId { id: 6507, name: \"io::IoSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }, Not)) })])"
    ],
    "io::IoSlice": [
      "Ref"
    ],
    "alloc_crate::vec::Vec": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": 1339,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:550:5: 637:6",
  "src": "fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // FIXME: Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied\n        // to `write` and `write_all`. The performance benefits can be significant. See #79930.\n        if self.get_ref().is_write_vectored() {\n            // We have to handle the possibility that the total length of the buffers overflows\n            // `usize` (even though this can only happen if multiple `IoSlice`s reference the\n            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the\n            // computation overflows, then surely the input cannot fit in our buffer, so we forward\n            // to the inner writer's `write_vectored` method to let it handle it appropriately.\n            let mut saturated_total_len: usize = 0;\n\n            for buf in bufs {\n                saturated_total_len = saturated_total_len.saturating_add(buf.len());\n\n                if saturated_total_len > self.spare_capacity() && !self.buf.is_empty() {\n                    // Flush if the total length of the input exceeds our buffer's spare capacity.\n                    // If we would have overflowed, this condition also holds, and we need to flush.\n                    self.flush_buf()?;\n                }\n\n                if saturated_total_len >= self.buf.capacity() {\n                    // Forward to our inner writer if the total length of the input is greater than or\n                    // equal to our buffer capacity. If we would have overflowed, this condition also\n                    // holds, and we punt to the inner writer.\n                    self.panicked = true;\n                    let r = self.get_mut().write_vectored(bufs);\n                    self.panicked = false;\n                    return r;\n                }\n            }\n\n            // `saturated_total_len < self.buf.capacity()` implies that we did not saturate.\n\n            // SAFETY: We checked whether or not the spare capacity was large enough above. If\n            // it was, then we're safe already. If it wasn't, we flushed, making sufficient\n            // room for any input <= the buffer size, which includes this input.\n            unsafe {\n                bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));\n            };\n\n            Ok(saturated_total_len)\n        } else {\n            let mut iter = bufs.iter();\n            let mut total_written = if let Some(buf) = iter.by_ref().find(|&buf| !buf.is_empty()) {\n                // This is the first non-empty slice to write, so if it does\n                // not fit in the buffer, we still get to flush and proceed.\n                if buf.len() > self.spare_capacity() {\n                    self.flush_buf()?;\n                }\n                if buf.len() >= self.buf.capacity() {\n                    // The slice is at least as large as the buffering capacity,\n                    // so it's better to write it directly, bypassing the buffer.\n                    self.panicked = true;\n                    let r = self.get_mut().write(buf);\n                    self.panicked = false;\n                    return r;\n                } else {\n                    // SAFETY: We checked whether or not the spare capacity was large enough above.\n                    // If it was, then we're safe already. If it wasn't, we flushed, making\n                    // sufficient room for any input <= the buffer size, which includes this input.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    buf.len()\n                }\n            } else {\n                return Ok(0);\n            };\n            debug_assert!(total_written != 0);\n            for buf in iter {\n                if buf.len() <= self.spare_capacity() {\n                    // SAFETY: safe by above conditional.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    // This cannot overflow `usize`. If we are here, we've written all of the bytes\n                    // so far to our buffer, and we've ensured that we never exceed the buffer's\n                    // capacity. Therefore, `total_written` <= `self.buf.capacity()` <= `usize::MAX`.\n                    total_written += buf.len();\n                } else {\n                    break;\n                }\n            }\n            Ok(total_written)\n        }\n    }",
  "mir": "fn <io::buffered::bufwriter::BufWriter<W> as io::Write>::write_vectored(_1: &mut io::buffered::bufwriter::BufWriter<W>, _2: &[io::IoSlice<'_>]) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _3: bool;\n    let  _4: &W;\n    let mut _5: &io::buffered::bufwriter::BufWriter<W>;\n    let mut _6: usize;\n    let mut _7: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _8: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _9: core::option::Option<&io::IoSlice<'_>>;\n    let mut _10: &mut core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _11: isize;\n    let  _12: &io::IoSlice<'_>;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: usize;\n    let  _16: &[u8];\n    let mut _17: bool;\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: &io::buffered::bufwriter::BufWriter<W>;\n    let mut _21: bool;\n    let mut _22: &alloc_crate::vec::Vec<u8>;\n    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _24: core::result::Result<(), io::error::Error>;\n    let mut _25: isize;\n    let  _26: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _27: bool;\n    let mut _28: usize;\n    let mut _29: usize;\n    let mut _30: &alloc_crate::vec::Vec<u8>;\n    let  _31: core::result::Result<usize, io::error::Error>;\n    let mut _32: &mut W;\n    let  _33: ();\n    let mut _34: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _35: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:587:38: 587:41};\n    let mut _36: usize;\n    let mut _37: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _38: usize;\n    let mut _39: core::option::Option<&io::IoSlice<'_>>;\n    let mut _40: &mut core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _41: &mut core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _42: isize;\n    let  _43: &io::IoSlice<'_>;\n    let mut _44: bool;\n    let mut _45: usize;\n    let  _46: &[u8];\n    let mut _47: usize;\n    let mut _48: &io::buffered::bufwriter::BufWriter<W>;\n    let mut _49: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _50: core::result::Result<(), io::error::Error>;\n    let mut _51: isize;\n    let  _52: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _53: bool;\n    let mut _54: usize;\n    let  _55: &[u8];\n    let mut _56: usize;\n    let mut _57: &alloc_crate::vec::Vec<u8>;\n    let  _58: core::result::Result<usize, io::error::Error>;\n    let mut _59: &mut W;\n    let  _60: &[u8];\n    let  _61: ();\n    let  _62: &[u8];\n    let  _63: &[u8];\n    let mut _64: usize;\n    let mut _65: !;\n    let mut _66: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _67: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _68: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _69: core::option::Option<&io::IoSlice<'_>>;\n    let mut _70: &mut core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _71: isize;\n    let  _72: &io::IoSlice<'_>;\n    let mut _73: bool;\n    let mut _74: usize;\n    let  _75: &[u8];\n    let mut _76: usize;\n    let mut _77: &io::buffered::bufwriter::BufWriter<W>;\n    let  _78: ();\n    let  _79: &[u8];\n    let mut _80: usize;\n    let  _81: &[u8];\n    let mut _82: (usize, bool);\n    let mut _83: usize;\n    debug self => _1;\n    debug bufs => _2;\n    debug saturated_total_len => _6;\n    debug iter => _8;\n    debug buf => _12;\n    debug residual => _26;\n    debug val => ();\n    debug r => _31;\n    debug iter => _37;\n    debug total_written => _38;\n    debug buf => _43;\n    debug residual => _52;\n    debug val => ();\n    debug r => _58;\n    debug iter => _68;\n    debug buf => _72;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = io::buffered::bufwriter::BufWriter::<W>::get_ref(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = <W as io::Write>::is_write_vectored(_4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _3) -> [0: bb31, otherwise: bb3];\n    }\n    bb3: {\n        StorageLive(_6);\n        _6 = 0_usize;\n        StorageLive(_7);\n        _7 = <&[io::IoSlice<'_>] as core::iter::IntoIterator>::into_iter(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = move _7;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_9);\n        _10 = &mut _8;\n        _9 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::next(_10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _11 = discriminant(_9);\n        switchInt(move _11) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _12 = ((_9 as variant#1).0: &io::IoSlice<'_>);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _6;\n        StorageLive(_15);\n        _16 = <io::IoSlice<'_> as core::ops::Deref>::deref(_12) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_34);\n        _34 = core::slice::<impl [io::IoSlice<'_>]>::iter(_2) -> [return: bb29, unwind unreachable];\n    }\n    bb10: {\n        _15 = PtrMetadata(_16);\n        _13 = core::num::<impl usize>::saturating_add(move _14, move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _6 = move _13;\n        StorageDead(_13);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _6;\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &(*_1);\n        _19 = io::buffered::bufwriter::BufWriter::<W>::spare_capacity(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        _17 = Gt(move _18, move _19);\n        switchInt(move _17) -> [0: bb22, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &((*_1).0: alloc_crate::vec::Vec<u8>);\n        _21 = alloc_crate::vec::Vec::<u8>::is_empty(move _22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(move _21) -> [0: bb16, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_22);\n        goto -> bb23;\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(_1) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _23 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _24) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_24);\n        _25 = discriminant(_23);\n        switchInt(move _25) -> [0: bb19, 1: bb20, otherwise: bb7];\n    }\n    bb19: {\n        StorageDead(_23);\n        goto -> bb23;\n    }\n    bb20: {\n        _26 = move ((_23 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_26) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_23);\n        StorageDead(_21);\n        StorageDead(_17);\n        goto -> bb75;\n    }\n    bb22: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_21);\n        StorageDead(_17);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _6;\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &((*_1).0: alloc_crate::vec::Vec<u8>);\n        _29 = alloc_crate::vec::Vec::<u8>::capacity(move _30) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_30);\n        _27 = Ge(move _28, move _29);\n        switchInt(move _27) -> [0: bb28, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_29);\n        StorageDead(_28);\n        ((*_1).1: bool) = true;\n        StorageLive(_31);\n        _32 = io::buffered::bufwriter::BufWriter::<W>::get_mut(_1) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _31 = <W as io::Write>::write_vectored(_32, _2) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        ((*_1).1: bool) = false;\n        _0 = move _31;\n        StorageDead(_31);\n        StorageDead(_27);\n        goto -> bb75;\n    }\n    bb28: {\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_9);\n        goto -> bb5;\n    }\n    bb29: {\n        StorageLive(_35);\n        _35 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:587:38: 587:41}(_1);\n        _33 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::for_each::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:587:38: 587:41}>(move _34, move _35) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_36);\n        _36 = _6;\n        _0 = core::result::Result::Ok(move _36);\n        StorageDead(_36);\n        StorageDead(_6);\n        goto -> bb72;\n    }\n    bb31: {\n        StorageLive(_37);\n        _37 = core::slice::<impl [io::IoSlice<'_>]>::iter(_2) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_41);\n        _41 = &mut _37;\n        _40 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::by_ref(move _41) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_41);\n        _39 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::find::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:593:75: 593:81}>(_40, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:593:75: 593:81}) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _42 = discriminant(_39);\n        switchInt(move _42) -> [1: bb35, 0: bb56, otherwise: bb7];\n    }\n    bb35: {\n        _43 = ((_39 as variant#1).0: &io::IoSlice<'_>);\n        StorageLive(_44);\n        StorageLive(_45);\n        _46 = <io::IoSlice<'_> as core::ops::Deref>::deref(_43) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _45 = PtrMetadata(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = &(*_1);\n        _47 = io::buffered::bufwriter::BufWriter::<W>::spare_capacity(move _48) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_48);\n        _44 = Gt(move _45, move _47);\n        switchInt(move _44) -> [0: bb44, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_47);\n        StorageDead(_45);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(_1) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _49 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _50) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_50);\n        _51 = discriminant(_49);\n        switchInt(move _51) -> [0: bb41, 1: bb42, otherwise: bb7];\n    }\n    bb41: {\n        StorageDead(_49);\n        goto -> bb45;\n    }\n    bb42: {\n        _52 = move ((_49 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_52) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_49);\n        StorageDead(_44);\n        goto -> bb73;\n    }\n    bb44: {\n        StorageDead(_47);\n        StorageDead(_45);\n        goto -> bb45;\n    }\n    bb45: {\n        StorageDead(_44);\n        StorageLive(_53);\n        StorageLive(_54);\n        _55 = <io::IoSlice<'_> as core::ops::Deref>::deref(_43) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _54 = PtrMetadata(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &((*_1).0: alloc_crate::vec::Vec<u8>);\n        _56 = alloc_crate::vec::Vec::<u8>::capacity(move _57) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_57);\n        _53 = Ge(move _54, move _56);\n        switchInt(move _53) -> [0: bb52, otherwise: bb48];\n    }\n    bb48: {\n        StorageDead(_56);\n        StorageDead(_54);\n        ((*_1).1: bool) = true;\n        StorageLive(_58);\n        _59 = io::buffered::bufwriter::BufWriter::<W>::get_mut(_1) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _60 = <io::IoSlice<'_> as core::ops::Deref>::deref(_43) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        _58 = <W as io::Write>::write(_59, _60) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        ((*_1).1: bool) = false;\n        _0 = move _58;\n        StorageDead(_58);\n        StorageDead(_53);\n        goto -> bb73;\n    }\n    bb52: {\n        StorageDead(_56);\n        StorageDead(_54);\n        _62 = <io::IoSlice<'_> as core::ops::Deref>::deref(_43) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        _61 = io::buffered::bufwriter::BufWriter::<W>::write_to_buffer_unchecked(_1, _62) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        _63 = <io::IoSlice<'_> as core::ops::Deref>::deref(_43) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        _38 = PtrMetadata(_63);\n        StorageDead(_53);\n        StorageDead(_39);\n        StorageLive(_64);\n        _64 = _38;\n        switchInt(move _64) -> [0: bb58, otherwise: bb57];\n    }\n    bb56: {\n        StorageDead(_39);\n        _0 = core::result::Result::Ok(0_usize);\n        goto -> bb74;\n    }\n    bb57: {\n        StorageDead(_64);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = move _37;\n        _66 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::IntoIterator>::into_iter(move _67) -> [return: bb59, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_64);\n        _65 = core::panicking::panic(\"assertion failed: total_written != 0\") -> unwind unreachable;\n    }\n    bb59: {\n        StorageDead(_67);\n        StorageLive(_68);\n        _68 = move _66;\n        goto -> bb60;\n    }\n    bb60: {\n        StorageLive(_69);\n        _70 = &mut _68;\n        _69 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::next(_70) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        _71 = discriminant(_69);\n        switchInt(move _71) -> [0: bb71, 1: bb62, otherwise: bb7];\n    }\n    bb62: {\n        _72 = ((_69 as variant#1).0: &io::IoSlice<'_>);\n        StorageLive(_73);\n        StorageLive(_74);\n        _75 = <io::IoSlice<'_> as core::ops::Deref>::deref(_72) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        _74 = PtrMetadata(_75);\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = &(*_1);\n        _76 = io::buffered::bufwriter::BufWriter::<W>::spare_capacity(move _77) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_77);\n        _73 = Le(move _74, move _76);\n        switchInt(move _73) -> [0: bb70, otherwise: bb65];\n    }\n    bb65: {\n        StorageDead(_76);\n        StorageDead(_74);\n        _79 = <io::IoSlice<'_> as core::ops::Deref>::deref(_72) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        _78 = io::buffered::bufwriter::BufWriter::<W>::write_to_buffer_unchecked(_1, _79) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        StorageLive(_80);\n        _81 = <io::IoSlice<'_> as core::ops::Deref>::deref(_72) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        _80 = PtrMetadata(_81);\n        _82 = CheckedAdd(_38, _80);\n        assert(!move (_82.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _38, move _80) -> [success: bb69, unwind unreachable];\n    }\n    bb69: {\n        _38 = move (_82.0: usize);\n        StorageDead(_80);\n        StorageDead(_73);\n        StorageDead(_69);\n        goto -> bb60;\n    }\n    bb70: {\n        StorageDead(_76);\n        StorageDead(_74);\n        StorageDead(_73);\n        goto -> bb71;\n    }\n    bb71: {\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_66);\n        StorageLive(_83);\n        _83 = _38;\n        _0 = core::result::Result::Ok(move _83);\n        StorageDead(_83);\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb72;\n    }\n    bb72: {\n        StorageDead(_3);\n        goto -> bb77;\n    }\n    bb73: {\n        StorageDead(_39);\n        goto -> bb74;\n    }\n    bb74: {\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb76;\n    }\n    bb75: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb76;\n    }\n    bb76: {\n        StorageDead(_3);\n        goto -> bb77;\n    }\n    bb77: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}