{
  "name": "std::<thread::lifecycle::Packet<'scope, T> as core::ops::Drop>::drop",
  "span": "$library/std/src/thread/lifecycle.rs:189:5: 189:23",
  "src": "fn drop(&mut self) {\n        // If this packet was for a thread that ran in a scope, the thread\n        // panicked, and nobody consumed the panic payload, we make sure\n        // the scope function will panic.\n        let unhandled_panic = matches!(self.result.get_mut(), Some(Err(_)));\n        // Drop the result without causing unwinding.\n        // This is only relevant for threads that aren't join()ed, as\n        // join() will take the `result` and set it to None, such that\n        // there is nothing left to drop here.\n        // If this panics, we should handle that, because we're outside the\n        // outermost `catch_unwind` of our thread.\n        // We just abort in that case, since there's nothing else we can do.\n        // (And even if we tried to handle it somehow, we'd also need to handle\n        // the case where the panic payload we get out of it also panics on\n        // drop, and so on. See issue #86027.)\n        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n            *self.result.get_mut() = None;\n        })) {\n            rtabort!(\"thread result panicked on drop\");\n        }\n        // Book-keeping so the scope knows when it's done.\n        if let Some(scope) = &self.scope {\n            // Now that there will be no more user code running on this thread\n            // that can use 'scope, mark the thread as 'finished'.\n            // It's important we only do this after the `result` has been dropped,\n            // since dropping it might still use things it borrowed from 'scope.\n            scope.decrement_num_running_threads(unhandled_panic);\n        }\n    }"
}