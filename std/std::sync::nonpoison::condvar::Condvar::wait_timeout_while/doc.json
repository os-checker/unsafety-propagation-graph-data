{
  "name": "std::sync::nonpoison::condvar::Condvar::wait_timeout_while",
  "span": "$library/std/src/sync/nonpoison/condvar.rs:317:5: 324:34",
  "doc": " Waits on this condition variable for a notification, timing out after a\n specified duration.\n\n The semantics of this function are equivalent to [`wait_while`] except\n that the thread will be blocked for roughly no longer than `dur`. This\n method should not be used for precise timing due to anomalies such as\n preemption or platform differences that might not cause the maximum\n amount of time waited to be precisely `dur`.\n\n Note that the best effort is made to ensure that the time waited is\n measured with a monotonic clock, and not affected by the changes made to\n the system time.\n\n The returned [`WaitTimeoutResult`] value indicates if the timeout is\n known to have elapsed without the condition being met.\n\n Like [`wait_while`], the lock specified will have been re-acquired when this\n function returns, regardless of whether the timeout elapsed or not.\n\n [`wait_while`]: Self::wait_while\n [`wait_timeout`]: Self::wait_timeout\n\n # Examples\n\n ```\n #![feature(nonpoison_mutex)]\n #![feature(nonpoison_condvar)]\n\n use std::sync::nonpoison::{Mutex, Condvar};\n use std::sync::Arc;\n use std::thread;\n use std::time::Duration;\n\n let pair = Arc::new((Mutex::new(true), Condvar::new()));\n let pair2 = Arc::clone(&pair);\n\n thread::spawn(move || {\n     let (lock, cvar) = &*pair2;\n     let mut pending = lock.lock();\n     *pending = false;\n     // We notify the condvar that the value has changed.\n     cvar.notify_one();\n });\n\n // wait for the thread to start up\n let (lock, cvar) = &*pair;\n let mut guard = lock.lock();\n let result = cvar.wait_timeout_while(\n     &mut guard,\n     Duration::from_millis(100),\n     |&mut pending| pending,\n );\n if result.timed_out() {\n     // timed-out without the condition ever evaluating to false.\n }\n // access the locked mutex via guard\n ```\n"
}