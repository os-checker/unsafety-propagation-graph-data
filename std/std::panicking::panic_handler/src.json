{
  "name": "std::panicking::panic_handler",
  "span": "$library/std/src/panicking.rs:622:1: 622:61",
  "src": "pub fn panic_handler(info: &core::panic::PanicInfo<'_>) -> ! {\n    struct FormatStringPayload<'a> {\n        inner: &'a core::panic::PanicMessage<'a>,\n        string: Option<String>,\n    }\n\n    impl FormatStringPayload<'_> {\n        fn fill(&mut self) -> &mut String {\n            let inner = self.inner;\n            // Lazily, the first time this gets called, run the actual string formatting.\n            self.string.get_or_insert_with(|| {\n                let mut s = String::new();\n                let mut fmt = fmt::Formatter::new(&mut s, fmt::FormattingOptions::new());\n                let _err = fmt::Display::fmt(&inner, &mut fmt);\n                s\n            })\n        }\n    }\n\n    unsafe impl PanicPayload for FormatStringPayload<'_> {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            // We do two allocations here, unfortunately. But (a) they're required with the current\n            // scheme, and (b) we don't handle panic + OOM properly anyway (see comment in\n            // begin_panic below).\n            let contents = mem::take(self.fill());\n            Box::into_raw(Box::new(contents))\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            self.fill()\n        }\n    }\n\n    impl fmt::Display for FormatStringPayload<'_> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            if let Some(s) = &self.string {\n                f.write_str(s)\n            } else {\n                fmt::Display::fmt(&self.inner, f)\n            }\n        }\n    }\n\n    struct StaticStrPayload(&'static str);\n\n    unsafe impl PanicPayload for StaticStrPayload {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            Box::into_raw(Box::new(self.0))\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            &self.0\n        }\n\n        fn as_str(&mut self) -> Option<&str> {\n            Some(self.0)\n        }\n    }\n\n    impl fmt::Display for StaticStrPayload {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            f.write_str(self.0)\n        }\n    }\n\n    let loc = info.location().unwrap(); // The current implementation always returns Some\n    let msg = info.message();\n    crate::sys::backtrace::__rust_end_short_backtrace(move || {\n        if let Some(s) = msg.as_str() {\n            panic_with_hook(\n                &mut StaticStrPayload(s),\n                loc,\n                info.can_unwind(),\n                info.force_no_backtrace(),\n            );\n        } else {\n            panic_with_hook(\n                &mut FormatStringPayload { inner: &msg, string: None },\n                loc,\n                info.can_unwind(),\n                info.force_no_backtrace(),\n            );\n        }\n    })\n}"
}