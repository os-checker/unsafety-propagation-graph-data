{
  "name": "std::sys::process::unix::unix::<impl sys::process::unix::common::Command>::recv_pidfd",
  "span": "$library/std/src/sys/process/unix/unix.rs:890:5: 890:66",
  "src": "fn recv_pidfd(&self, sock: &crate::sys::net::Socket) -> pid_t {\n        use libc::{CMSG_DATA, CMSG_FIRSTHDR, CMSG_LEN, CMSG_SPACE, SCM_RIGHTS, SOL_SOCKET};\n\n        use crate::io::IoSliceMut;\n        use crate::sys::cvt_r;\n\n        unsafe {\n            const SCM_MSG_LEN: usize = size_of::<[c_int; 1]>();\n\n            #[repr(C)]\n            union Cmsg {\n                _buf: [u8; unsafe { CMSG_SPACE(SCM_MSG_LEN as u32) as usize }],\n                _align: libc::cmsghdr,\n            }\n            let mut cmsg: Cmsg = mem::zeroed();\n            // 0-length read to get the fd\n            let mut iov = [IoSliceMut::new(&mut [])];\n\n            let mut msg: libc::msghdr = mem::zeroed();\n\n            msg.msg_iov = (&raw mut iov) as *mut _;\n            msg.msg_iovlen = 1;\n            msg.msg_controllen = size_of::<Cmsg>() as _;\n            msg.msg_control = (&raw mut cmsg) as *mut _;\n\n            match cvt_r(|| libc::recvmsg(sock.as_raw(), &mut msg, libc::MSG_CMSG_CLOEXEC)) {\n                Err(_) => return -1,\n                Ok(_) => {}\n            }\n\n            let hdr = CMSG_FIRSTHDR((&raw mut msg) as *mut _);\n            if hdr.is_null()\n                || (*hdr).cmsg_level != SOL_SOCKET\n                || (*hdr).cmsg_type != SCM_RIGHTS\n                || (*hdr).cmsg_len != CMSG_LEN(SCM_MSG_LEN as _) as _\n            {\n                return -1;\n            }\n            let data = CMSG_DATA(hdr);\n\n            let mut fds = [-1 as c_int];\n\n            crate::ptr::copy_nonoverlapping(\n                data as *const _,\n                fds.as_mut_ptr().cast::<u8>(),\n                SCM_MSG_LEN,\n            );\n\n            fds[0]\n        }\n    }"
}