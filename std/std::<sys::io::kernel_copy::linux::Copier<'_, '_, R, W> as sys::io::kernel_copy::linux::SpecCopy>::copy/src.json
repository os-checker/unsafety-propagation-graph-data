{
  "name": "std::<sys::io::kernel_copy::linux::Copier<'_, '_, R, W> as sys::io::kernel_copy::linux::SpecCopy>::copy",
  "span": "$library/std/src/sys/io/kernel_copy/linux.rs:189:5: 189:39",
  "src": "fn copy(self) -> Result<CopyState> {\n        let (reader, writer) = (self.read, self.write);\n        let r_cfg = reader.properties();\n        let w_cfg = writer.properties();\n\n        // before direct operations on file descriptors ensure that all source and sink buffers are empty\n        let mut flush = || -> Result<u64> {\n            let bytes = reader.drain_to(writer, u64::MAX)?;\n            // BufWriter buffered bytes have already been accounted for in earlier write() calls\n            writer.flush()?;\n            Ok(bytes)\n        };\n\n        let mut written = 0u64;\n\n        if let (CopyParams(input_meta, Some(readfd)), CopyParams(output_meta, Some(writefd))) =\n            (r_cfg, w_cfg)\n        {\n            written += flush()?;\n            let max_write = reader.min_limit();\n\n            if input_meta.copy_file_range_candidate(FdHandle::Input)\n                && output_meta.copy_file_range_candidate(FdHandle::Output)\n            {\n                let result = copy_regular_files(readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => {\n                        return Ok(CopyState::Ended(bytes_copied + written));\n                    }\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(bytes) => written += bytes,\n                }\n            }\n\n            // on modern kernels sendfile can copy from any mmapable type (some but not all regular files and block devices)\n            // to any writable file descriptor. On older kernels the writer side can only be a socket.\n            // So we just try and fallback if needed.\n            // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n            // fall back to the generic copy loop.\n            if input_meta.potential_sendfile_source() && safe_kernel_copy(&input_meta, &output_meta)\n            {\n                let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => {\n                        return Ok(CopyState::Ended(bytes_copied + written));\n                    }\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(bytes) => written += bytes,\n                }\n            }\n\n            if (input_meta.maybe_fifo() || output_meta.maybe_fifo())\n                && safe_kernel_copy(&input_meta, &output_meta)\n            {\n                let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n                result.update_take(reader);\n\n                match result {\n                    CopyResult::Ended(bytes_copied) => {\n                        return Ok(CopyState::Ended(bytes_copied + written));\n                    }\n                    CopyResult::Error(e, _) => return Err(e),\n                    CopyResult::Fallback(0) => { /* use the fallback below */ }\n                    CopyResult::Fallback(_) => {\n                        unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n                    }\n                }\n            }\n        }\n\n        // fallback if none of the more specialized syscalls wants to work with these file descriptors\n        Ok(CopyState::Fallback(written))\n    }"
}