{
  "name": "std::panicking::begin_panic",
  "span": "$library/std/src/panicking.rs:720:1: 720:53",
  "src": "pub const fn begin_panic<M: Any + Send>(msg: M) -> ! {\n    if cfg!(panic = \"immediate-abort\") {\n        intrinsics::abort()\n    }\n\n    struct Payload<A> {\n        inner: Option<A>,\n    }\n\n    unsafe impl<A: Send + 'static> PanicPayload for Payload<A> {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            // Note that this should be the only allocation performed in this code path. Currently\n            // this means that panic!() on OOM will invoke this code path, but then again we're not\n            // really ready for panic on OOM anyway. If we do start doing this, then we should\n            // propagate this allocation to be performed in the parent of this thread instead of the\n            // thread that's panicking.\n            let data = match self.inner.take() {\n                Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                None => process::abort(),\n            };\n            Box::into_raw(data)\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            match self.inner {\n                Some(ref a) => a,\n                None => process::abort(),\n            }\n        }\n    }\n\n    impl<A: 'static> fmt::Display for Payload<A> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            match &self.inner {\n                Some(a) => f.write_str(payload_as_str(a)),\n                None => process::abort(),\n            }\n        }\n    }\n\n    let loc = Location::caller();\n    crate::sys::backtrace::__rust_end_short_backtrace(move || {\n        panic_with_hook(\n            &mut Payload { inner: Some(msg) },\n            loc,\n            /* can_unwind */ true,\n            /* force_no_backtrace */ false,\n        )\n    })\n}"
}