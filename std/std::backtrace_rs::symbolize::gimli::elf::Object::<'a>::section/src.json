{
  "name": "std::backtrace_rs::symbolize::gimli::elf::Object::<'a>::section",
  "span": "$library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:215:5: 215:76",
  "src": "pub fn section(&self, stash: &'a Stash, name: &str) -> Option<&'a [u8]> {\n        if let Some(section) = self.section_header(name) {\n            let mut data = Bytes(section.data(self.endian, self.data).ok()?);\n\n            // Check for DWARF-standard (gABI) compression, i.e., as generated\n            // by ld's `--compress-debug-sections=zlib-gabi` and\n            // `--compress-debug-sections=zstd` flags.\n            let flags: u64 = section.sh_flags(self.endian).into();\n            if (flags & u64::from(SHF_COMPRESSED)) == 0 {\n                // Not compressed.\n                return Some(data.0);\n            }\n\n            let header = data.read::<<Elf as FileHeader>::CompressionHeader>().ok()?;\n            match header.ch_type(self.endian) {\n                ELFCOMPRESS_ZLIB => {\n                    let size = usize::try_from(header.ch_size(self.endian)).ok()?;\n                    let buf = stash.allocate(size);\n                    decompress_zlib(data.0, buf)?;\n                    return Some(buf);\n                }\n                #[cfg(feature = \"ruzstd\")]\n                ELFCOMPRESS_ZSTD => {\n                    let size = usize::try_from(header.ch_size(self.endian)).ok()?;\n                    let buf = stash.allocate(size);\n                    decompress_zstd(data.0, buf)?;\n                    return Some(buf);\n                }\n                _ => return None, // Unknown compression type.\n            }\n        }\n\n        // Check for the nonstandard GNU compression format, i.e., as generated\n        // by ld's `--compress-debug-sections=zlib-gnu` flag. This means that if\n        // we're actually asking for `.debug_info` then we need to look up a\n        // section named `.zdebug_info`.\n        if !name.starts_with(\".debug_\") {\n            return None;\n        }\n        let debug_name = name[7..].as_bytes();\n        let compressed_section = self\n            .sections\n            .iter()\n            .filter_map(|header| {\n                let name = self.sections.section_name(self.endian, header).ok()?;\n                if name.starts_with(b\".zdebug_\") && &name[8..] == debug_name {\n                    Some(header)\n                } else {\n                    None\n                }\n            })\n            .next()?;\n        let mut data = Bytes(compressed_section.data(self.endian, self.data).ok()?);\n        if data.read_bytes(8).ok()?.0 != b\"ZLIB\\0\\0\\0\\0\" {\n            return None;\n        }\n        let size = usize::try_from(data.read::<object::U32Bytes<_>>().ok()?.get(BigEndian)).ok()?;\n        let buf = stash.allocate(size);\n        decompress_zlib(data.0, buf)?;\n        Some(buf)\n    }"
}