{
  "name": "std::os::unix::net::addr::sockaddr_un",
  "span": "$library/std/src/os/unix/net/addr.rs:26:1: 26:91",
  "src": "pub(super) fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n    // SAFETY: All zeros is a valid representation for `sockaddr_un`.\n    let mut addr: libc::sockaddr_un = unsafe { mem::zeroed() };\n    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n\n    let bytes = path.as_os_str().as_bytes();\n\n    if bytes.contains(&0) {\n        return Err(io::const_error!(\n            io::ErrorKind::InvalidInput,\n            \"paths must not contain interior null bytes\",\n        ));\n    }\n\n    if bytes.len() >= addr.sun_path.len() {\n        return Err(io::const_error!(\n            io::ErrorKind::InvalidInput,\n            \"path must be shorter than SUN_LEN\",\n        ));\n    }\n    // SAFETY: `bytes` and `addr.sun_path` are not overlapping and\n    // both point to valid memory.\n    // NOTE: We zeroed the memory above, so the path is already null\n    // terminated.\n    unsafe {\n        ptr::copy_nonoverlapping(bytes.as_ptr(), addr.sun_path.as_mut_ptr().cast(), bytes.len())\n    };\n\n    let mut len = SUN_PATH_OFFSET + bytes.len();\n    match bytes.get(0) {\n        Some(&0) | None => {}\n        Some(_) => len += 1,\n    }\n    Ok((addr, len as libc::socklen_t))\n}"
}