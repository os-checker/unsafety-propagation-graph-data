{
  "name": "std::sys::pal::unix::stack_overflow::imp::signal_handler",
  "span": "$library/std/src/sys/pal/unix/stack_overflow.rs:101:5: 105:6",
  "src": "unsafe extern \"C\" fn signal_handler(\n        signum: libc::c_int,\n        info: *mut libc::siginfo_t,\n        _data: *mut libc::c_void,\n    ) {\n        // SAFETY: this pointer is provided by the system and will always point to a valid `siginfo_t`.\n        let fault_addr = unsafe { (*info).si_addr().addr() };\n\n        // `with_current_info` expects that the process aborts after it is\n        // called. If the signal was not caused by a memory access, this might\n        // not be true. We detect this by noticing that the `si_addr` field is\n        // zero if the signal is synthetic.\n        if fault_addr != 0 {\n            with_current_info(|thread_info| {\n                // If the faulting address is within the guard page, then we print a\n                // message saying so and abort.\n                if let Some(thread_info) = thread_info\n                    && thread_info.guard_page_range.contains(&fault_addr)\n                {\n                    // Hey you! Yes, you modifying the stack overflow message!\n                    // Please make sure that all functions called here are\n                    // actually async-signal-safe. If they're not, try retrieving\n                    // the information beforehand and storing it in `ThreadInfo`.\n                    // Thank you!\n                    // - says Jonas after having had to watch his carefully\n                    //   written code get made unsound again.\n                    let tid = thread_info.tid;\n                    let name = thread_info.name.as_deref().unwrap_or(\"<unknown>\");\n                    rtprintpanic!(\"\\nthread '{name}' ({tid}) has overflowed its stack\\n\");\n                    rtabort!(\"stack overflow\");\n                }\n            })\n        }\n\n        // Unregister ourselves by reverting back to the default behavior.\n        // SAFETY: assuming all platforms define struct sigaction as \"zero-initializable\"\n        let mut action: sigaction = unsafe { mem::zeroed() };\n        action.sa_sigaction = SIG_DFL;\n        // SAFETY: pray this is a well-behaved POSIX implementation of fn sigaction\n        unsafe { sigaction(signum, &action, ptr::null_mut()) };\n\n        // See comment above for why this function returns.\n    }"
}