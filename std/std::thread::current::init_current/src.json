{
  "name": "std::thread::current::init_current",
  "span": "$library/std/src/thread/current.rs:289:1: 289:44",
  "src": "fn init_current(current: *mut ()) -> Thread {\n    if current == NONE {\n        CURRENT.set(BUSY);\n        // If the thread ID was initialized already, use it.\n        let id = id::get_or_init();\n        let thread = Thread::new(id, None);\n\n        // Make sure that `crate::rt::thread_cleanup` will be run, which will\n        // call `drop_current`.\n        crate::sys::thread_local::guard::enable();\n        CURRENT.set(thread.clone().into_raw().cast_mut());\n        thread\n    } else if current == BUSY {\n        // BUSY exists solely for this check, but as it is in the slow path, the\n        // extra TLS write above shouldn't matter. The alternative is nearly always\n        // a stack overflow.\n        //\n        // If we reach this point it means our initialization routine ended up\n        // calling current() either directly, or indirectly through the global\n        // allocator, which is a bug either way as we may not call the global\n        // allocator in current().\n        rtabort!(\n            \"init_current() was re-entrant, which indicates a bug in the Rust threading implementation\"\n        )\n    } else {\n        debug_assert_eq!(current, DESTROYED);\n        panic!(\n            \"use of std::thread::current() is not possible after the thread's \\\n            local data has been destroyed\"\n        )\n    }\n}"
}