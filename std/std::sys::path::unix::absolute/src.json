{
  "name": "std::sys::path::unix::absolute",
  "span": "$library/std/src/sys/path/unix.rs:25:1: 25:59",
  "src": "pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n    // This is mostly a wrapper around collecting `Path::components`, with\n    // exceptions made where this conflicts with the POSIX specification.\n    // See 4.13 Pathname Resolution, IEEE Std 1003.1-2017\n    // https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n\n    // Get the components, skipping the redundant leading \".\" component if it exists.\n    let mut components = path.strip_prefix(\".\").unwrap_or(path).components();\n    let path_os = path.as_os_str().as_encoded_bytes();\n\n    let mut normalized = if path.is_absolute() {\n        // \"If a pathname begins with two successive <slash> characters, the\n        // first component following the leading <slash> characters may be\n        // interpreted in an implementation-defined manner, although more than\n        // two leading <slash> characters shall be treated as a single <slash>\n        // character.\"\n        if path_os.starts_with(b\"//\") && !path_os.starts_with(b\"///\") {\n            components.next();\n            PathBuf::from(\"//\")\n        } else {\n            PathBuf::new()\n        }\n    } else {\n        env::current_dir()?\n    };\n    normalized.extend(components);\n\n    // \"Interfaces using pathname resolution may specify additional constraints\n    // when a pathname that does not name an existing directory contains at\n    // least one non- <slash> character and contains one or more trailing\n    // <slash> characters\".\n    // A trailing <slash> is also meaningful if \"a symbolic link is\n    // encountered during pathname resolution\".\n    if path_os.ends_with(b\"/\") {\n        normalized.push(\"\");\n    }\n\n    Ok(normalized)\n}"
}