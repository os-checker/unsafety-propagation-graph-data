{
  "name": "std::sync::mpsc::SyncSender::<T>::try_send",
  "span": "$library/std/src/sync/mpsc.rs:731:5: 731:64",
  "doc": " Attempts to send a value on this channel without blocking.\n\n This method differs from [`send`] by returning immediately if the\n channel's buffer is full or no receiver is waiting to acquire some\n data. Compared with [`send`], this function has two failure cases\n instead of one (one for disconnection, one for a full buffer).\n\n See [`send`] for notes about guarantees of whether the\n receiver has received the data or not if this function is successful.\n\n [`send`]: Self::send\n\n # Examples\n\n ```rust\n use std::sync::mpsc::sync_channel;\n use std::thread;\n\n // Create a sync_channel with buffer size 1\n let (sync_sender, receiver) = sync_channel(1);\n let sync_sender2 = sync_sender.clone();\n\n // First thread owns sync_sender\n let handle1 = thread::spawn(move || {\n     sync_sender.send(1).unwrap();\n     sync_sender.send(2).unwrap();\n     // Thread blocked\n });\n\n // Second thread owns sync_sender2\n let handle2 = thread::spawn(move || {\n     // This will return an error and send\n     // no message if the buffer is full\n     let _ = sync_sender2.try_send(3);\n });\n\n let mut msg;\n msg = receiver.recv().unwrap();\n println!(\"message {msg} received\");\n\n msg = receiver.recv().unwrap();\n println!(\"message {msg} received\");\n\n // Third message may have never been sent\n match receiver.try_recv() {\n     Ok(msg) => println!(\"message {msg} received\"),\n     Err(_) => println!(\"the third message was never sent\"),\n }\n\n // Wait for threads to complete\n handle1.join().unwrap();\n handle2.join().unwrap();\n ```\n"
}