{
  "name": "std::net::tcp::TcpStream::set_nonblocking",
  "span": "$library/std/src/net/tcp.rs:618:5: 618:71",
  "doc": " Moves this TCP stream into or out of nonblocking mode.\n\n This will result in `read`, `write`, `recv` and `send` system operations\n becoming nonblocking, i.e., immediately returning from their calls.\n If the IO operation is successful, `Ok` is returned and no further\n action is required. If the IO operation could not be completed and needs\n to be retried, an error with kind [`io::ErrorKind::WouldBlock`] is\n returned.\n\n On Unix platforms, calling this method corresponds to calling `fcntl`\n `FIONBIO`. On Windows calling this method corresponds to calling\n `ioctlsocket` `FIONBIO`.\n\n # Examples\n\n Reading bytes from a TCP stream in non-blocking mode:\n\n ```no_run\n use std::io::{self, Read};\n use std::net::TcpStream;\n\n let mut stream = TcpStream::connect(\"127.0.0.1:7878\")\n     .expect(\"Couldn't connect to the server...\");\n stream.set_nonblocking(true).expect(\"set_nonblocking call failed\");\n\n # fn wait_for_fd() { unimplemented!() }\n let mut buf = vec![];\n loop {\n     match stream.read_to_end(&mut buf) {\n         Ok(_) => break,\n         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n             // wait until network socket is ready, typically implemented\n             // via platform-specific APIs such as epoll or IOCP\n             wait_for_fd();\n         }\n         Err(e) => panic!(\"encountered IO error: {e}\"),\n     };\n };\n println!(\"bytes: {buf:?}\");\n ```\n"
}