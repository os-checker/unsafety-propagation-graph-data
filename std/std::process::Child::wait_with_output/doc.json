{
  "name": "std::process::Child::wait_with_output",
  "span": "$library/std/src/process.rs:2368:5: 2368:60",
  "doc": " Simultaneously waits for the child to exit and collect all remaining\n output on the stdout/stderr handles, returning an `Output`\n instance.\n\n The stdin handle to the child process, if any, will be closed\n before waiting. This helps avoid deadlock: it ensures that the\n child does not block waiting for input from the parent, while\n the parent waits for the child to exit.\n\n By default, stdin, stdout and stderr are inherited from the parent.\n In order to capture the output into this `Result<Output>` it is\n necessary to create new pipes between parent and child. Use\n `stdout(Stdio::piped())` or `stderr(Stdio::piped())`, respectively.\n\n # Examples\n\n ```should_panic\n use std::process::{Command, Stdio};\n\n let child = Command::new(\"/bin/cat\")\n     .arg(\"file.txt\")\n     .stdout(Stdio::piped())\n     .spawn()\n     .expect(\"failed to execute child\");\n\n let output = child\n     .wait_with_output()\n     .expect(\"failed to wait on child\");\n\n assert!(output.status.success());\n ```\n\n"
}