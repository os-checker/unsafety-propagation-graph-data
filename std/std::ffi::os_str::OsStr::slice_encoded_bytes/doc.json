{
  "name": "std::ffi::os_str::OsStr::slice_encoded_bytes",
  "span": "$library/std/src/ffi/os_str.rs:1104:5: 1104:85",
  "doc": " Takes a substring based on a range that corresponds to the return value of\n [`OsStr::as_encoded_bytes`].\n\n The range's start and end must lie on valid `OsStr` boundaries.\n A valid `OsStr` boundary is one of:\n - The start of the string\n - The end of the string\n - Immediately before a valid non-empty UTF-8 substring\n - Immediately after a valid non-empty UTF-8 substring\n\n # Panics\n\n Panics if `range` does not lie on valid `OsStr` boundaries or if it\n exceeds the end of the string.\n\n # Example\n\n ```\n #![feature(os_str_slice)]\n\n use std::ffi::OsStr;\n\n let os_str = OsStr::new(\"foo=bar\");\n let bytes = os_str.as_encoded_bytes();\n if let Some(index) = bytes.iter().position(|b| *b == b'=') {\n     let key = os_str.slice_encoded_bytes(..index);\n     let value = os_str.slice_encoded_bytes(index + 1..);\n     assert_eq!(key, \"foo\");\n     assert_eq!(value, \"bar\");\n }\n ```\n"
}