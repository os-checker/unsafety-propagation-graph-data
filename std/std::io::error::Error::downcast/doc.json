{
  "name": "std::io::error::Error::downcast",
  "span": "$library/std/src/io/error.rs:949:5: 951:49",
  "doc": " Attempts to downcast the custom boxed error to `E`.\n\n If this [`Error`] contains a custom boxed error,\n then it would attempt downcasting on the boxed error,\n otherwise it will return [`Err`].\n\n If the custom boxed error has the same type as `E`, it will return [`Ok`],\n otherwise it will also return [`Err`].\n\n This method is meant to be a convenience routine for calling\n `Box<dyn Error + Sync + Send>::downcast` on the custom boxed error, returned by\n [`Error::into_inner`].\n\n\n # Examples\n\n ```\n use std::fmt;\n use std::io;\n use std::error::Error;\n\n #[derive(Debug)]\n enum E {\n     Io(io::Error),\n     SomeOtherVariant,\n }\n\n impl fmt::Display for E {\n    // ...\n #    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n #        todo!()\n #    }\n }\n impl Error for E {}\n\n impl From<io::Error> for E {\n     fn from(err: io::Error) -> E {\n         err.downcast::<E>()\n             .unwrap_or_else(E::Io)\n     }\n }\n\n impl From<E> for io::Error {\n     fn from(err: E) -> io::Error {\n         match err {\n             E::Io(io_error) => io_error,\n             e => io::Error::new(io::ErrorKind::Other, e),\n         }\n     }\n }\n\n # fn main() {\n let e = E::SomeOtherVariant;\n // Convert it to an io::Error\n let io_error = io::Error::from(e);\n // Cast it back to the original variant\n let e = E::from(io_error);\n assert!(matches!(e, E::SomeOtherVariant));\n\n let io_error = io::Error::from(io::ErrorKind::AlreadyExists);\n // Convert it to E\n let e = E::from(io_error);\n // Cast it back to the original variant\n let io_error = io::Error::from(e);\n assert_eq!(io_error.kind(), io::ErrorKind::AlreadyExists);\n assert!(io_error.get_ref().is_none());\n assert!(io_error.raw_os_error().is_none());\n # }\n ```\n"
}