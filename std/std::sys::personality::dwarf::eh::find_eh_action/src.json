{
  "name": "std::sys::personality::dwarf::eh::find_eh_action",
  "span": "$library/std/src/sys/personality/dwarf/eh.rs:66:1: 66:95",
  "src": "pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result<EHAction, ()> {\n    if lsda.is_null() {\n        return Ok(EHAction::None);\n    }\n\n    let func_start = context.func_start;\n    let mut reader = DwarfReader::new(lsda);\n    let lpad_base = unsafe {\n        let start_encoding = reader.read::<u8>();\n        // base address for landing pad offsets\n        if start_encoding != DW_EH_PE_omit {\n            read_encoded_pointer(&mut reader, context, start_encoding)?\n        } else {\n            func_start\n        }\n    };\n    let call_site_encoding = unsafe {\n        let ttype_encoding = reader.read::<u8>();\n        if ttype_encoding != DW_EH_PE_omit {\n            // Rust doesn't analyze exception types, so we don't care about the type table\n            reader.read_uleb128();\n        }\n\n        reader.read::<u8>()\n    };\n    let action_table = unsafe {\n        let call_site_table_length = reader.read_uleb128();\n        reader.ptr.add(call_site_table_length as usize)\n    };\n    let ip = context.ip;\n\n    if !USING_SJLJ_EXCEPTIONS {\n        // read the callsite table\n        while reader.ptr < action_table {\n            unsafe {\n                // these are offsets rather than pointers;\n                let cs_start = read_encoded_offset(&mut reader, call_site_encoding)?;\n                let cs_len = read_encoded_offset(&mut reader, call_site_encoding)?;\n                let cs_lpad = read_encoded_offset(&mut reader, call_site_encoding)?;\n                let cs_action_entry = reader.read_uleb128();\n                // Callsite table is sorted by cs_start, so if we've passed the ip, we\n                // may stop searching.\n                if ip < func_start.wrapping_add(cs_start) {\n                    break;\n                }\n                if ip < func_start.wrapping_add(cs_start + cs_len) {\n                    if cs_lpad == 0 {\n                        return Ok(EHAction::None);\n                    } else {\n                        let lpad = lpad_base.wrapping_add(cs_lpad);\n                        return Ok(interpret_cs_action(action_table, cs_action_entry, lpad));\n                    }\n                }\n            }\n        }\n        // Ip is not present in the table. This indicates a nounwind call.\n        Ok(EHAction::Terminate)\n    } else {\n        // SjLj version:\n        // The \"IP\" is an index into the call-site table, with two exceptions:\n        // -1 means 'no-action', and 0 means 'terminate'.\n        match ip.addr() as isize {\n            -1 => return Ok(EHAction::None),\n            0 => return Ok(EHAction::Terminate),\n            _ => (),\n        }\n        let mut idx = ip.addr();\n        loop {\n            let cs_lpad = unsafe { reader.read_uleb128() };\n            let cs_action_entry = unsafe { reader.read_uleb128() };\n            idx -= 1;\n            if idx == 0 {\n                // Can never have null landing pad for sjlj -- that would have\n                // been indicated by a -1 call site index.\n                // FIXME(strict provenance)\n                let lpad = ptr::with_exposed_provenance((cs_lpad + 1) as usize);\n                return Ok(unsafe { interpret_cs_action(action_table, cs_action_entry, lpad) });\n            }\n        }\n    }\n}"
}