{
  "name": "std::sync::mpmc::array::Channel::<T>::start_recv",
  "span": "$library/std/src/sync/mpmc/array.rs:215:5: 215:52",
  "src": "fn start_recv(&self, token: &mut Token) -> bool {\n        let backoff = Backoff::new();\n        let mut head = self.head.load(Ordering::Relaxed);\n\n        loop {\n            // Deconstruct the head.\n            let index = head & (self.mark_bit - 1);\n            let lap = head & !(self.one_lap - 1);\n\n            // Inspect the corresponding slot.\n            debug_assert!(index < self.buffer.len());\n            let slot = unsafe { self.buffer.get_unchecked(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the stamp is ahead of the head by 1, we may attempt to pop.\n            if head + 1 == stamp {\n                let new = if index + 1 < self.cap {\n                    // Same lap, incremented index.\n                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n                    head + 1\n                } else {\n                    // One lap forward, index wraps around to zero.\n                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n                    lap.wrapping_add(self.one_lap)\n                };\n\n                // Try moving the head.\n                match self.head.compare_exchange_weak(\n                    head,\n                    new,\n                    Ordering::SeqCst,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => {\n                        // Prepare the token for the follow-up call to `read`.\n                        token.array.slot = slot as *const Slot<T> as *const u8;\n                        token.array.stamp = head.wrapping_add(self.one_lap);\n                        return true;\n                    }\n                    Err(_) => {\n                        backoff.spin_light();\n                        head = self.head.load(Ordering::Relaxed);\n                    }\n                }\n            } else if stamp == head {\n                atomic::fence(Ordering::SeqCst);\n                let tail = self.tail.load(Ordering::Relaxed);\n\n                // If the tail equals the head, that means the channel is empty.\n                if (tail & !self.mark_bit) == head {\n                    // If the channel is disconnected...\n                    if tail & self.mark_bit != 0 {\n                        // ...then receive an error.\n                        token.array.slot = ptr::null();\n                        token.array.stamp = 0;\n                        return true;\n                    } else {\n                        // Otherwise, the receive operation is not ready.\n                        return false;\n                    }\n                }\n\n                backoff.spin_light();\n                head = self.head.load(Ordering::Relaxed);\n            } else {\n                // Snooze because we need to wait for the stamp to get updated.\n                backoff.spin_heavy();\n                head = self.head.load(Ordering::Relaxed);\n            }\n        }\n    }"
}