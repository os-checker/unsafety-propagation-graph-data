{
  "name": "std::sys::personality::dwarf::eh::read_encoded_pointer",
  "span": "$library/std/src/sys/personality/dwarf/eh.rs:225:1: 229:27",
  "src": "unsafe fn read_encoded_pointer(\n    reader: &mut DwarfReader,\n    context: &EHContext<'_>,\n    encoding: u8,\n) -> Result<*const u8, ()> {\n    if encoding == DW_EH_PE_omit {\n        return Err(());\n    }\n\n    let base_ptr = match encoding & 0x70 {\n        DW_EH_PE_absptr => core::ptr::null(),\n        // relative to address of the encoded value, despite the name\n        DW_EH_PE_pcrel => reader.ptr,\n        DW_EH_PE_funcrel => {\n            if context.func_start.is_null() {\n                return Err(());\n            }\n            context.func_start\n        }\n        DW_EH_PE_textrel => (*context.get_text_start)(),\n        DW_EH_PE_datarel => (*context.get_data_start)(),\n        // aligned means the value is aligned to the size of a pointer\n        DW_EH_PE_aligned => {\n            reader.ptr = reader.ptr.with_addr(round_up(reader.ptr.addr(), size_of::<*const u8>())?);\n            core::ptr::null()\n        }\n        _ => return Err(()),\n    };\n\n    let mut ptr = if base_ptr.is_null() {\n        // any value encoding other than absptr would be nonsensical here;\n        // there would be no source of pointer provenance\n        if encoding & 0x0F != DW_EH_PE_absptr {\n            return Err(());\n        }\n        unsafe { reader.read::<*const u8>() }\n    } else {\n        let offset = unsafe { read_encoded_offset(reader, encoding & 0x0F)? };\n        base_ptr.wrapping_add(offset)\n    };\n\n    if encoding & DW_EH_PE_indirect != 0 {\n        ptr = unsafe { *(ptr.cast::<*const u8>()) };\n    }\n\n    Ok(ptr)\n}"
}