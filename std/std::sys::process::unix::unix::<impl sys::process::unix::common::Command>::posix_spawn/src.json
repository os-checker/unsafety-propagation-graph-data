{
  "name": "std::sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn",
  "span": "$library/std/src/sys/process/unix/unix.rs:449:5: 453:37",
  "src": "fn posix_spawn(\n        &mut self,\n        stdio: &ChildPipes,\n        envp: Option<&CStringArray>,\n    ) -> io::Result<Option<Process>> {\n        #[cfg(target_os = \"linux\")]\n        use core::sync::atomic::{Atomic, AtomicU8, Ordering};\n\n        use crate::mem::MaybeUninit;\n        use crate::sys::{self, cvt_nz, on_broken_pipe_flag_used};\n\n        if self.get_gid().is_some()\n            || self.get_uid().is_some()\n            || (self.env_saw_path() && !self.program_is_path())\n            || !self.get_closures().is_empty()\n            || self.get_groups().is_some()\n            || self.get_chroot().is_some()\n        {\n            return Ok(None);\n        }\n\n        cfg_select! {\n            target_os = \"linux\" => {\n                use crate::sys::weak::weak;\n\n                weak!(\n                    fn pidfd_spawnp(\n                        pidfd: *mut libc::c_int,\n                        path: *const libc::c_char,\n                        file_actions: *const libc::posix_spawn_file_actions_t,\n                        attrp: *const libc::posix_spawnattr_t,\n                        argv: *const *mut libc::c_char,\n                        envp: *const *mut libc::c_char,\n                    ) -> libc::c_int;\n                );\n\n                weak!(\n                    fn pidfd_getpid(pidfd: libc::c_int) -> libc::c_int;\n                );\n\n                static PIDFD_SUPPORTED: Atomic<u8> = AtomicU8::new(0);\n                const UNKNOWN: u8 = 0;\n                const SPAWN: u8 = 1;\n                // Obtaining a pidfd via the fork+exec path might work\n                const FORK_EXEC: u8 = 2;\n                // Neither pidfd_spawn nor fork/exec will get us a pidfd.\n                // Instead we'll just posix_spawn if the other preconditions are met.\n                const NO: u8 = 3;\n\n                if self.get_create_pidfd() {\n                    let mut support = PIDFD_SUPPORTED.load(Ordering::Relaxed);\n                    if support == FORK_EXEC {\n                        return Ok(None);\n                    }\n                    if support == UNKNOWN {\n                        support = NO;\n                        let our_pid = crate::process::id();\n                        let pidfd = cvt(unsafe { libc::syscall(libc::SYS_pidfd_open, our_pid, 0) } as c_int);\n                        match pidfd {\n                            Ok(pidfd) => {\n                                support = FORK_EXEC;\n                                if let Some(Ok(pid)) = pidfd_getpid.get().map(|f| cvt(unsafe { f(pidfd) } as i32)) {\n                                    if pidfd_spawnp.get().is_some() && pid as u32 == our_pid {\n                                        support = SPAWN\n                                    }\n                                }\n                                unsafe { libc::close(pidfd) };\n                            }\n                            Err(e) if e.raw_os_error() == Some(libc::EMFILE) => {\n                                // We're temporarily(?) out of file descriptors.  In this case obtaining a pidfd would also fail\n                                // Don't update the support flag so we can probe again later.\n                                return Err(e)\n                            }\n                            _ => {}\n                        }\n                        PIDFD_SUPPORTED.store(support, Ordering::Relaxed);\n                        if support == FORK_EXEC {\n                            return Ok(None);\n                        }\n                    }\n                    core::assert_matches::debug_assert_matches!(support, SPAWN | NO);\n                }\n            }\n            _ => {\n                if self.get_create_pidfd() {\n                    unreachable!(\"only implemented on linux\")\n                }\n            }\n        }\n\n        // Only glibc 2.24+ posix_spawn() supports returning ENOENT directly.\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n        {\n            if let Some(version) = sys::os::glibc_version() {\n                if version < (2, 24) {\n                    return Ok(None);\n                }\n            } else {\n                return Ok(None);\n            }\n        }\n\n        // On QNX Neutrino, posix_spawnp can fail with EBADF in case \"another thread might have opened\n        // or closed a file descriptor while the posix_spawn() was occurring\".\n        // Documentation says \"... or try calling posix_spawn() again\". This is what we do here.\n        // See also http://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/p/posix_spawn.html\n        #[cfg(target_os = \"nto\")]\n        unsafe fn retrying_libc_posix_spawnp(\n            pid: *mut pid_t,\n            file: *const c_char,\n            file_actions: *const posix_spawn_file_actions_t,\n            attrp: *const posix_spawnattr_t,\n            argv: *const *mut c_char,\n            envp: *const *mut c_char,\n        ) -> io::Result<i32> {\n            let mut delay = MIN_FORKSPAWN_SLEEP;\n            loop {\n                match libc::posix_spawnp(pid, file, file_actions, attrp, argv, envp) {\n                    libc::EBADF => {\n                        if delay < get_clock_resolution() {\n                            // We cannot sleep this short (it would be longer).\n                            // Yield instead.\n                            thread::yield_now();\n                        } else if delay < MAX_FORKSPAWN_SLEEP {\n                            thread::sleep(delay);\n                        } else {\n                            return Err(io::const_error!(\n                                ErrorKind::WouldBlock,\n                                \"posix_spawnp returned EBADF too often\",\n                            ));\n                        }\n                        delay *= 2;\n                        continue;\n                    }\n                    r => {\n                        return Ok(r);\n                    }\n                }\n            }\n        }\n\n        type PosixSpawnAddChdirFn = unsafe extern \"C\" fn(\n            *mut libc::posix_spawn_file_actions_t,\n            *const libc::c_char,\n        ) -> libc::c_int;\n\n        /// Get the function pointer for adding a chdir action to a\n        /// `posix_spawn_file_actions_t`, if available, assuming a dynamic libc.\n        ///\n        /// Some platforms can set a new working directory for a spawned process in the\n        /// `posix_spawn` path. This function looks up the function pointer for adding\n        /// such an action to a `posix_spawn_file_actions_t` struct.\n        #[cfg(not(any(all(target_os = \"linux\", target_env = \"musl\"), target_os = \"cygwin\")))]\n        fn get_posix_spawn_addchdir() -> Option<PosixSpawnAddChdirFn> {\n            use crate::sys::weak::weak;\n\n            // POSIX.1-2024 standardizes this function:\n            // https://pubs.opengroup.org/onlinepubs/9799919799/functions/posix_spawn_file_actions_addchdir.html.\n            // The _np version is more widely available, though, so try that first.\n\n            weak!(\n                fn posix_spawn_file_actions_addchdir_np(\n                    file_actions: *mut libc::posix_spawn_file_actions_t,\n                    path: *const libc::c_char,\n                ) -> libc::c_int;\n            );\n\n            weak!(\n                fn posix_spawn_file_actions_addchdir(\n                    file_actions: *mut libc::posix_spawn_file_actions_t,\n                    path: *const libc::c_char,\n                ) -> libc::c_int;\n            );\n\n            posix_spawn_file_actions_addchdir_np\n                .get()\n                .or_else(|| posix_spawn_file_actions_addchdir.get())\n        }\n\n        /// Get the function pointer for adding a chdir action to a\n        /// `posix_spawn_file_actions_t`, if available, on platforms where the function\n        /// is known to exist.\n        ///\n        /// Weak symbol lookup doesn't work with statically linked libcs, so in cases\n        /// where static linking is possible we need to either check for the presence\n        /// of the symbol at compile time or know about it upfront.\n        ///\n        /// Cygwin doesn't support weak symbol, so just link it.\n        #[cfg(any(all(target_os = \"linux\", target_env = \"musl\"), target_os = \"cygwin\"))]\n        fn get_posix_spawn_addchdir() -> Option<PosixSpawnAddChdirFn> {\n            // Our minimum required musl supports this function, so we can just use it.\n            Some(libc::posix_spawn_file_actions_addchdir_np)\n        }\n\n        let addchdir = match self.get_cwd() {\n            Some(cwd) => {\n                if cfg!(target_vendor = \"apple\") {\n                    // There is a bug in macOS where a relative executable\n                    // path like \"../myprogram\" will cause `posix_spawn` to\n                    // successfully launch the program, but erroneously return\n                    // ENOENT when used with posix_spawn_file_actions_addchdir_np\n                    // which was introduced in macOS 10.15.\n                    if self.get_program_kind() == ProgramKind::Relative {\n                        return Ok(None);\n                    }\n                }\n                // Check for the availability of the posix_spawn addchdir\n                // function now. If it isn't available, bail and use the\n                // fork/exec path.\n                match get_posix_spawn_addchdir() {\n                    Some(f) => Some((f, cwd)),\n                    None => return Ok(None),\n                }\n            }\n            None => None,\n        };\n\n        let pgroup = self.get_pgroup();\n\n        struct PosixSpawnFileActions<'a>(&'a mut MaybeUninit<libc::posix_spawn_file_actions_t>);\n\n        impl Drop for PosixSpawnFileActions<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawn_file_actions_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        struct PosixSpawnattr<'a>(&'a mut MaybeUninit<libc::posix_spawnattr_t>);\n\n        impl Drop for PosixSpawnattr<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawnattr_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        unsafe {\n            let mut attrs = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawnattr_init(attrs.as_mut_ptr()))?;\n            let attrs = PosixSpawnattr(&mut attrs);\n\n            let mut flags = 0;\n\n            let mut file_actions = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawn_file_actions_init(file_actions.as_mut_ptr()))?;\n            let file_actions = PosixSpawnFileActions(&mut file_actions);\n\n            if let Some(fd) = stdio.stdin.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDIN_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stdout.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDOUT_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stderr.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDERR_FILENO,\n                ))?;\n            }\n            if let Some((f, cwd)) = addchdir {\n                cvt_nz(f(file_actions.0.as_mut_ptr(), cwd.as_ptr()))?;\n            }\n\n            if let Some(pgroup) = pgroup {\n                flags |= libc::POSIX_SPAWN_SETPGROUP;\n                cvt_nz(libc::posix_spawnattr_setpgroup(attrs.0.as_mut_ptr(), pgroup))?;\n            }\n\n            // Inherit the signal mask from this process rather than resetting it (i.e. do not call\n            // posix_spawnattr_setsigmask).\n\n            // If -Zon-broken-pipe is used, don't reset SIGPIPE to SIG_DFL.\n            // If -Zon-broken-pipe is not used, reset SIGPIPE to SIG_DFL for backward compatibility.\n            //\n            // -Zon-broken-pipe is an opportunity to change the default here.\n            if !on_broken_pipe_flag_used() {\n                let mut default_set = MaybeUninit::<libc::sigset_t>::uninit();\n                cvt(sigemptyset(default_set.as_mut_ptr()))?;\n                cvt(sigaddset(default_set.as_mut_ptr(), libc::SIGPIPE))?;\n                #[cfg(target_os = \"hurd\")]\n                {\n                    cvt(sigaddset(default_set.as_mut_ptr(), libc::SIGLOST))?;\n                }\n                cvt_nz(libc::posix_spawnattr_setsigdefault(\n                    attrs.0.as_mut_ptr(),\n                    default_set.as_ptr(),\n                ))?;\n                flags |= libc::POSIX_SPAWN_SETSIGDEF;\n            }\n\n            if self.get_setsid() {\n                cfg_select! {\n                    all(target_os = \"linux\", target_env = \"gnu\") => {\n                        flags |= libc::POSIX_SPAWN_SETSID;\n                    }\n                    _ => {\n                        return Ok(None);\n                    }\n                }\n            }\n\n            cvt_nz(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n\n            // Make sure we synchronize access to the global `environ` resource\n            let _env_lock = sys::env::env_read_lock();\n            let envp = envp.map(|c| c.as_ptr()).unwrap_or_else(|| *sys::env::environ() as *const _);\n\n            #[cfg(not(target_os = \"nto\"))]\n            let spawn_fn = libc::posix_spawnp;\n            #[cfg(target_os = \"nto\")]\n            let spawn_fn = retrying_libc_posix_spawnp;\n\n            #[cfg(target_os = \"linux\")]\n            if self.get_create_pidfd() && PIDFD_SUPPORTED.load(Ordering::Relaxed) == SPAWN {\n                let mut pidfd: libc::c_int = -1;\n                let spawn_res = pidfd_spawnp.get().unwrap()(\n                    &mut pidfd,\n                    self.get_program_cstr().as_ptr(),\n                    file_actions.0.as_ptr(),\n                    attrs.0.as_ptr(),\n                    self.get_argv().as_ptr() as *const _,\n                    envp as *const _,\n                );\n\n                let spawn_res = cvt_nz(spawn_res);\n                if let Err(ref e) = spawn_res\n                    && e.raw_os_error() == Some(libc::ENOSYS)\n                {\n                    PIDFD_SUPPORTED.store(FORK_EXEC, Ordering::Relaxed);\n                    return Ok(None);\n                }\n                spawn_res?;\n\n                let pid = match cvt(pidfd_getpid.get().unwrap()(pidfd)) {\n                    Ok(pid) => pid,\n                    Err(e) => {\n                        // The child has been spawned and we are holding its pidfd.\n                        // But we cannot obtain its pid even though pidfd_getpid support was verified earlier.\n                        // This might happen if libc can't open procfs because the file descriptor limit has been reached.\n                        libc::close(pidfd);\n                        return Err(Error::new(\n                            e.kind(),\n                            \"pidfd_spawnp succeeded but the child's PID could not be obtained\",\n                        ));\n                    }\n                };\n\n                return Ok(Some(Process::new(pid, pidfd)));\n            }\n\n            // Safety: -1 indicates we don't have a pidfd.\n            let mut p = Process::new(0, -1);\n\n            let spawn_res = spawn_fn(\n                &mut p.pid,\n                self.get_program_cstr().as_ptr(),\n                file_actions.0.as_ptr(),\n                attrs.0.as_ptr(),\n                self.get_argv().as_ptr() as *const _,\n                envp as *const _,\n            );\n\n            #[cfg(target_os = \"nto\")]\n            let spawn_res = spawn_res?;\n\n            cvt_nz(spawn_res)?;\n            Ok(Some(p))\n        }\n    }"
}