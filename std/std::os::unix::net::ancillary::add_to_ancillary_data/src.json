{
  "name": "std::os::unix::net::ancillary::add_to_ancillary_data",
  "span": "$library/std/src/os/unix/net/ancillary.rs:90:1: 96:10",
  "src": "fn add_to_ancillary_data<T>(\n    buffer: &mut [u8],\n    length: &mut usize,\n    source: &[T],\n    cmsg_level: libc::c_int,\n    cmsg_type: libc::c_int,\n) -> bool {\n    #[cfg(not(target_os = \"freebsd\"))]\n    let cmsg_size = source.len().checked_mul(size_of::<T>());\n    #[cfg(target_os = \"freebsd\")]\n    let cmsg_size = Some(unsafe { libc::SOCKCRED2SIZE(1) });\n\n    let source_len = if let Some(source_len) = cmsg_size {\n        if let Ok(source_len) = u32::try_from(source_len) {\n            source_len\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    };\n\n    unsafe {\n        let additional_space = libc::CMSG_SPACE(source_len) as usize;\n\n        let new_length = if let Some(new_length) = additional_space.checked_add(*length) {\n            new_length\n        } else {\n            return false;\n        };\n\n        if new_length > buffer.len() {\n            return false;\n        }\n\n        buffer[*length..new_length].fill(0);\n\n        *length = new_length;\n\n        let mut msg: libc::msghdr = zeroed();\n        msg.msg_control = buffer.as_mut_ptr().cast();\n        msg.msg_controllen = *length as _;\n\n        let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n        let mut previous_cmsg = cmsg;\n        while !cmsg.is_null() {\n            previous_cmsg = cmsg;\n            cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n\n            // Most operating systems, but not Linux or emscripten, return the previous pointer\n            // when its length is zero. Therefore, check if the previous pointer is the same as\n            // the current one.\n            if eq(cmsg, previous_cmsg) {\n                break;\n            }\n        }\n\n        if previous_cmsg.is_null() {\n            return false;\n        }\n\n        (*previous_cmsg).cmsg_level = cmsg_level;\n        (*previous_cmsg).cmsg_type = cmsg_type;\n        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as _;\n\n        let data = libc::CMSG_DATA(previous_cmsg).cast();\n\n        libc::memcpy(data, source.as_ptr().cast(), source_len as usize);\n    }\n    true\n}"
}