{
  "name": "std::sys::pal::unix::pipe::anon_pipe",
  "span": "$library/std/src/sys/pal/unix/pipe.rs:15:1: 15:55",
  "src": "pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n    let mut fds = [0; 2];\n\n    // The only known way right now to create atomically set the CLOEXEC flag is\n    // to use the `pipe2` syscall. This was added to Linux in 2.6.27, glibc 2.9\n    // and musl 0.9.3, and some other targets also have it.\n    cfg_select! {\n        any(\n            target_os = \"android\",\n            target_os = \"dragonfly\",\n            target_os = \"freebsd\",\n            target_os = \"hurd\",\n            target_os = \"illumos\",\n            target_os = \"linux\",\n            target_os = \"netbsd\",\n            target_os = \"openbsd\",\n            target_os = \"cygwin\",\n            target_os = \"redox\"\n        ) => {\n            unsafe {\n                cvt(libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC))?;\n                Ok((AnonPipe(FileDesc::from_raw_fd(fds[0])), AnonPipe(FileDesc::from_raw_fd(fds[1]))))\n            }\n        }\n        _ => {\n            unsafe {\n                cvt(libc::pipe(fds.as_mut_ptr()))?;\n\n                let fd0 = FileDesc::from_raw_fd(fds[0]);\n                let fd1 = FileDesc::from_raw_fd(fds[1]);\n                fd0.set_cloexec()?;\n                fd1.set_cloexec()?;\n                Ok((AnonPipe(fd0), AnonPipe(fd1)))\n            }\n        }\n    }\n}"
}