{
  "name": "std::sync::mpmc::array::Channel::<T>::send",
  "span": "$library/std/src/sync/mpmc/array.rs:319:5: 323:41",
  "src": "pub(crate) fn send(\n        &self,\n        msg: T,\n        deadline: Option<Instant>,\n    ) -> Result<(), SendTimeoutError<T>> {\n        let token = &mut Token::default();\n        loop {\n            // Try sending a message.\n            if self.start_send(token) {\n                let res = unsafe { self.write(token, msg) };\n                return res.map_err(SendTimeoutError::Disconnected);\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(SendTimeoutError::Timeout(msg));\n                }\n            }\n\n            Context::with(|cx| {\n                // Prepare for blocking until a receiver wakes us up.\n                let oper = Operation::hook(token);\n                self.senders.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_full() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                // SAFETY: the context belongs to the current thread.\n                let sel = unsafe { cx.wait_until(deadline) };\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.senders.unregister(oper).unwrap();\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }"
}