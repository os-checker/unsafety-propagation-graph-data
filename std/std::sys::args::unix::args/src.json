{
  "name": "std::sys::args::unix::args",
  "span": "$library/std/src/sys/args/unix.rs:21:1: 21:22",
  "src": "pub fn args() -> Args {\n    let (argc, argv) = imp::argc_argv();\n\n    let mut vec = Vec::with_capacity(argc as usize);\n\n    for i in 0..argc {\n        // SAFETY: `argv` is non-null if `argc` is positive, and it is\n        // guaranteed to be at least as long as `argc`, so reading from it\n        // should be safe.\n        let ptr = unsafe { argv.offset(i).read() };\n\n        // Some C commandline parsers (e.g. GLib and Qt) are replacing already\n        // handled arguments in `argv` with `NULL` and move them to the end.\n        //\n        // Since they can't directly ensure updates to `argc` as well, this\n        // means that `argc` might be bigger than the actual number of\n        // non-`NULL` pointers in `argv` at this point.\n        //\n        // To handle this we simply stop iterating at the first `NULL`\n        // argument. `argv` is also guaranteed to be `NULL`-terminated so any\n        // non-`NULL` arguments after the first `NULL` can safely be ignored.\n        if ptr.is_null() {\n            // NOTE: On Apple platforms, `-[NSProcessInfo arguments]` does not\n            // stop iterating here, but instead `continue`, always iterating\n            // up until it reached `argc`.\n            //\n            // This difference will only matter in very specific circumstances\n            // where `argc`/`argv` have been modified, but in unexpected ways,\n            // so it likely doesn't really matter which option we choose.\n            // See the following PR for further discussion:\n            // <https://github.com/rust-lang/rust/pull/125225>\n            break;\n        }\n\n        // SAFETY: Just checked that the pointer is not NULL, and arguments\n        // are otherwise guaranteed to be valid C strings.\n        let cstr = unsafe { CStr::from_ptr(ptr) };\n        vec.push(OsStringExt::from_vec(cstr.to_bytes().to_vec()));\n    }\n\n    Args::new(vec)\n}"
}