{
  "name": "std::sys::net::hostname::unix::hostname",
  "span": "$library/std/src/sys/net/hostname/unix.rs:6:1: 6:42",
  "src": "pub fn hostname() -> io::Result<OsString> {\n    // Query the system for the maximum host name length.\n    let host_name_max = match unsafe { libc::sysconf(libc::_SC_HOST_NAME_MAX) } {\n        // If this fails (possibly because there is no maximum length), then\n        // assume a maximum length of _POSIX_HOST_NAME_MAX (255).\n        -1 => 255,\n        max => max as usize,\n    };\n\n    // Reserve space for the nul terminator too.\n    let mut buf = Vec::<u8>::try_with_capacity(host_name_max + 1)?;\n    loop {\n        // SAFETY: `buf.capacity()` bytes of `buf` are writable.\n        let r = unsafe { libc::gethostname(buf.as_mut_ptr().cast(), buf.capacity()) };\n        match (r != 0).then(errno) {\n            None => {\n                // Unfortunately, the UNIX specification says that the name will\n                // be truncated if it does not fit in the buffer, without returning\n                // an error. As additionally, the truncated name may still be null-\n                // terminated, there is no reliable way to  detect truncation.\n                // Fortunately, most platforms ignore what the specification says\n                // and return an error (mostly ENAMETOOLONG). Should that not be\n                // the case, the following detects truncation if the null-terminator\n                // was omitted. Note that this check does not impact performance at\n                // all as we need to find the length of the string anyways.\n                //\n                // Use `strnlen` as it does not place an initialization requirement\n                // on the bytes after the nul terminator.\n                //\n                // SAFETY: `buf.capacity()` bytes of `buf` are accessible, and are\n                // initialized up to and including a possible nul terminator.\n                let len = unsafe { libc::strnlen(buf.as_ptr().cast(), buf.capacity()) };\n                if len < buf.capacity() {\n                    // If the string is nul-terminated, we assume that is has not\n                    // been truncated, as the capacity *should be* enough to hold\n                    // `HOST_NAME_MAX` bytes.\n                    // SAFETY: `len + 1` bytes have been initialized (we exclude\n                    // the nul terminator from the string).\n                    unsafe { buf.set_len(len) };\n                    return Ok(OsString::from_vec(buf));\n                }\n            }\n            // As `buf.capacity()` is always less than or equal to `isize::MAX`\n            // (Rust allocations cannot exceed that limit), the only way `EINVAL`\n            // can be returned is if the system uses `EINVAL` to report that the\n            // name does not fit in the provided buffer. In that case (or in the\n            // case of `ENAMETOOLONG`), resize the buffer and try again.\n            Some(libc::EINVAL | libc::ENAMETOOLONG) => {}\n            // Other error codes (e.g. EPERM) have nothing to do with the buffer\n            // size and should be returned to the user.\n            Some(err) => return Err(io::Error::from_raw_os_error(err)),\n        }\n\n        // Resize the buffer (according to `Vec`'s resizing rules) and try again.\n        buf.try_reserve(buf.capacity() + 1)?;\n    }\n}"
}