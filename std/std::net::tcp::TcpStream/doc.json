{
  "name": "std::net::tcp::TcpStream",
  "span": "$library/std/src/net/tcp.rs:63:1: 63:21",
  "doc": " A TCP stream between a local and a remote socket.\n\n After creating a `TcpStream` by either [`connect`]ing to a remote host or\n [`accept`]ing a connection on a [`TcpListener`], data can be transmitted\n by [reading] and [writing] to it.\n\n The connection will be closed when the value is dropped. The reading and writing\n portions of the connection can also be shut down individually with the [`shutdown`]\n method.\n\n The Transmission Control Protocol is specified in [IETF RFC 793].\n\n [`accept`]: TcpListener::accept\n [`connect`]: TcpStream::connect\n [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n [reading]: Read\n [`shutdown`]: TcpStream::shutdown\n [writing]: Write\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::net::TcpStream;\n\n fn main() -> std::io::Result<()> {\n     let mut stream = TcpStream::connect(\"127.0.0.1:34254\")?;\n\n     stream.write(&[1])?;\n     stream.read(&mut [0; 128])?;\n     Ok(())\n } // the stream is closed here\n ```\n\n # Platform-specific Behavior\n\n On Unix, writes to the underlying socket in `SOCK_STREAM` mode are made with\n `MSG_NOSIGNAL` flag. This suppresses the emission of the  `SIGPIPE` signal when writing\n to disconnected socket. In some cases, getting a `SIGPIPE` would trigger process termination.\n"
}