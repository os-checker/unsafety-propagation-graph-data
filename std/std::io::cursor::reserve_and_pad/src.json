{
  "name": "std::io::cursor::reserve_and_pad",
  "span": "$library/std/src/io/cursor.rs:464:1: 468:23",
  "src": "fn reserve_and_pad<A: Allocator>(\n    pos_mut: &mut u64,\n    vec: &mut Vec<u8, A>,\n    buf_len: usize,\n) -> io::Result<usize> {\n    let pos: usize = (*pos_mut).try_into().map_err(|_| {\n        io::const_error!(\n            ErrorKind::InvalidInput,\n            \"cursor position exceeds maximum possible vector length\",\n        )\n    })?;\n\n    // For safety reasons, we don't want these numbers to overflow\n    // otherwise our allocation won't be enough\n    let desired_cap = pos.saturating_add(buf_len);\n    if desired_cap > vec.capacity() {\n        // We want our vec's total capacity\n        // to have room for (pos+buf_len) bytes. Reserve allocates\n        // based on additional elements from the length, so we need to\n        // reserve the difference\n        vec.reserve(desired_cap - vec.len());\n    }\n    // Pad if pos is above the current len.\n    if pos > vec.len() {\n        let diff = pos - vec.len();\n        // Unfortunately, `resize()` would suffice but the optimiser does not\n        // realise the `reserve` it does can be eliminated. So we do it manually\n        // to eliminate that extra branch\n        let spare = vec.spare_capacity_mut();\n        debug_assert!(spare.len() >= diff);\n        // Safety: we have allocated enough capacity for this.\n        // And we are only writing, not reading\n        unsafe {\n            spare.get_unchecked_mut(..diff).fill(core::mem::MaybeUninit::new(0));\n            vec.set_len(pos);\n        }\n    }\n\n    Ok(pos)\n}"
}