{
  "name": "std::io::Read::read_array",
  "span": "$library/std/src/io/mod.rs:1249:5: 1251:21",
  "doc": " Read and return a fixed array of bytes from this source.\n\n This function uses an array sized based on a const generic size known at compile time. You\n can specify the size with turbofish (`reader.read_array::<8>()`), or let type inference\n determine the number of bytes needed based on how the return value gets used. For instance,\n this function works well with functions like [`u64::from_le_bytes`] to turn an array of\n bytes into an integer of the same size.\n\n Like `read_exact`, if this function encounters an \"end of file\" before reading the desired\n number of bytes, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n\n ```\n #![feature(read_array)]\n use std::io::Cursor;\n use std::io::prelude::*;\n\n fn main() -> std::io::Result<()> {\n     let mut buf = Cursor::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 4, 3, 2]);\n     let x = u64::from_le_bytes(buf.read_array()?);\n     let y = u32::from_be_bytes(buf.read_array()?);\n     let z = u16::from_be_bytes(buf.read_array()?);\n     assert_eq!(x, 0x807060504030201);\n     assert_eq!(y, 0x9080706);\n     assert_eq!(z, 0x504);\n     Ok(())\n }\n ```\n"
}