{
  "name": "std::sys::os_str::bytes::Slice::check_public_boundary",
  "span": "$library/std/src/sys/os_str/bytes.rs:258:5: 258:54",
  "src": "pub fn check_public_boundary(&self, index: usize) {\n        if index == 0 || index == self.inner.len() {\n            return;\n        }\n        if index < self.inner.len()\n            && (self.inner[index - 1].is_ascii() || self.inner[index].is_ascii())\n        {\n            return;\n        }\n\n        slow_path(&self.inner, index);\n\n        /// We're betting that typical splits will involve an ASCII character.\n        ///\n        /// Putting the expensive checks in a separate function generates notably\n        /// better assembly.\n        #[track_caller]\n        #[inline(never)]\n        fn slow_path(bytes: &[u8], index: usize) {\n            let (before, after) = bytes.split_at(index);\n\n            // UTF-8 takes at most 4 bytes per codepoint, so we don't\n            // need to check more than that.\n            let after = after.get(..4).unwrap_or(after);\n            match str::from_utf8(after) {\n                Ok(_) => return,\n                Err(err) if err.valid_up_to() != 0 => return,\n                Err(_) => (),\n            }\n\n            for len in 2..=4.min(index) {\n                let before = &before[index - len..];\n                if str::from_utf8(before).is_ok() {\n                    return;\n                }\n            }\n\n            panic!(\"byte index {index} is not an OsStr boundary\");\n        }\n    }"
}