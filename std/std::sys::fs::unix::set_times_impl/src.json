{
  "name": "std::sys::fs::unix::set_times_impl",
  "span": "$library/std/src/sys/fs/unix.rs:2139:1: 2139:87",
  "src": "fn set_times_impl(p: &CStr, times: FileTimes, follow_symlinks: bool) -> io::Result<()> {\n    cfg_select! {\n       any(target_os = \"redox\", target_os = \"espidf\", target_os = \"horizon\", target_os = \"nuttx\") => {\n            let _ = (p, times, follow_symlinks);\n            Err(io::const_error!(\n                io::ErrorKind::Unsupported,\n                \"setting file times not supported\",\n            ))\n       }\n       target_vendor = \"apple\" => {\n            // Apple platforms use setattrlist which supports setting times on symlinks\n            let ta = TimesAttrlist::from_times(&times)?;\n            let options = if follow_symlinks {\n                0\n            } else {\n                libc::FSOPT_NOFOLLOW\n            };\n\n            cvt(unsafe { libc::setattrlist(\n                p.as_ptr(),\n                ta.attrlist(),\n                ta.times_buf(),\n                ta.times_buf_size(),\n                options as u32\n            ) })?;\n            Ok(())\n       }\n       target_os = \"android\" => {\n            let times = [file_time_to_timespec(times.accessed)?, file_time_to_timespec(times.modified)?];\n            let flags = if follow_symlinks { 0 } else { libc::AT_SYMLINK_NOFOLLOW };\n            // utimensat requires Android API level 19\n            cvt(unsafe {\n                weak!(\n                    fn utimensat(dirfd: c_int, path: *const libc::c_char, times: *const libc::timespec, flags: c_int) -> c_int;\n                );\n                match utimensat.get() {\n                    Some(utimensat) => utimensat(libc::AT_FDCWD, p.as_ptr(), times.as_ptr(), flags),\n                    None => return Err(io::const_error!(\n                        io::ErrorKind::Unsupported,\n                        \"setting file times requires Android API level >= 19\",\n                    )),\n                }\n            })?;\n            Ok(())\n       }\n       _ => {\n            let flags = if follow_symlinks { 0 } else { libc::AT_SYMLINK_NOFOLLOW };\n            #[cfg(all(target_os = \"linux\", target_env = \"gnu\", target_pointer_width = \"32\", not(target_arch = \"riscv32\")))]\n            {\n                use crate::sys::{time::__timespec64, weak::weak};\n\n                // Added in glibc 2.34\n                weak!(\n                    fn __utimensat64(dirfd: c_int, path: *const c_char, times: *const __timespec64, flags: c_int) -> c_int;\n                );\n\n                if let Some(utimensat64) = __utimensat64.get() {\n                    let to_timespec = |time: Option<SystemTime>| time.map(|time| time.t.to_timespec64())\n                        .unwrap_or(__timespec64::new(0, libc::UTIME_OMIT as _));\n                    let times = [to_timespec(times.accessed), to_timespec(times.modified)];\n                    cvt(unsafe { utimensat64(libc::AT_FDCWD, p.as_ptr(), times.as_ptr(), flags) })?;\n                    return Ok(());\n                }\n            }\n            let times = [file_time_to_timespec(times.accessed)?, file_time_to_timespec(times.modified)?];\n            cvt(unsafe { libc::utimensat(libc::AT_FDCWD, p.as_ptr(), times.as_ptr(), flags) })?;\n            Ok(())\n         }\n    }\n}"
}