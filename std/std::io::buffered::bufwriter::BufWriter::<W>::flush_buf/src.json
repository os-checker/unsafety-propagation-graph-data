{
  "name": "std::io::buffered::bufwriter::BufWriter::<W>::flush_buf",
  "span": "$library/std/src/io/buffered/bufwriter.rs:195:5: 195:64",
  "src": "pub(in crate::io) fn flush_buf(&mut self) -> io::Result<()> {\n        /// Helper struct to ensure the buffer is updated after all the writes\n        /// are complete. It tracks the number of written bytes and drains them\n        /// all from the front of the buffer when dropped.\n        struct BufGuard<'a> {\n            buffer: &'a mut Vec<u8>,\n            written: usize,\n        }\n\n        impl<'a> BufGuard<'a> {\n            fn new(buffer: &'a mut Vec<u8>) -> Self {\n                Self { buffer, written: 0 }\n            }\n\n            /// The unwritten part of the buffer\n            fn remaining(&self) -> &[u8] {\n                &self.buffer[self.written..]\n            }\n\n            /// Flag some bytes as removed from the front of the buffer\n            fn consume(&mut self, amt: usize) {\n                self.written += amt;\n            }\n\n            /// true if all of the bytes have been written\n            fn done(&self) -> bool {\n                self.written >= self.buffer.len()\n            }\n        }\n\n        impl Drop for BufGuard<'_> {\n            fn drop(&mut self) {\n                if self.written > 0 {\n                    self.buffer.drain(..self.written);\n                }\n            }\n        }\n\n        let mut guard = BufGuard::new(&mut self.buf);\n        while !guard.done() {\n            self.panicked = true;\n            let r = self.inner.write(guard.remaining());\n            self.panicked = false;\n\n            match r {\n                Ok(0) => {\n                    return Err(io::const_error!(\n                        ErrorKind::WriteZero,\n                        \"failed to write the buffered data\",\n                    ));\n                }\n                Ok(n) => guard.consume(n),\n                Err(ref e) if e.is_interrupted() => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }"
}