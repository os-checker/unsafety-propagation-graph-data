{
  "name": "std::net::udp::UdpSocket",
  "span": "$library/std/src/net/udp.rs:67:1: 67:21",
  "doc": " A UDP socket.\n\n After creating a `UdpSocket` by [`bind`]ing it to a socket address, data can be\n [sent to] and [received from] any other socket address.\n\n Although UDP is a connectionless protocol, this implementation provides an interface\n to set an address where data should be sent and received from. After setting a remote\n address with [`connect`], data can be sent to and received from that address with\n [`send`] and [`recv`].\n\n As stated in the User Datagram Protocol's specification in [IETF RFC 768], UDP is\n an unordered, unreliable protocol; refer to [`TcpListener`] and [`TcpStream`] for TCP\n primitives.\n\n [`bind`]: UdpSocket::bind\n [`connect`]: UdpSocket::connect\n [IETF RFC 768]: https://tools.ietf.org/html/rfc768\n [`recv`]: UdpSocket::recv\n [received from]: UdpSocket::recv_from\n [`send`]: UdpSocket::send\n [sent to]: UdpSocket::send_to\n [`TcpListener`]: crate::net::TcpListener\n [`TcpStream`]: crate::net::TcpStream\n\n # Examples\n\n ```no_run\n use std::net::UdpSocket;\n\n fn main() -> std::io::Result<()> {\n     {\n         let socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n\n         // Receives a single datagram message on the socket. If `buf` is too small to hold\n         // the message, it will be cut off.\n         let mut buf = [0; 10];\n         let (amt, src) = socket.recv_from(&mut buf)?;\n\n         // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n         let buf = &mut buf[..amt];\n         buf.reverse();\n         socket.send_to(buf, &src)?;\n     } // the socket is closed here\n     Ok(())\n }\n ```\n"
}