{
  "name": "std::sys::pal::unix::stack_overflow::thread_info::with_current_info",
  "span": "$library/std/src/sys/pal/unix/stack_overflow/thread_info.rs:62:1: 62:75",
  "src": "pub fn with_current_info<R>(f: impl FnOnce(Option<&ThreadInfo>) -> R) -> R {\n    let this = errno_location().addr();\n    let mut attempt = 0;\n    let _guard = loop {\n        // If we are just spinning endlessly, it's very likely that the thread\n        // modifying the thread info map has a lower priority than us and will\n        // not continue until we stop running. Just give up in that case.\n        if attempt == 10_000_000 {\n            rtprintpanic!(\"deadlock in SIGSEGV handler\");\n            return f(None);\n        }\n\n        match SPIN_LOCK.compare_exchange(0, this, Ordering::Acquire, Ordering::Relaxed) {\n            Ok(_) => break UnlockOnDrop,\n            Err(owner) if owner == this => {\n                rtabort!(\"a thread received SIGSEGV while modifying its stack overflow information\")\n            }\n            // Spin until the lock can be acquired â€“ there is nothing better to\n            // do. This is unfortunately a priority hole, but a stack overflow\n            // is a fatal error anyway.\n            Err(_) => {\n                spin_loop();\n                attempt += 1;\n            }\n        }\n    };\n\n    // SAFETY: we own the spin lock, so `THREAD_INFO` cannot not be aliased.\n    let thread_info = unsafe { &*(&raw const THREAD_INFO) };\n    f(thread_info.get(&this))\n}"
}