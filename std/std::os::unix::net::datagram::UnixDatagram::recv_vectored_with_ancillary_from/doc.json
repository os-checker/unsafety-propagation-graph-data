{
  "name": "std::os::unix::net::datagram::UnixDatagram::recv_vectored_with_ancillary_from",
  "span": "$library/std/src/os/unix/net/datagram.rs:439:5: 443:47",
  "doc": " Receives data and ancillary data from socket.\n\n On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.\n\n # Examples\n\n #![feature(unix_socket_ancillary_data)]\n use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n use std::io::IoSliceMut;\n\n fn main() -> std::io::Result<()> {\n     let sock = UnixDatagram::unbound()?;\n     let mut buf1 = [1; 8];\n     let mut buf2 = [2; 16];\n     let mut buf3 = [3; 8];\n     let mut bufs = &mut [\n         IoSliceMut::new(&mut buf1),\n         IoSliceMut::new(&mut buf2),\n         IoSliceMut::new(&mut buf3),\n     ][..];\n     let mut fds = [0; 8];\n     let mut ancillary_buffer = [0; 128];\n     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n     let (size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, &mut ancillary)?;\n     println!(\"received {size}\");\n     for ancillary_result in ancillary.messages() {\n         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n             for fd in scm_rights {\n                 println!(\"receive file descriptor: {fd}\");\n             }\n         }\n     }\n     Ok(())\n }\n ```\n"
}