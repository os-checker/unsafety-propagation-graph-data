{
  "name": "std::io::default_write_fmt",
  "span": "$library/std/src/io/mod.rs:590:1: 593:16",
  "src": "pub(crate) fn default_write_fmt<W: Write + ?Sized>(\n    this: &mut W,\n    args: fmt::Arguments<'_>,\n) -> Result<()> {\n    // Create a shim which translates a `Write` to a `fmt::Write` and saves off\n    // I/O errors, instead of discarding them.\n    struct Adapter<'a, T: ?Sized + 'a> {\n        inner: &'a mut T,\n        error: Result<()>,\n    }\n\n    impl<T: Write + ?Sized> fmt::Write for Adapter<'_, T> {\n        fn write_str(&mut self, s: &str) -> fmt::Result {\n            match self.inner.write_all(s.as_bytes()) {\n                Ok(()) => Ok(()),\n                Err(e) => {\n                    self.error = Err(e);\n                    Err(fmt::Error)\n                }\n            }\n        }\n    }\n\n    let mut output = Adapter { inner: this, error: Ok(()) };\n    match fmt::write(&mut output, args) {\n        Ok(()) => Ok(()),\n        Err(..) => {\n            // Check whether the error came from the underlying `Write`.\n            if output.error.is_err() {\n                output.error\n            } else {\n                // This shouldn't happen: the underlying stream did not error,\n                // but somehow the formatter still errored?\n                panic!(\n                    \"a formatting trait implementation returned an error when the underlying stream did not\"\n                );\n            }\n        }\n    }\n}"
}