{
  "name": "std::sys::pal::unix::stack_overflow::imp::get_stack",
  "span": "$library/std/src/sys/pal/unix/stack_overflow.rs:205:5: 205:43",
  "src": "unsafe fn get_stack() -> libc::stack_t {\n        // OpenBSD requires this flag for stack mapping\n        // otherwise the said mapping will fail as a no-op on most systems\n        // and has a different meaning on FreeBSD\n        #[cfg(any(\n            target_os = \"openbsd\",\n            target_os = \"netbsd\",\n            target_os = \"linux\",\n            target_os = \"dragonfly\",\n        ))]\n        let flags = MAP_PRIVATE | MAP_ANON | libc::MAP_STACK;\n        #[cfg(not(any(\n            target_os = \"openbsd\",\n            target_os = \"netbsd\",\n            target_os = \"linux\",\n            target_os = \"dragonfly\",\n        )))]\n        let flags = MAP_PRIVATE | MAP_ANON;\n\n        let sigstack_size = sigstack_size();\n        let page_size = PAGE_SIZE.load(Ordering::Relaxed);\n\n        let stackp = mmap64(\n            ptr::null_mut(),\n            sigstack_size + page_size,\n            PROT_READ | PROT_WRITE,\n            flags,\n            -1,\n            0,\n        );\n        if stackp == MAP_FAILED {\n            panic!(\"failed to allocate an alternative stack: {}\", io::Error::last_os_error());\n        }\n        let guard_result = libc::mprotect(stackp, page_size, PROT_NONE);\n        if guard_result != 0 {\n            panic!(\"failed to set up alternative stack guard page: {}\", io::Error::last_os_error());\n        }\n        let stackp = stackp.add(page_size);\n\n        libc::stack_t { ss_sp: stackp, ss_flags: 0, ss_size: sigstack_size }\n    }"
}