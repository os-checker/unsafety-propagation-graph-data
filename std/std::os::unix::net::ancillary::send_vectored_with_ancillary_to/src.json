{
  "name": "std::os::unix::net::ancillary::send_vectored_with_ancillary_to",
  "span": "$library/std/src/os/unix/net/ancillary.rs:63:1: 68:23",
  "src": "pub(super) fn send_vectored_with_ancillary_to(\n    socket: &Socket,\n    path: Option<&Path>,\n    bufs: &[IoSlice<'_>],\n    ancillary: &mut SocketAncillary<'_>,\n) -> io::Result<usize> {\n    unsafe {\n        let (mut msg_name, msg_namelen) =\n            if let Some(path) = path { sockaddr_un(path)? } else { (zeroed(), 0) };\n\n        let mut msg: libc::msghdr = zeroed();\n        msg.msg_name = (&raw mut msg_name) as *mut _;\n        msg.msg_namelen = msg_namelen;\n        msg.msg_iov = bufs.as_ptr() as *mut _;\n        msg.msg_iovlen = bufs.len() as _;\n        msg.msg_controllen = ancillary.length as _;\n        // macos requires that the control pointer is null when the len is 0.\n        if msg.msg_controllen > 0 {\n            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n        }\n\n        ancillary.truncated = false;\n\n        socket.send_msg(&mut msg)\n    }\n}"
}