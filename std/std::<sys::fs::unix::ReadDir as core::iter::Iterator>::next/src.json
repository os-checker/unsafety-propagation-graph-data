{
  "name": "std::<sys::fs::unix::ReadDir as core::iter::Iterator>::next",
  "span": "$library/std/src/sys/fs/unix.rs:719:5: 719:55",
  "src": "fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        use crate::sys::os::{errno, set_errno};\n\n        if self.end_of_stream {\n            return None;\n        }\n\n        unsafe {\n            loop {\n                // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n                // readdir_r() is. However, readdir_r() cannot correctly handle platforms\n                // with unlimited or variable NAME_MAX. Many modern platforms guarantee\n                // thread safety for readdir() as long an individual DIR* is not accessed\n                // concurrently, which is sufficient for Rust.\n                set_errno(0);\n                let entry_ptr: *const dirent64 = readdir64(self.inner.dirp.0);\n                if entry_ptr.is_null() {\n                    // We either encountered an error, or reached the end. Either way,\n                    // the next call to next() should return None.\n                    self.end_of_stream = true;\n\n                    // To distinguish between errors and end-of-directory, we had to clear\n                    // errno beforehand to check for an error now.\n                    return match errno() {\n                        0 => None,\n                        e => Some(Err(Error::from_raw_os_error(e))),\n                    };\n                }\n\n                // The dirent64 struct is a weird imaginary thing that isn't ever supposed\n                // to be worked with by value. Its trailing d_name field is declared\n                // variously as [c_char; 256] or [c_char; 1] on different systems but\n                // either way that size is meaningless; only the offset of d_name is\n                // meaningful. The dirent64 pointers that libc returns from readdir64 are\n                // allowed to point to allocations smaller _or_ LARGER than implied by the\n                // definition of the struct.\n                //\n                // As such, we need to be even more careful with dirent64 than if its\n                // contents were \"simply\" partially initialized data.\n                //\n                // Like for uninitialized contents, converting entry_ptr to `&dirent64`\n                // would not be legal. However, we can use `&raw const (*entry_ptr).d_name`\n                // to refer the fields individually, because that operation is equivalent\n                // to `byte_offset` and thus does not require the full extent of `*entry_ptr`\n                // to be in bounds of the same allocation, only the offset of the field\n                // being referenced.\n\n                // d_name is guaranteed to be null-terminated.\n                let name = CStr::from_ptr((&raw const (*entry_ptr).d_name).cast());\n                let name_bytes = name.to_bytes();\n                if name_bytes == b\".\" || name_bytes == b\"..\" {\n                    continue;\n                }\n\n                // When loading from a field, we can skip the `&raw const`; `(*entry_ptr).d_ino` as\n                // a value expression will do the right thing: `byte_offset` to the field and then\n                // only access those bytes.\n                #[cfg(not(target_os = \"vita\"))]\n                let entry = dirent64_min {\n                    #[cfg(target_os = \"freebsd\")]\n                    d_ino: (*entry_ptr).d_fileno,\n                    #[cfg(not(target_os = \"freebsd\"))]\n                    d_ino: (*entry_ptr).d_ino as u64,\n                    #[cfg(not(any(\n                        target_os = \"solaris\",\n                        target_os = \"illumos\",\n                        target_os = \"aix\",\n                        target_os = \"nto\",\n                    )))]\n                    d_type: (*entry_ptr).d_type as u8,\n                };\n\n                #[cfg(target_os = \"vita\")]\n                let entry = dirent64_min { d_ino: 0u64 };\n\n                return Some(Ok(DirEntry {\n                    entry,\n                    name: name.to_owned(),\n                    dir: Arc::clone(&self.inner),\n                }));\n            }\n        }\n    }"
}