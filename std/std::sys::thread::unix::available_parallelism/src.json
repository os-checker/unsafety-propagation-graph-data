{
  "name": "std::sys::thread::unix::available_parallelism",
  "span": "$library/std/src/sys/thread/unix.rs:146:1: 146:61",
  "src": "pub fn available_parallelism() -> io::Result<NonZero<usize>> {\n    cfg_select! {\n        any(\n            target_os = \"android\",\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"linux\",\n            target_os = \"aix\",\n            target_vendor = \"apple\",\n            target_os = \"cygwin\",\n        ) => {\n            #[allow(unused_assignments)]\n            #[allow(unused_mut)]\n            let mut quota = usize::MAX;\n\n            #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n            {\n                quota = cgroups::quota().max(1);\n                let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n                unsafe {\n                    if libc::sched_getaffinity(0, size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n                        let count = libc::CPU_COUNT(&set) as usize;\n                        let count = count.min(quota);\n\n                        // According to sched_getaffinity's API it should always be non-zero, but\n                        // some old MIPS kernels were buggy and zero-initialized the mask if\n                        // none was explicitly set.\n                        // In that case we use the sysconf fallback.\n                        if let Some(count) = NonZero::new(count) {\n                            return Ok(count)\n                        }\n                    }\n                }\n            }\n            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n                -1 => Err(io::Error::last_os_error()),\n                0 => Err(io::Error::UNKNOWN_THREAD_COUNT),\n                cpus => {\n                    let count = cpus as usize;\n                    // Cover the unusual situation where we were able to get the quota but not the affinity mask\n                    let count = count.min(quota);\n                    Ok(unsafe { NonZero::new_unchecked(count) })\n                }\n            }\n        }\n        any(\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\",\n           target_os = \"openbsd\",\n           target_os = \"netbsd\",\n        ) => {\n            use crate::ptr;\n\n            #[cfg(target_os = \"freebsd\")]\n            {\n                let mut set: libc::cpuset_t = unsafe { mem::zeroed() };\n                unsafe {\n                    if libc::cpuset_getaffinity(\n                        libc::CPU_LEVEL_WHICH,\n                        libc::CPU_WHICH_PID,\n                        -1,\n                        size_of::<libc::cpuset_t>(),\n                        &mut set,\n                    ) == 0 {\n                        let count = libc::CPU_COUNT(&set) as usize;\n                        if count > 0 {\n                            return Ok(NonZero::new_unchecked(count));\n                        }\n                    }\n                }\n            }\n\n            #[cfg(target_os = \"netbsd\")]\n            {\n                unsafe {\n                    let set = libc::_cpuset_create();\n                    if !set.is_null() {\n                        let mut count: usize = 0;\n                        if libc::pthread_getaffinity_np(libc::pthread_self(), libc::_cpuset_size(set), set) == 0 {\n                            for i in 0..libc::cpuid_t::MAX {\n                                match libc::_cpuset_isset(i, set) {\n                                    -1 => break,\n                                    0 => continue,\n                                    _ => count = count + 1,\n                                }\n                            }\n                        }\n                        libc::_cpuset_destroy(set);\n                        if let Some(count) = NonZero::new(count) {\n                            return Ok(count);\n                        }\n                    }\n                }\n            }\n\n            let mut cpus: libc::c_uint = 0;\n            let mut cpus_size = size_of_val(&cpus);\n\n            unsafe {\n                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n            }\n\n            // Fallback approach in case of errors or no hardware threads.\n            if cpus < 1 {\n                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n                let res = unsafe {\n                    libc::sysctl(\n                        mib.as_mut_ptr(),\n                        2,\n                        (&raw mut cpus) as *mut _,\n                        (&raw mut cpus_size) as *mut _,\n                        ptr::null_mut(),\n                        0,\n                    )\n                };\n\n                // Handle errors if any.\n                if res == -1 {\n                    return Err(io::Error::last_os_error());\n                } else if cpus == 0 {\n                    return Err(io::Error::UNKNOWN_THREAD_COUNT);\n                }\n            }\n\n            Ok(unsafe { NonZero::new_unchecked(cpus as usize) })\n        }\n        target_os = \"nto\" => {\n            unsafe {\n                use libc::_syspage_ptr;\n                if _syspage_ptr.is_null() {\n                    Err(io::const_error!(io::ErrorKind::NotFound, \"no syspage available\"))\n                } else {\n                    let cpus = (*_syspage_ptr).num_cpu;\n                    NonZero::new(cpus as usize)\n                        .ok_or(io::Error::UNKNOWN_THREAD_COUNT)\n                }\n            }\n        }\n        any(target_os = \"solaris\", target_os = \"illumos\") => {\n            let mut cpus = 0u32;\n            if unsafe { libc::pset_info(libc::PS_MYID, core::ptr::null_mut(), &mut cpus, core::ptr::null_mut()) } != 0 {\n                return Err(io::Error::UNKNOWN_THREAD_COUNT);\n            }\n            Ok(unsafe { NonZero::new_unchecked(cpus as usize) })\n        }\n        target_os = \"haiku\" => {\n            // system_info cpu_count field gets the static data set at boot time with `smp_set_num_cpus`\n            // `get_system_info` calls then `smp_get_num_cpus`\n            unsafe {\n                let mut sinfo: libc::system_info = crate::mem::zeroed();\n                let res = libc::get_system_info(&mut sinfo);\n\n                if res != libc::B_OK {\n                    return Err(io::Error::UNKNOWN_THREAD_COUNT);\n                }\n\n                Ok(NonZero::new_unchecked(sinfo.cpu_count as usize))\n            }\n        }\n        target_os = \"vxworks\" => {\n            // Note: there is also `vxCpuConfiguredGet`, closer to _SC_NPROCESSORS_CONF\n            // expectations than the actual cores availability.\n\n            // SAFETY: `vxCpuEnabledGet` always fetches a mask with at least one bit set\n            unsafe{\n                let set = libc::vxCpuEnabledGet();\n                Ok(NonZero::new_unchecked(set.count_ones() as usize))\n            }\n        }\n        _ => {\n            // FIXME: implement on Redox, l4re\n            Err(io::const_error!(io::ErrorKind::Unsupported, \"getting the number of hardware threads is not supported on the target platform\"))\n        }\n    }\n}"
}