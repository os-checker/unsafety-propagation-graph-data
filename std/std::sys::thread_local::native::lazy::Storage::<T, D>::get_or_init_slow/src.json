{
  "name": "std::sys::thread_local::native::lazy::Storage::<T, D>::get_or_init_slow",
  "span": "$library/std/src/sys/thread_local/native/lazy.rs:69:5: 73:18",
  "src": "unsafe fn get_or_init_slow(\n        &self,\n        i: Option<&mut Option<T>>,\n        f: impl FnOnce() -> T,\n    ) -> *const T {\n        match self.state.get() {\n            State::Uninitialized => {}\n            State::Alive => return self.value.get().cast(),\n            State::Destroyed(_) => return ptr::null(),\n        }\n\n        let v = i.and_then(Option::take).unwrap_or_else(f);\n\n        // SAFETY: we cannot be inside a `LocalKey::with` scope, as the initializer\n        // has already returned and the next scope only starts after we return\n        // the pointer. Therefore, there can be no references to the old value,\n        // even if it was initialized. Thus because we are !Sync we have exclusive\n        // access to self.value and may replace it.\n        let mut old_value = unsafe { self.value.get().replace(MaybeUninit::new(v)) };\n        match self.state.replace(State::Alive) {\n            // If the variable is not being recursively initialized, register\n            // the destructor. This might be a noop if the value does not need\n            // destruction.\n            State::Uninitialized => D::register_dtor(self),\n\n            // Recursive initialization, we only need to drop the old value\n            // as we've already registered the destructor.\n            State::Alive => unsafe { old_value.assume_init_drop() },\n\n            State::Destroyed(_) => unreachable!(),\n        }\n\n        self.value.get().cast()\n    }"
}