{
  "name": "std::os::unix::net::ancillary::recv_vectored_with_ancillary_from",
  "span": "$library/std/src/os/unix/net/ancillary.rs:33:1: 37:55",
  "src": "pub(super) fn recv_vectored_with_ancillary_from(\n    socket: &Socket,\n    bufs: &mut [IoSliceMut<'_>],\n    ancillary: &mut SocketAncillary<'_>,\n) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n    unsafe {\n        let mut msg_name: libc::sockaddr_un = zeroed();\n        let mut msg: libc::msghdr = zeroed();\n        msg.msg_name = (&raw mut msg_name) as *mut _;\n        msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;\n        msg.msg_iov = bufs.as_mut_ptr().cast();\n        msg.msg_iovlen = bufs.len() as _;\n        msg.msg_controllen = ancillary.buffer.len() as _;\n        // macos requires that the control pointer is null when the len is 0.\n        if msg.msg_controllen > 0 {\n            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n        }\n\n        let count = socket.recv_msg(&mut msg)?;\n\n        ancillary.length = msg.msg_controllen as usize;\n        ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;\n\n        let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;\n        let addr = SocketAddr::from_parts(msg_name, msg.msg_namelen);\n\n        Ok((count, truncated, addr))\n    }\n}"
}