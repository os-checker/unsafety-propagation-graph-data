{
  "name": "std::sys::thread::unix::cgroups::quota_v1",
  "span": "$library/std/src/sys/thread/unix.rs:753:5: 753:46",
  "src": "fn quota_v1(group_path: PathBuf) -> usize {\n        let mut quota = usize::MAX;\n        let mut path = PathBuf::with_capacity(128);\n        let mut read_buf = String::with_capacity(20);\n\n        // Hardcode commonly used locations mentioned in the cgroups(7) manpage\n        // if that doesn't work scan mountinfo and adjust `group_path` for bind-mounts\n        let mounts: &[fn(&Path) -> Option<(_, &Path)>] = &[\n            |p| Some((Cow::Borrowed(\"/sys/fs/cgroup/cpu\"), p)),\n            |p| Some((Cow::Borrowed(\"/sys/fs/cgroup/cpu,cpuacct\"), p)),\n            // this can be expensive on systems with tons of mountpoints\n            // but we only get to this point when /proc/self/cgroups explicitly indicated\n            // this process belongs to a cpu-controller cgroup v1 and the defaults didn't work\n            find_mountpoint,\n        ];\n\n        for mount in mounts {\n            let Some((mount, group_path)) = mount(&group_path) else { continue };\n\n            path.clear();\n            path.push(mount.as_ref());\n            path.push(&group_path);\n\n            // skip if we guessed the mount incorrectly\n            if matches!(exists(&path), Err(_) | Ok(false)) {\n                continue;\n            }\n\n            while path.starts_with(mount.as_ref()) {\n                let mut parse_file = |name| {\n                    path.push(name);\n                    read_buf.clear();\n\n                    let f = File::open(&path);\n                    path.pop(); // restore buffer before any early returns\n                    f.ok()?.read_to_string(&mut read_buf).ok()?;\n                    let parsed = read_buf.trim().parse::<usize>().ok()?;\n\n                    Some(parsed)\n                };\n\n                let limit = parse_file(\"cpu.cfs_quota_us\");\n                let period = parse_file(\"cpu.cfs_period_us\");\n\n                match (limit, period) {\n                    (Some(limit), Some(period)) if period > 0 => quota = quota.min(limit / period),\n                    _ => {}\n                }\n\n                path.pop();\n            }\n\n            // we passed the try_exists above so we should have traversed the correct hierarchy\n            // when reaching this line\n            break;\n        }\n\n        quota\n    }"
}