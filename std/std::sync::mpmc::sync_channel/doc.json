{
  "name": "std::sync::mpmc::sync_channel",
  "span": "$library/std/src/sync/mpmc/mod.rs:249:1: 249:63",
  "doc": " Creates a new synchronous, bounded channel.\n\n All data sent on the [`Sender`] will become available on the [`Receiver`]\n in the same order as it was sent. Like asynchronous [`channel`]s, the\n [`Receiver`] will block until a message becomes available. `sync_channel`\n differs greatly in the semantics of the sender, however.\n\n This channel has an internal buffer on which messages will be queued.\n `bound` specifies the buffer size. When the internal buffer becomes full,\n future sends will *block* waiting for the buffer to open up. Note that a\n buffer size of 0 is valid, in which case this becomes \"rendezvous channel\"\n where each [`send`] will not return until a [`recv`] is paired with it.\n\n The [`Sender`] can be cloned to [`send`] to the same channel multiple\n times. The [`Receiver`] also can be cloned to have multi receivers.\n\n Like asynchronous channels, if the [`Receiver`] is disconnected while trying\n to [`send`] with the [`Sender`], the [`send`] method will return a\n [`SendError`]. Similarly, If the [`Sender`] is disconnected while trying\n to [`recv`], the [`recv`] method will return a [`RecvError`].\n\n [`send`]: Sender::send\n [`recv`]: Receiver::recv\n\n # Examples\n\n ```\n use std::sync::mpsc::sync_channel;\n use std::thread;\n\n let (sender, receiver) = sync_channel(1);\n\n // this returns immediately\n sender.send(1).unwrap();\n\n thread::spawn(move || {\n     // this will block until the previous message has been received\n     sender.send(2).unwrap();\n });\n\n assert_eq!(receiver.recv().unwrap(), 1);\n assert_eq!(receiver.recv().unwrap(), 2);\n ```\n"
}