{
  "name": "std::sys::pal::unix::futex::futex_wait",
  "span": "$library/std/src/sys/pal/unix/futex.rs:30:1: 30:89",
  "src": "pub fn futex_wait(futex: &Atomic<u32>, expected: u32, timeout: Option<Duration>) -> bool {\n    use super::time::Timespec;\n    use crate::ptr::null;\n    use crate::sync::atomic::Ordering::Relaxed;\n\n    // Calculate the timeout as an absolute timespec.\n    //\n    // Overflows are rounded up to an infinite timeout (None).\n    let timespec = timeout\n        .and_then(|d| Timespec::now(libc::CLOCK_MONOTONIC).checked_add_duration(&d))\n        .and_then(|t| t.to_timespec());\n\n    loop {\n        // No need to wait if the value already changed.\n        if futex.load(Relaxed) != expected {\n            return true;\n        }\n\n        let r = unsafe {\n            cfg_select! {\n                target_os = \"freebsd\" => {\n                    // FreeBSD doesn't have futex(), but it has\n                    // _umtx_op(UMTX_OP_WAIT_UINT_PRIVATE), which is nearly\n                    // identical. It supports absolute timeouts through a flag\n                    // in the _umtx_time struct.\n                    let umtx_timeout = timespec.map(|t| libc::_umtx_time {\n                        _timeout: t,\n                        _flags: libc::UMTX_ABSTIME,\n                        _clockid: libc::CLOCK_MONOTONIC as u32,\n                    });\n                    let umtx_timeout_ptr = umtx_timeout.as_ref().map_or(null(), |t| t as *const _);\n                    let umtx_timeout_size = umtx_timeout.as_ref().map_or(0, |t| size_of_val(t));\n                    libc::_umtx_op(\n                        futex as *const Atomic<u32> as *mut _,\n                        libc::UMTX_OP_WAIT_UINT_PRIVATE,\n                        expected as libc::c_ulong,\n                        crate::ptr::without_provenance_mut(umtx_timeout_size),\n                        umtx_timeout_ptr as *mut _,\n                    )\n                }\n                any(target_os = \"linux\", target_os = \"android\") => {\n                    // Use FUTEX_WAIT_BITSET rather than FUTEX_WAIT to be able to give an\n                    // absolute time rather than a relative time.\n                    libc::syscall(\n                        libc::SYS_futex,\n                        futex as *const Atomic<u32>,\n                        libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,\n                        expected,\n                        timespec.as_ref().map_or(null(), |t| t as *const libc::timespec),\n                        null::<u32>(), // This argument is unused for FUTEX_WAIT_BITSET.\n                        !0u32,         // A full bitmask, to make it behave like a regular FUTEX_WAIT.\n                    )\n                }\n                _ => {\n                    compile_error!(\"unknown target_os\");\n                }\n            }\n        };\n\n        match (r < 0).then(super::os::errno) {\n            Some(libc::ETIMEDOUT) => return false,\n            Some(libc::EINTR) => continue,\n            _ => return true,\n        }\n    }\n}"
}