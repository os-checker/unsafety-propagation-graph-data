{
  "name": "std::thread::functions::sleep_until",
  "span": "$library/std/src/thread/functions.rs:387:1: 387:38",
  "doc": " Puts the current thread to sleep until the specified deadline has passed.\n\n The thread may still be asleep after the deadline specified due to\n scheduling specifics or platform-dependent functionality. It will never\n wake before.\n\n This function is blocking, and should not be used in `async` functions.\n\n # Platform-specific behavior\n\n In most cases this function will call an OS specific function. Where that\n is not supported [`sleep`] is used. Those platforms are referred to as other\n in the table below.\n\n # Underlying System calls\n\n The following system calls are [currently] being used:\n\n |  Platform |               System call                                            |\n |-----------|----------------------------------------------------------------------|\n | Linux     | [clock_nanosleep] (Monotonic clock)                                  |\n | BSD except OpenBSD | [clock_nanosleep] (Monotonic Clock)]                        |\n | Android   | [clock_nanosleep] (Monotonic Clock)]                                 |\n | Solaris   | [clock_nanosleep] (Monotonic Clock)]                                 |\n | Illumos   | [clock_nanosleep] (Monotonic Clock)]                                 |\n | Dragonfly | [clock_nanosleep] (Monotonic Clock)]                                 |\n | Hurd      | [clock_nanosleep] (Monotonic Clock)]                                 |\n | Fuchsia   | [clock_nanosleep] (Monotonic Clock)]                                 |\n | Vxworks   | [clock_nanosleep] (Monotonic Clock)]                                 |\n | Other     | `sleep_until` uses [`sleep`] and does not issue a syscall itself     |\n\n [currently]: crate::io#platform-specific-behavior\n [clock_nanosleep]: https://linux.die.net/man/3/clock_nanosleep\n\n **Disclaimer:** These system calls might change over time.\n\n # Examples\n\n A simple game loop that limits the game to 60 frames per second.\n\n ```no_run\n #![feature(thread_sleep_until)]\n # use std::time::{Duration, Instant};\n # use std::thread;\n #\n # fn update() {}\n # fn render() {}\n #\n let max_fps = 60.0;\n let frame_time = Duration::from_secs_f32(1.0/max_fps);\n let mut next_frame = Instant::now();\n loop {\n     thread::sleep_until(next_frame);\n     next_frame += frame_time;\n     update();\n     render();\n }\n ```\n\n A slow API we must not call too fast and which takes a few\n tries before succeeding. By using `sleep_until` the time the\n API call takes does not influence when we retry or when we give up\n\n ```no_run\n #![feature(thread_sleep_until)]\n # use std::time::{Duration, Instant};\n # use std::thread;\n #\n # enum Status {\n #     Ready(usize),\n #     Waiting,\n # }\n # fn slow_web_api_call() -> Status { Status::Ready(42) }\n #\n # const MAX_DURATION: Duration = Duration::from_secs(10);\n #\n # fn try_api_call() -> Result<usize, ()> {\n let deadline = Instant::now() + MAX_DURATION;\n let delay = Duration::from_millis(250);\n let mut next_attempt = Instant::now();\n loop {\n     if Instant::now() > deadline {\n         break Err(());\n     }\n     if let Status::Ready(data) = slow_web_api_call() {\n         break Ok(data);\n     }\n\n     next_attempt = deadline.min(next_attempt + delay);\n     thread::sleep_until(next_attempt);\n }\n # }\n # let _data = try_api_call();\n ```\n"
}