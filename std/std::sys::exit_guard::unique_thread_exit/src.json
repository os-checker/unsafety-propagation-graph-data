{
  "name": "std::sys::exit_guard::unique_thread_exit",
  "span": "$library/std/src/sys/exit_guard.rs:23:9: 23:43",
  "src": "pub(crate) fn unique_thread_exit() {\n            use crate::ffi::c_int;\n            use crate::ptr;\n            use crate::sync::atomic::AtomicPtr;\n            use crate::sync::atomic::Ordering::{Acquire, Relaxed};\n\n            static EXITING_THREAD_ID: AtomicPtr<c_int> = AtomicPtr::new(ptr::null_mut());\n\n            // We use the address of `errno` as a cheap and safe way to identify\n            // threads. As the C standard mandates that `errno` must have thread\n            // storage duration, we can rely on its address not changing over the\n            // lifetime of the thread. Additionally, accesses to `errno` are\n            // async-signal-safe, so this function is available in all imaginable\n            // circumstances.\n            let this_thread_id = crate::sys::os::errno_location();\n            match EXITING_THREAD_ID.compare_exchange(ptr::null_mut(), this_thread_id, Acquire, Relaxed) {\n                Ok(_) => {\n                    // This is the first thread to call `unique_thread_exit`,\n                    // and this is the first time it is called. Continue exiting.\n                }\n                Err(exiting_thread_id) if exiting_thread_id == this_thread_id => {\n                    // This is the first thread to call `unique_thread_exit`,\n                    // but this is the second time it is called.\n                    // Abort the process.\n                    core::panicking::panic_nounwind(\"std::process::exit called re-entrantly\")\n                }\n                Err(_) => {\n                    // This is not the first thread to call `unique_thread_exit`.\n                    // Pause until the process exits.\n                    loop {\n                        // Safety: libc::pause is safe to call.\n                        unsafe { libc::pause(); }\n                    }\n                }\n            }\n        }"
}