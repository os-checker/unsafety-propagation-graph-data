{
  "name": "std::sync::once::Once::call_once_force",
  "span": "$library/std/src/sync/once.rs:209:5: 211:31",
  "doc": " Performs the same function as [`call_once()`] except ignores poisoning.\n\n Unlike [`call_once()`], if this [`Once`] has been poisoned (i.e., a previous\n call to [`call_once()`] or [`call_once_force()`] caused a panic), calling\n [`call_once_force()`] will still invoke the closure `f` and will _not_\n result in an immediate panic. If `f` panics, the [`Once`] will remain\n in a poison state. If `f` does _not_ panic, the [`Once`] will no\n longer be in a poison state and all future calls to [`call_once()`] or\n [`call_once_force()`] will be no-ops.\n\n The closure `f` is yielded a [`OnceState`] structure which can be used\n to query the poison status of the [`Once`].\n\n [`call_once()`]: Once::call_once\n [`call_once_force()`]: Once::call_once_force\n\n # Examples\n\n ```\n use std::sync::Once;\n use std::thread;\n\n static INIT: Once = Once::new();\n\n // poison the once\n let handle = thread::spawn(|| {\n     INIT.call_once(|| panic!());\n });\n assert!(handle.join().is_err());\n\n // poisoning propagates\n let handle = thread::spawn(|| {\n     INIT.call_once(|| {});\n });\n assert!(handle.join().is_err());\n\n // call_once_force will still run and reset the poisoned state\n INIT.call_once_force(|state| {\n     assert!(state.is_poisoned());\n });\n\n // once any success happens, we stop propagating the poison\n INIT.call_once(|| {});\n ```\n"
}