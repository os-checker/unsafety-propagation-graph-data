{
  "name": "std::path::compare_components",
  "span": "$library/std/src/path.rs:1046:1: 1046:92",
  "src": "fn compare_components(mut left: Components<'_>, mut right: Components<'_>) -> cmp::Ordering {\n    // Fast path for long shared prefixes\n    //\n    // - compare raw bytes to find first mismatch\n    // - backtrack to find separator before mismatch to avoid ambiguous parsings of '.' or '..' characters\n    // - if found update state to only do a component-wise comparison on the remainder,\n    //   otherwise do it on the full path\n    //\n    // The fast path isn't taken for paths with a PrefixComponent to avoid backtracking into\n    // the middle of one\n    if left.prefix.is_none() && right.prefix.is_none() && left.front == right.front {\n        // possible future improvement: a [u8]::first_mismatch simd implementation\n        let first_difference = match left.path.iter().zip(right.path).position(|(&a, &b)| a != b) {\n            None if left.path.len() == right.path.len() => return cmp::Ordering::Equal,\n            None => left.path.len().min(right.path.len()),\n            Some(diff) => diff,\n        };\n\n        if let Some(previous_sep) =\n            left.path[..first_difference].iter().rposition(|&b| left.is_sep_byte(b))\n        {\n            let mismatched_component_start = previous_sep + 1;\n            left.path = &left.path[mismatched_component_start..];\n            left.front = State::Body;\n            right.path = &right.path[mismatched_component_start..];\n            right.front = State::Body;\n        }\n    }\n\n    Iterator::cmp(left, right)\n}"
}