{
  "name": "std::panicking::panic_with_hook",
  "span": "$library/std/src/panicking.rs:787:1: 792:7",
  "src": "fn panic_with_hook(\n    payload: &mut dyn PanicPayload,\n    location: &Location<'_>,\n    can_unwind: bool,\n    force_no_backtrace: bool,\n) -> ! {\n    let must_abort = panic_count::increase(true);\n\n    // Check if we need to abort immediately.\n    if let Some(must_abort) = must_abort {\n        match must_abort {\n            panic_count::MustAbort::PanicInHook => {\n                // Don't try to format the message in this case, perhaps that is causing the\n                // recursive panics. However if the message is just a string, no user-defined\n                // code is involved in printing it, so that is risk-free.\n                let message: &str = payload.as_str().unwrap_or_default();\n                rtprintpanic!(\n                    \"panicked at {location}:\\n{message}\\nthread panicked while processing panic. aborting.\\n\"\n                );\n            }\n            panic_count::MustAbort::AlwaysAbort => {\n                // Unfortunately, this does not print a backtrace, because creating\n                // a `Backtrace` will allocate, which we must avoid here.\n                rtprintpanic!(\"aborting due to panic at {location}:\\n{payload}\\n\");\n            }\n        }\n        crate::process::abort();\n    }\n\n    match *HOOK.read() {\n        // Some platforms (like wasm) know that printing to stderr won't ever actually\n        // print anything, and if that's the case we can skip the default\n        // hook. Since string formatting happens lazily when calling `payload`\n        // methods, this means we avoid formatting the string at all!\n        // (The panic runtime might still call `payload.take_box()` though and trigger\n        // formatting.)\n        Hook::Default if panic_output().is_none() => {}\n        Hook::Default => {\n            default_hook(&PanicHookInfo::new(\n                location,\n                payload.get(),\n                can_unwind,\n                force_no_backtrace,\n            ));\n        }\n        Hook::Custom(ref hook) => {\n            hook(&PanicHookInfo::new(location, payload.get(), can_unwind, force_no_backtrace));\n        }\n    }\n\n    // Indicate that we have finished executing the panic hook. After this point\n    // it is fine if there is a panic while executing destructors, as long as it\n    // it contained within a `catch_unwind`.\n    panic_count::finished_panic_hook();\n\n    if !can_unwind {\n        // If a thread panics while running destructors or tries to unwind\n        // through a nounwind function (e.g. extern \"C\") then we cannot continue\n        // unwinding and have to abort immediately.\n        rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n        crate::process::abort();\n    }\n\n    rust_panic(payload)\n}"
}