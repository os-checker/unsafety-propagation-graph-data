{
  "name": "std::sys::thread_local::destructors::linux_like::register",
  "span": "$library/std/src/sys/thread_local/destructors/linux_like.rs:15:1: 15:72",
  "src": "pub unsafe fn register(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n    /// This is necessary because the __cxa_thread_atexit_impl implementation\n    /// std links to by default may be a C or C++ implementation that was not\n    /// compiled using the Clang integer normalization option.\n    #[cfg(sanitizer_cfi_normalize_integers)]\n    use core::ffi::c_int;\n    #[cfg(not(sanitizer_cfi_normalize_integers))]\n    #[cfi_encoding = \"i\"]\n    #[repr(transparent)]\n    #[allow(non_camel_case_types)]\n    pub struct c_int(#[allow(dead_code)] pub core::ffi::c_int);\n\n    unsafe extern \"C\" {\n        #[linkage = \"extern_weak\"]\n        static __dso_handle: *mut u8;\n        #[linkage = \"extern_weak\"]\n        static __cxa_thread_atexit_impl: Option<\n            extern \"C\" fn(\n                unsafe extern \"C\" fn(*mut libc::c_void),\n                *mut libc::c_void,\n                *mut libc::c_void,\n            ) -> c_int,\n        >;\n    }\n\n    if let Some(f) = unsafe { __cxa_thread_atexit_impl } {\n        unsafe {\n            f(\n                transmute::<unsafe extern \"C\" fn(*mut u8), unsafe extern \"C\" fn(*mut libc::c_void)>(\n                    dtor,\n                ),\n                t.cast(),\n                (&raw const __dso_handle) as *mut _,\n            );\n        }\n    } else {\n        unsafe {\n            super::list::register(t, dtor);\n        }\n    }\n}"
}