{
  "name": "std::<io::buffered::bufwriter::BufWriter<I> as io::copy::BufferedWriterSpec>::copy_from",
  "span": "$library/std/src/io/copy.rs:211:5: 211:77",
  "src": "fn copy_from<R: Read + ?Sized>(&mut self, reader: &mut R) -> Result<u64> {\n        if self.capacity() < DEFAULT_BUF_SIZE {\n            return stack_buffer_copy(reader, self);\n        }\n\n        let mut len = 0;\n\n        loop {\n            let buf = self.buffer_mut();\n            let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n\n            if read_buf.capacity() >= DEFAULT_BUF_SIZE {\n                let mut cursor = read_buf.unfilled();\n                match reader.read_buf(cursor.reborrow()) {\n                    Ok(()) => {\n                        let bytes_read = cursor.written();\n                        if bytes_read == 0 {\n                            return Ok(len);\n                        }\n                        len += bytes_read as u64;\n\n                        // SAFETY: BorrowedBuf guarantees all of its filled bytes are init\n                        unsafe { buf.set_len(buf.len() + bytes_read) };\n\n                        // Read again if the buffer still has enough capacity, as BufWriter itself would do\n                        // This will occur if the reader returns short reads\n                    }\n                    Err(ref e) if e.is_interrupted() => {}\n                    Err(e) => return Err(e),\n                }\n            } else {\n                self.flush_buf()?;\n            }\n        }\n    }"
}