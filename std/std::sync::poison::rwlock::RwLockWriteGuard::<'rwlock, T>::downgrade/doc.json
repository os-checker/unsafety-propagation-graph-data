{
  "name": "std::sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::downgrade",
  "span": "$library/std/src/sync/poison/rwlock.rs:869:5: 869:61",
  "doc": " Downgrades a write-locked `RwLockWriteGuard` into a read-locked [`RwLockReadGuard`].\n\n Since we have the `RwLockWriteGuard`, the [`RwLock`] must already be locked for writing, so\n this method cannot fail.\n\n After downgrading, other readers will be allowed to read the protected data.\n\n # Examples\n\n `downgrade` takes ownership of the `RwLockWriteGuard` and returns a [`RwLockReadGuard`].\n\n ```\n use std::sync::{RwLock, RwLockWriteGuard};\n\n let rw = RwLock::new(0);\n\n let mut write_guard = rw.write().unwrap();\n *write_guard = 42;\n\n let read_guard = RwLockWriteGuard::downgrade(write_guard);\n assert_eq!(42, *read_guard);\n ```\n\n `downgrade` will _atomically_ change the state of the [`RwLock`] from exclusive mode into\n shared mode. This means that it is impossible for another writing thread to get in between a\n thread calling `downgrade` and any reads it performs after downgrading.\n\n ```\n use std::sync::{Arc, RwLock, RwLockWriteGuard};\n\n let rw = Arc::new(RwLock::new(1));\n\n // Put the lock in write mode.\n let mut main_write_guard = rw.write().unwrap();\n\n let rw_clone = rw.clone();\n let evil_handle = std::thread::spawn(move || {\n     // This will not return until the main thread drops the `main_read_guard`.\n     let mut evil_guard = rw_clone.write().unwrap();\n\n     assert_eq!(*evil_guard, 2);\n     *evil_guard = 3;\n });\n\n *main_write_guard = 2;\n\n // Atomically downgrade the write guard into a read guard.\n let main_read_guard = RwLockWriteGuard::downgrade(main_write_guard);\n\n // Since `downgrade` is atomic, the writer thread cannot have changed the protected data.\n assert_eq!(*main_read_guard, 2, \"`downgrade` was not atomic\");\n #\n # drop(main_read_guard);\n # evil_handle.join().unwrap();\n #\n # let final_check = rw.read().unwrap();\n # assert_eq!(*final_check, 3);\n ```\n"
}