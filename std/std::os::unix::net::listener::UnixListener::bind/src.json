{
  "name": "std::os::unix::net::listener::UnixListener::bind",
  "span": "$library/std/src/os/unix/net/listener.rs:72:5: 72:69",
  "src": "pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n        unsafe {\n            let inner = Socket::new(libc::AF_UNIX, libc::SOCK_STREAM)?;\n            let (addr, len) = sockaddr_un(path.as_ref())?;\n            #[cfg(any(\n                target_os = \"windows\",\n                target_os = \"redox\",\n                target_os = \"espidf\",\n                target_os = \"horizon\"\n            ))]\n            const backlog: core::ffi::c_int = 128;\n            #[cfg(any(\n                // Silently capped to `/proc/sys/net/core/somaxconn`.\n                target_os = \"linux\",\n                // Silently capped to `kern.ipc.soacceptqueue`.\n                target_os = \"freebsd\",\n                // Silently capped to `kern.somaxconn sysctl`.\n                target_os = \"openbsd\",\n                // Silently capped to the default 128.\n                target_vendor = \"apple\",\n            ))]\n            const backlog: core::ffi::c_int = -1;\n            #[cfg(not(any(\n                target_os = \"windows\",\n                target_os = \"redox\",\n                target_os = \"espidf\",\n                target_os = \"horizon\",\n                target_os = \"linux\",\n                target_os = \"freebsd\",\n                target_os = \"openbsd\",\n                target_vendor = \"apple\",\n            )))]\n            const backlog: libc::c_int = libc::SOMAXCONN;\n\n            cvt(libc::bind(inner.as_inner().as_raw_fd(), (&raw const addr) as *const _, len as _))?;\n            cvt(libc::listen(inner.as_inner().as_raw_fd(), backlog))?;\n\n            Ok(UnixListener(inner))\n        }\n    }"
}