{
  "name": "std::sys::backtrace::_print_fmt",
  "span": "$library/std/src/sys/backtrace.rs:48:1: 48:87",
  "src": "unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n    // Always 'fail' to get the cwd when running under Miri -\n    // this allows Miri to display backtraces in isolation mode\n    let cwd = if !cfg!(miri) { env::current_dir().ok() } else { None };\n\n    let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n        output_filename(fmt, bows, print_fmt, cwd.as_ref())\n    };\n    writeln!(fmt, \"stack backtrace:\")?;\n    let mut bt_fmt = BacktraceFmt::new(fmt, print_fmt, &mut print_path);\n    bt_fmt.add_context()?;\n    let mut idx = 0;\n    let mut res = Ok(());\n    let mut omitted_count: usize = 0;\n    let mut first_omit = true;\n    // If we're using a short backtrace, ignore all frames until we're told to start printing.\n    let mut print = print_fmt != PrintFmt::Short;\n    set_image_base();\n    // SAFETY: we roll our own locking in this town\n    unsafe {\n        backtrace_rs::trace_unsynchronized(|frame| {\n            if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n                return false;\n            }\n\n            if cfg!(feature = \"backtrace-trace-only\") {\n                const HEX_WIDTH: usize = 2 + 2 * size_of::<usize>();\n                let frame_ip = frame.ip();\n                res = writeln!(bt_fmt.formatter(), \"{idx:4}: {frame_ip:HEX_WIDTH$?}\");\n            } else {\n                let mut hit = false;\n                backtrace_rs::resolve_frame_unsynchronized(frame, |symbol| {\n                    hit = true;\n\n                    // `__rust_end_short_backtrace` means we are done hiding symbols\n                    // for now. Print until we see `__rust_begin_short_backtrace`.\n                    if print_fmt == PrintFmt::Short {\n                        if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n                            if sym.contains(\"__rust_end_short_backtrace\") {\n                                print = true;\n                                return;\n                            }\n                            if print && sym.contains(\"__rust_begin_short_backtrace\") {\n                                print = false;\n                                return;\n                            }\n                            if !print {\n                                omitted_count += 1;\n                            }\n                        }\n                    }\n\n                    if print {\n                        if omitted_count > 0 {\n                            debug_assert!(print_fmt == PrintFmt::Short);\n                            // only print the message between the middle of frames\n                            if !first_omit {\n                                let _ = writeln!(\n                                    bt_fmt.formatter(),\n                                    \"      [... omitted {} frame{} ...]\",\n                                    omitted_count,\n                                    if omitted_count > 1 { \"s\" } else { \"\" }\n                                );\n                            }\n                            first_omit = false;\n                            omitted_count = 0;\n                        }\n                        res = bt_fmt.frame().symbol(frame, symbol);\n                    }\n                });\n                #[cfg(all(target_os = \"nto\", any(target_env = \"nto70\", target_env = \"nto71\")))]\n                if libc::__my_thread_exit as *mut libc::c_void == frame.ip() {\n                    if !hit && print {\n                        use crate::backtrace_rs::SymbolName;\n                        res = bt_fmt.frame().print_raw(\n                            frame.ip(),\n                            Some(SymbolName::new(\"__my_thread_exit\".as_bytes())),\n                            None,\n                            None,\n                        );\n                    }\n                    return false;\n                }\n                if !hit && print {\n                    res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n                }\n            }\n\n            idx += 1;\n            res.is_ok()\n        })\n    };\n    res?;\n    bt_fmt.finish()?;\n    if print_fmt == PrintFmt::Short {\n        writeln!(\n            fmt,\n            \"note: Some details are omitted, \\\n             run with `RUST_BACKTRACE=full` for a verbose backtrace.\"\n        )?;\n    }\n    Ok(())\n}"
}