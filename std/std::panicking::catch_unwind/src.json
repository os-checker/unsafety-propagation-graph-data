{
  "name": "std::panicking::catch_unwind",
  "span": "$library/std/src/panicking.rs:500:1: 500:88",
  "src": "pub unsafe fn catch_unwind<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n    union Data<F, R> {\n        f: ManuallyDrop<F>,\n        r: ManuallyDrop<R>,\n        p: ManuallyDrop<Box<dyn Any + Send>>,\n    }\n\n    // We do some sketchy operations with ownership here for the sake of\n    // performance. We can only pass pointers down to `do_call` (can't pass\n    // objects by value), so we do all the ownership tracking here manually\n    // using a union.\n    //\n    // We go through a transition where:\n    //\n    // * First, we set the data field `f` to be the argumentless closure that we're going to call.\n    // * When we make the function call, the `do_call` function below, we take\n    //   ownership of the function pointer. At this point the `data` union is\n    //   entirely uninitialized.\n    // * If the closure successfully returns, we write the return value into the\n    //   data's return slot (field `r`).\n    // * If the closure panics (`do_catch` below), we write the panic payload into field `p`.\n    // * Finally, when we come back out of the `try` intrinsic we're\n    //   in one of two states:\n    //\n    //      1. The closure didn't panic, in which case the return value was\n    //         filled in. We move it out of `data.r` and return it.\n    //      2. The closure panicked, in which case the panic payload was\n    //         filled in. We move it out of `data.p` and return it.\n    //\n    // Once we stack all that together we should have the \"most efficient'\n    // method of calling a catch panic whilst juggling ownership.\n    let mut data = Data { f: ManuallyDrop::new(f) };\n\n    let data_ptr = (&raw mut data) as *mut u8;\n    // SAFETY:\n    //\n    // Access to the union's fields: this is `std` and we know that the `catch_unwind`\n    // intrinsic fills in the `r` or `p` union field based on its return value.\n    //\n    // The call to `intrinsics::catch_unwind` is made safe by:\n    // - `do_call`, the first argument, can be called with the initial `data_ptr`.\n    // - `do_catch`, the second argument, can be called with the `data_ptr` as well.\n    // See their safety preconditions for more information\n    unsafe {\n        return if intrinsics::catch_unwind(do_call::<F, R>, data_ptr, do_catch::<F, R>) == 0 {\n            Ok(ManuallyDrop::into_inner(data.r))\n        } else {\n            Err(ManuallyDrop::into_inner(data.p))\n        };\n    }\n\n    // We consider unwinding to be rare, so mark this function as cold. However,\n    // do not mark it no-inline -- that decision is best to leave to the\n    // optimizer (in most cases this function is not inlined even as a normal,\n    // non-cold function, though, as of the writing of this comment).\n    #[cold]\n    #[optimize(size)]\n    unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send + 'static> {\n        // SAFETY: The whole unsafe block hinges on a correct implementation of\n        // the panic handler `__rust_panic_cleanup`. As such we can only\n        // assume it returns the correct thing for `Box::from_raw` to work\n        // without undefined behavior.\n        let obj = unsafe { Box::from_raw(__rust_panic_cleanup(payload)) };\n        panic_count::decrease();\n        obj\n    }\n\n    // SAFETY:\n    // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`\n    // Its must contains a valid `f` (type: F) value that can be use to fill\n    // `data.r`.\n    //\n    // This function cannot be marked as `unsafe` because `intrinsics::catch_unwind`\n    // expects normal function pointers.\n    #[inline]\n    fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n        // SAFETY: this is the responsibility of the caller, see above.\n        unsafe {\n            let data = data as *mut Data<F, R>;\n            let data = &mut (*data);\n            let f = ManuallyDrop::take(&mut data.f);\n            data.r = ManuallyDrop::new(f());\n        }\n    }\n\n    // We *do* want this part of the catch to be inlined: this allows the\n    // compiler to properly track accesses to the Data union and optimize it\n    // away most of the time.\n    //\n    // SAFETY:\n    // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`\n    // Since this uses `cleanup` it also hinges on a correct implementation of\n    // `__rustc_panic_cleanup`.\n    //\n    // This function cannot be marked as `unsafe` because `intrinsics::catch_unwind`\n    // expects normal function pointers.\n    #[inline]\n    #[rustc_nounwind] // `intrinsic::catch_unwind` requires catch fn to be nounwind\n    fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n        // SAFETY: this is the responsibility of the caller, see above.\n        //\n        // When `__rustc_panic_cleaner` is correctly implemented we can rely\n        // on `obj` being the correct thing to pass to `data.p` (after wrapping\n        // in `ManuallyDrop`).\n        unsafe {\n            let data = data as *mut Data<F, R>;\n            let data = &mut (*data);\n            let obj = cleanup(payload);\n            data.p = ManuallyDrop::new(obj);\n        }\n    }\n}"
}