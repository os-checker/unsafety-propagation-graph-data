{
  "name": "std::sys::thread::unix::sleep_until",
  "span": "$library/std/src/sys/thread/unix.rs:592:1: 592:51",
  "src": "pub fn sleep_until(deadline: crate::time::Instant) {\n    use crate::time::Instant;\n\n    let Some(ts) = deadline.into_inner().into_timespec().to_timespec() else {\n        // The deadline is further in the future then can be passed to\n        // clock_nanosleep. We have to use Self::sleep instead. This might\n        // happen on 32 bit platforms, especially closer to 2038.\n        let now = Instant::now();\n        if let Some(delay) = deadline.checked_duration_since(now) {\n            sleep(delay);\n        }\n        return;\n    };\n\n    unsafe {\n        // When we get interrupted (res = EINTR) call clock_nanosleep again\n        loop {\n            let res = libc::clock_nanosleep(\n                crate::sys::time::Instant::CLOCK_ID,\n                libc::TIMER_ABSTIME,\n                &ts,\n                core::ptr::null_mut(), // not required with TIMER_ABSTIME\n            );\n\n            if res == 0 {\n                break;\n            } else {\n                assert_eq!(\n                    res,\n                    libc::EINTR,\n                    \"timespec is in range,\n                         clockid is valid and kernel should support it\"\n                );\n            }\n        }\n    }\n}"
}