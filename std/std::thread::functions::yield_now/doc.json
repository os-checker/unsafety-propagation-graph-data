{
  "name": "std::thread::functions::yield_now",
  "span": "$library/std/src/thread/functions.rs:167:1: 167:19",
  "doc": " Cooperatively gives up a timeslice to the OS scheduler.\n\n This calls the underlying OS scheduler's yield primitive, signaling\n that the calling thread is willing to give up its remaining timeslice\n so that the OS may schedule other threads on the CPU.\n\n A drawback of yielding in a loop is that if the OS does not have any\n other ready threads to run on the current CPU, the thread will effectively\n busy-wait, which wastes CPU time and energy.\n\n Therefore, when waiting for events of interest, a programmer's first\n choice should be to use synchronization devices such as [`channel`]s,\n [`Condvar`]s, [`Mutex`]es or [`join`] since these primitives are\n implemented in a blocking manner, giving up the CPU until the event\n of interest has occurred which avoids repeated yielding.\n\n `yield_now` should thus be used only rarely, mostly in situations where\n repeated polling is required because there is no other suitable way to\n learn when an event of interest has occurred.\n\n # Examples\n\n ```\n use std::thread;\n\n thread::yield_now();\n ```\n\n [`channel`]: crate::sync::mpsc\n [`join`]: JoinHandle::join\n [`Condvar`]: crate::sync::Condvar\n [`Mutex`]: crate::sync::Mutex\n"
}