{
  "name": "std::<io::buffered::bufwriter::BufWriter<W> as io::Write>::write_vectored",
  "span": "$library/std/src/io/buffered/bufwriter.rs:550:5: 550:76",
  "src": "fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // FIXME: Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied\n        // to `write` and `write_all`. The performance benefits can be significant. See #79930.\n        if self.get_ref().is_write_vectored() {\n            // We have to handle the possibility that the total length of the buffers overflows\n            // `usize` (even though this can only happen if multiple `IoSlice`s reference the\n            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the\n            // computation overflows, then surely the input cannot fit in our buffer, so we forward\n            // to the inner writer's `write_vectored` method to let it handle it appropriately.\n            let mut saturated_total_len: usize = 0;\n\n            for buf in bufs {\n                saturated_total_len = saturated_total_len.saturating_add(buf.len());\n\n                if saturated_total_len > self.spare_capacity() && !self.buf.is_empty() {\n                    // Flush if the total length of the input exceeds our buffer's spare capacity.\n                    // If we would have overflowed, this condition also holds, and we need to flush.\n                    self.flush_buf()?;\n                }\n\n                if saturated_total_len >= self.buf.capacity() {\n                    // Forward to our inner writer if the total length of the input is greater than or\n                    // equal to our buffer capacity. If we would have overflowed, this condition also\n                    // holds, and we punt to the inner writer.\n                    self.panicked = true;\n                    let r = self.get_mut().write_vectored(bufs);\n                    self.panicked = false;\n                    return r;\n                }\n            }\n\n            // `saturated_total_len < self.buf.capacity()` implies that we did not saturate.\n\n            // SAFETY: We checked whether or not the spare capacity was large enough above. If\n            // it was, then we're safe already. If it wasn't, we flushed, making sufficient\n            // room for any input <= the buffer size, which includes this input.\n            unsafe {\n                bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));\n            };\n\n            Ok(saturated_total_len)\n        } else {\n            let mut iter = bufs.iter();\n            let mut total_written = if let Some(buf) = iter.by_ref().find(|&buf| !buf.is_empty()) {\n                // This is the first non-empty slice to write, so if it does\n                // not fit in the buffer, we still get to flush and proceed.\n                if buf.len() > self.spare_capacity() {\n                    self.flush_buf()?;\n                }\n                if buf.len() >= self.buf.capacity() {\n                    // The slice is at least as large as the buffering capacity,\n                    // so it's better to write it directly, bypassing the buffer.\n                    self.panicked = true;\n                    let r = self.get_mut().write(buf);\n                    self.panicked = false;\n                    return r;\n                } else {\n                    // SAFETY: We checked whether or not the spare capacity was large enough above.\n                    // If it was, then we're safe already. If it wasn't, we flushed, making\n                    // sufficient room for any input <= the buffer size, which includes this input.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    buf.len()\n                }\n            } else {\n                return Ok(0);\n            };\n            debug_assert!(total_written != 0);\n            for buf in iter {\n                if buf.len() <= self.spare_capacity() {\n                    // SAFETY: safe by above conditional.\n                    unsafe {\n                        self.write_to_buffer_unchecked(buf);\n                    }\n\n                    // This cannot overflow `usize`. If we are here, we've written all of the bytes\n                    // so far to our buffer, and we've ensured that we never exceed the buffer's\n                    // capacity. Therefore, `total_written` <= `self.buf.capacity()` <= `usize::MAX`.\n                    total_written += buf.len();\n                } else {\n                    break;\n                }\n            }\n            Ok(total_written)\n        }\n    }"
}