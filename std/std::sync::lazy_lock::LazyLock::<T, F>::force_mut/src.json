{
  "name": "std::sync::lazy_lock::LazyLock::<T, F>::force_mut",
  "span": "$library/std/src/sync/lazy_lock.rs:187:5: 187:58",
  "src": "pub fn force_mut(this: &mut LazyLock<T, F>) -> &mut T {\n        #[cold]\n        /// # Safety\n        /// May only be called when the state is `Incomplete`.\n        unsafe fn really_init_mut<T, F: FnOnce() -> T>(this: &mut LazyLock<T, F>) -> &mut T {\n            struct PoisonOnPanic<'a, T, F>(&'a mut LazyLock<T, F>);\n            impl<T, F> Drop for PoisonOnPanic<'_, T, F> {\n                #[inline]\n                fn drop(&mut self) {\n                    self.0.once.set_state(OnceExclusiveState::Poisoned);\n                }\n            }\n\n            // SAFETY: We always poison if the initializer panics (then we never check the data),\n            // or set the data on success.\n            let f = unsafe { ManuallyDrop::take(&mut this.data.get_mut().f) };\n            // INVARIANT: Initiated from mutable reference, don't drop because we read it.\n            let guard = PoisonOnPanic(this);\n            let data = f();\n            guard.0.data.get_mut().value = ManuallyDrop::new(data);\n            guard.0.once.set_state(OnceExclusiveState::Complete);\n            core::mem::forget(guard);\n            // SAFETY: We put the value there above.\n            unsafe { &mut this.data.get_mut().value }\n        }\n\n        let state = this.once.state();\n        match state {\n            OnceExclusiveState::Poisoned => panic_poisoned(),\n            // SAFETY: The `Once` states we completed the initialization.\n            OnceExclusiveState::Complete => unsafe { &mut this.data.get_mut().value },\n            // SAFETY: The state is `Incomplete`.\n            OnceExclusiveState::Incomplete => unsafe { really_init_mut(this) },\n        }\n    }"
}