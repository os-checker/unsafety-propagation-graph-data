{
  "name": "std::<io::buffered::bufreader::BufReader<R> as io::Seek>::seek",
  "span": "$library/std/src/io/buffered/bufreader.rs:493:5: 493:57",
  "src": "fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        let result: u64;\n        if let SeekFrom::Current(n) = pos {\n            let remainder = (self.buf.filled() - self.buf.pos()) as i64;\n            // it should be safe to assume that remainder fits within an i64 as the alternative\n            // means we managed to allocate 8 exbibytes and that's absurd.\n            // But it's not out of the realm of possibility for some weird underlying reader to\n            // support seeking by i64::MIN so we need to handle underflow when subtracting\n            // remainder.\n            if let Some(offset) = n.checked_sub(remainder) {\n                result = self.inner.seek(SeekFrom::Current(offset))?;\n            } else {\n                // seek backwards by our remainder, and then by the offset\n                self.inner.seek(SeekFrom::Current(-remainder))?;\n                self.discard_buffer();\n                result = self.inner.seek(SeekFrom::Current(n))?;\n            }\n        } else {\n            // Seeking with Start/End doesn't care about our buffer length.\n            result = self.inner.seek(pos)?;\n        }\n        self.discard_buffer();\n        Ok(result)\n    }"
}