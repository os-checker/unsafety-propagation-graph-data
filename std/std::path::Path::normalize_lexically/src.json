{
  "name": "std::path::Path::normalize_lexically",
  "span": "$library/std/src/path.rs:3292:5: 3292:73",
  "src": "pub fn normalize_lexically(&self) -> Result<PathBuf, NormalizeError> {\n        let mut lexical = PathBuf::new();\n        let mut iter = self.components().peekable();\n\n        // Find the root, if any, and add it to the lexical path.\n        // Here we treat the Windows path \"C:\\\" as a single \"root\" even though\n        // `components` splits it into two: (Prefix, RootDir).\n        let root = match iter.peek() {\n            Some(Component::ParentDir) => return Err(NormalizeError),\n            Some(p @ Component::RootDir) | Some(p @ Component::CurDir) => {\n                lexical.push(p);\n                iter.next();\n                lexical.as_os_str().len()\n            }\n            Some(Component::Prefix(prefix)) => {\n                lexical.push(prefix.as_os_str());\n                iter.next();\n                if let Some(p @ Component::RootDir) = iter.peek() {\n                    lexical.push(p);\n                    iter.next();\n                }\n                lexical.as_os_str().len()\n            }\n            None => return Ok(PathBuf::new()),\n            Some(Component::Normal(_)) => 0,\n        };\n\n        for component in iter {\n            match component {\n                Component::RootDir => unreachable!(),\n                Component::Prefix(_) => return Err(NormalizeError),\n                Component::CurDir => continue,\n                Component::ParentDir => {\n                    // It's an error if ParentDir causes us to go above the \"root\".\n                    if lexical.as_os_str().len() == root {\n                        return Err(NormalizeError);\n                    } else {\n                        lexical.pop();\n                    }\n                }\n                Component::Normal(path) => lexical.push(path),\n            }\n        }\n        Ok(lexical)\n    }"
}