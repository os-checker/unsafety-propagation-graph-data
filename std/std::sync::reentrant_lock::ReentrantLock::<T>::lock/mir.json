{
  "name": "std::sync::reentrant_lock::ReentrantLock::<T>::lock",
  "span": "$library/std/src/sync/reentrant_lock.rs:284:5: 284:52",
  "mir": "fn std::sync::reentrant_lock::ReentrantLock::<T>::lock(_1: &sync::reentrant_lock::ReentrantLock<T>) -> sync::reentrant_lock::ReentrantLockGuard<'_, T> {\n    let mut _0: sync::reentrant_lock::ReentrantLockGuard<'_, T>;\n    let  _2: thread::id::ThreadId;\n    let mut _3: bool;\n    let mut _4: &sync::reentrant_lock::Tid;\n    let  _5: ();\n    let mut _6: core::option::Option<()>;\n    let mut _7: &str;\n    let  _8: ();\n    let mut _9: &sys::sync::mutex::futex::Mutex;\n    let  _10: ();\n    let mut _11: &sync::reentrant_lock::Tid;\n    let mut _12: core::option::Option<thread::id::ThreadId>;\n    let mut _13: (&u32, &u32);\n    let mut _14: &u32;\n    let  _15: *mut u32;\n    let mut _16: &core::cell::UnsafeCell<u32>;\n    let mut _17: &u32;\n    let  _18: &u32;\n    let  _19: &u32;\n    let mut _20: bool;\n    let mut _21: u32;\n    let mut _22: u32;\n    let  _23: core::panicking::AssertKind;\n    let  _24: !;\n    let mut _25: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _26: *mut u32;\n    let mut _27: &core::cell::UnsafeCell<u32>;\n    let mut _28: *const ();\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: *const ();\n    let mut _34: usize;\n    let mut _35: usize;\n    let mut _36: usize;\n    let mut _37: bool;\n    let mut _38: *const ();\n    let mut _39: usize;\n    let mut _40: bool;\n    let mut _41: bool;\n    let mut _42: bool;\n    let mut _43: *const ();\n    let mut _44: usize;\n    let mut _45: bool;\n    let mut _46: bool;\n    let mut _47: bool;\n    let mut _48: bool;\n    debug self => _1;\n    debug this_thread => _2;\n    debug left_val => _18;\n    debug right_val => _19;\n    debug kind => _23;\n    bb0: {\n        _2 = thread::current::current_id() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).1: sync::reentrant_lock::Tid);\n        _3 = sync::reentrant_lock::Tid::contains(move _4, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _3) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = sync::reentrant_lock::ReentrantLock::<T>::increment_lock_count(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = \"lock count overflow in reentrant mutex\";\n        _5 = core::option::Option::<()>::expect(move _6, move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb13;\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageLive(_9);\n        _9 = &((*_1).0: sys::sync::mutex::futex::Mutex);\n        _8 = sys::sync::mutex::futex::Mutex::lock(move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = &((*_1).1: sync::reentrant_lock::Tid);\n        StorageLive(_12);\n        _12 = core::option::Option::Some(_2);\n        _10 = sync::reentrant_lock::Tid::set(move _11, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &((*_1).2: core::cell::UnsafeCell<u32>);\n        _15 = core::cell::UnsafeCell::<u32>::get(move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        _33 = _15 as *const ();\n        _34 = _33 as usize;\n        _35 = Sub(<u32 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _36 = BitAnd(_34, _35);\n        _37 = Eq(_36, 0_usize);\n        assert(_37, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<u32 as core::mem::SizedTypeProperties>::ALIGN, _34) -> [success: bb15, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &((*_1).2: core::cell::UnsafeCell<u32>);\n        _26 = core::cell::UnsafeCell::<u32>::get(move _27) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _23 = core::panicking::AssertKind::Eq;\n        StorageLive(_25);\n        _25 = core::option::Option::None;\n        _24 = core::panicking::assert_failed::<u32, u32>(_23, _18, _19, move _25) -> unwind unreachable;\n    }\n    bb12: {\n        StorageDead(_27);\n        _28 = _26 as *const ();\n        _29 = _28 as usize;\n        _30 = Sub(<u32 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _31 = BitAnd(_29, _30);\n        _32 = Eq(_31, 0_usize);\n        assert(_32, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<u32 as core::mem::SizedTypeProperties>::ALIGN, _29) -> [success: bb14, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_3);\n        _0 = ReentrantLockGuard(_1);\n        return;\n    }\n    bb14: {\n        _43 = _26 as *const ();\n        _44 = _43 as usize;\n        _45 = Ne(<u32 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _46 = Eq(_44, 0_usize);\n        _47 = BitAnd(_46, _45);\n        _48 = Not(_47);\n        assert(_48, \"null pointer dereference occurred\") -> [success: bb17, unwind unreachable];\n    }\n    bb15: {\n        _38 = _15 as *const ();\n        _39 = _38 as usize;\n        _40 = Eq(_39, 0_usize);\n        _41 = BitAnd(_40, true);\n        _42 = Not(_41);\n        assert(_42, \"null pointer dereference occurred\") -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _14 = &(*_15);\n        StorageLive(_17);\n        _17 = sync::reentrant_lock::ReentrantLock::<T>::lock::promoted[0];\n        _13 = (move _14, move _17);\n        StorageDead(_17);\n        StorageDead(_14);\n        _18 = (_13.0: &u32);\n        _19 = (_13.1: &u32);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = (*_18);\n        StorageLive(_22);\n        _22 = (*_19);\n        _20 = Eq(move _21, move _22);\n        switchInt(move _20) -> [0: bb11, otherwise: bb10];\n    }\n    bb17: {\n        (*_26) = 1_u32;\n        StorageDead(_26);\n        goto -> bb13;\n    }\n}\n"
}