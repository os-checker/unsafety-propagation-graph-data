{
  "name": "std::alloc::default_alloc_error_hook",
  "span": "$library/std/src/alloc.rs:355:1: 355:44",
  "src": "fn default_alloc_error_hook(layout: Layout) {\n    if cfg!(panic = \"immediate-abort\") {\n        return;\n    }\n\n    unsafe extern \"Rust\" {\n        // This symbol is emitted by rustc next to __rust_alloc_error_handler.\n        // Its value depends on the -Zoom={panic,abort} compiler option.\n        #[rustc_std_internal_symbol]\n        fn __rust_alloc_error_handler_should_panic_v2() -> u8;\n    }\n\n    if unsafe { __rust_alloc_error_handler_should_panic_v2() != 0 } {\n        panic!(\"memory allocation of {} bytes failed\", layout.size());\n    }\n\n    // This is the default path taken on OOM, and the only path taken on stable with std.\n    // Crucially, it does *not* call any user-defined code, and therefore users do not have to\n    // worry about allocation failure causing reentrancy issues. That makes it different from\n    // the default `__rdl_alloc_error_handler` defined in alloc (i.e., the default alloc error\n    // handler that is  called when there is no `#[alloc_error_handler]`), which triggers a\n    // regular panic and thus can invoke a user-defined panic hook, executing arbitrary\n    // user-defined code.\n\n    static PREV_ALLOC_FAILURE: AtomicBool = AtomicBool::new(false);\n    if PREV_ALLOC_FAILURE.swap(true, Ordering::Relaxed) {\n        // Don't try to print a backtrace if a previous alloc error happened. This likely means\n        // there is not enough memory to print a backtrace, although it could also mean that two\n        // threads concurrently run out of memory.\n        rtprintpanic!(\n            \"memory allocation of {} bytes failed\\nskipping backtrace printing to avoid potential recursion\\n\",\n            layout.size()\n        );\n        return;\n    } else {\n        rtprintpanic!(\"memory allocation of {} bytes failed\\n\", layout.size());\n    }\n\n    let Some(mut out) = crate::sys::stdio::panic_output() else {\n        return;\n    };\n\n    // Use a lock to prevent mixed output in multithreading context.\n    // Some platforms also require it when printing a backtrace, like `SymFromAddr` on Windows.\n    // Make sure to not take this lock until after checking PREV_ALLOC_FAILURE to avoid deadlocks\n    // when there is too little memory to print a backtrace.\n    let mut lock = crate::sys::backtrace::lock();\n\n    match crate::panic::get_backtrace_style() {\n        Some(crate::panic::BacktraceStyle::Short) => {\n            drop(lock.print(&mut out, crate::backtrace_rs::PrintFmt::Short))\n        }\n        Some(crate::panic::BacktraceStyle::Full) => {\n            drop(lock.print(&mut out, crate::backtrace_rs::PrintFmt::Full))\n        }\n        Some(crate::panic::BacktraceStyle::Off) => {\n            use crate::io::Write;\n            let _ = writeln!(\n                out,\n                \"note: run with `RUST_BACKTRACE=1` environment variable to display a \\\n                             backtrace\"\n            );\n            if cfg!(miri) {\n                let _ = writeln!(\n                    out,\n                    \"note: in Miri, you may have to set `MIRIFLAGS=-Zmiri-env-forward=RUST_BACKTRACE` \\\n                                for the environment variable to have an effect\"\n                );\n            }\n        }\n        // If backtraces aren't supported or are forced-off, do nothing.\n        None => {}\n    }\n}"
}