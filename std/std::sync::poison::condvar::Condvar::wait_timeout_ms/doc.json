{
  "name": "std::sync::poison::condvar::Condvar::wait_timeout_ms",
  "span": "$library/std/src/sync/poison/condvar.rs:252:5: 256:47",
  "doc": " Waits on this condition variable for a notification, timing out after a\n specified duration.\n\n The semantics of this function are equivalent to [`wait`]\n except that the thread will be blocked for roughly no longer\n than `ms` milliseconds. This method should not be used for\n precise timing due to anomalies such as preemption or platform\n differences that might not cause the maximum amount of time\n waited to be precisely `ms`.\n\n Note that the best effort is made to ensure that the time waited is\n measured with a monotonic clock, and not affected by the changes made to\n the system time.\n\n The returned boolean is `false` only if the timeout is known\n to have elapsed.\n\n Like [`wait`], the lock specified will be re-acquired when this function\n returns, regardless of whether the timeout elapsed or not.\n\n [`wait`]: Self::wait\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex, Condvar};\n use std::thread;\n\n let pair = Arc::new((Mutex::new(false), Condvar::new()));\n let pair2 = Arc::clone(&pair);\n\n thread::spawn(move || {\n     let (lock, cvar) = &*pair2;\n     let mut started = lock.lock().unwrap();\n     *started = true;\n     // We notify the condvar that the value has changed.\n     cvar.notify_one();\n });\n\n // Wait for the thread to start up.\n let (lock, cvar) = &*pair;\n let mut started = lock.lock().unwrap();\n // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n loop {\n     let result = cvar.wait_timeout_ms(started, 10).unwrap();\n     // 10 milliseconds have passed, or maybe the value changed!\n     started = result.0;\n     if *started == true {\n         // We received the notification and the value has been updated, we can leave.\n         break\n     }\n }\n ```\n"
}