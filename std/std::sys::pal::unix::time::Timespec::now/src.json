{
  "name": "std::sys::pal::unix::time::Timespec::now",
  "span": "$library/std/src/sys/pal/unix/time.rs:99:5: 99:51",
  "src": "pub fn now(clock: libc::clockid_t) -> Timespec {\n        use crate::mem::MaybeUninit;\n        use crate::sys::cvt;\n\n        // Try to use 64-bit time in preparation for Y2038.\n        #[cfg(all(\n            target_os = \"linux\",\n            target_env = \"gnu\",\n            target_pointer_width = \"32\",\n            not(target_arch = \"riscv32\")\n        ))]\n        {\n            use crate::sys::weak::weak;\n\n            // __clock_gettime64 was added to 32-bit arches in glibc 2.34,\n            // and it handles both vDSO calls and ENOSYS fallbacks itself.\n            weak!(\n                fn __clock_gettime64(\n                    clockid: libc::clockid_t,\n                    tp: *mut __timespec64,\n                ) -> libc::c_int;\n            );\n\n            if let Some(clock_gettime64) = __clock_gettime64.get() {\n                let mut t = MaybeUninit::uninit();\n                cvt(unsafe { clock_gettime64(clock, t.as_mut_ptr()) }).unwrap();\n                let t = unsafe { t.assume_init() };\n                return Timespec::new(t.tv_sec as i64, t.tv_nsec as i64).unwrap();\n            }\n        }\n\n        let mut t = MaybeUninit::uninit();\n        cvt(unsafe { libc::clock_gettime(clock, t.as_mut_ptr()) }).unwrap();\n        let t = unsafe { t.assume_init() };\n        Timespec::new(t.tv_sec as i64, t.tv_nsec as i64).unwrap()\n    }"
}