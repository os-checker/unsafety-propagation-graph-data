{
  "name": "std::<io::buffered::bufreader::BufReader<I> as io::copy::BufferedReaderSpec>::copy_to",
  "span": "$library/std/src/io/copy.rs:157:5: 157:73",
  "src": "fn copy_to(&mut self, to: &mut (impl Write + ?Sized)) -> Result<u64> {\n        let mut len = 0;\n\n        loop {\n            // Hack: this relies on `impl Read for BufReader` always calling fill_buf\n            // if the buffer is empty, even for empty slices.\n            // It can't be called directly here since specialization prevents us\n            // from adding I: Read\n            match self.read(&mut []) {\n                Ok(_) => {}\n                Err(e) if e.is_interrupted() => continue,\n                Err(e) => return Err(e),\n            }\n            let buf = self.buffer();\n            if self.buffer().len() == 0 {\n                return Ok(len);\n            }\n\n            // In case the writer side is a BufWriter then its write_all\n            // implements an optimization that passes through large\n            // buffers to the underlying writer. That code path is #[cold]\n            // but we're still avoiding redundant memcopies when doing\n            // a copy between buffered inputs and outputs.\n            to.write_all(buf)?;\n            len += buf.len() as u64;\n            self.discard_buffer();\n        }\n    }"
}