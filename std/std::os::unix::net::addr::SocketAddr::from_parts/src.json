{
  "name": "std::os::unix::net::addr::SocketAddr::from_parts",
  "span": "$library/std/src/os/unix/net/addr.rs:104:5: 107:32",
  "src": "pub(super) fn from_parts(\n        addr: libc::sockaddr_un,\n        mut len: libc::socklen_t,\n    ) -> io::Result<SocketAddr> {\n        if cfg!(target_os = \"openbsd\") {\n            // on OpenBSD, getsockname(2) returns the actual size of the socket address,\n            // and not the len of the content. Figure out the length for ourselves.\n            // https://marc.info/?l=openbsd-bugs&m=170105481926736&w=2\n            let sun_path: &[u8] =\n                unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&addr.sun_path) };\n            len = core::slice::memchr::memchr(0, sun_path)\n                .map_or(len, |new_len| (new_len + SUN_PATH_OFFSET) as libc::socklen_t);\n        }\n\n        if len == 0 {\n            // When there is a datagram from unnamed unix socket\n            // linux returns zero bytes of address\n            len = SUN_PATH_OFFSET as libc::socklen_t; // i.e., zero-length address\n        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n            return Err(io::const_error!(\n                io::ErrorKind::InvalidInput,\n                \"file descriptor did not correspond to a Unix socket\",\n            ));\n        }\n\n        Ok(SocketAddr { addr, len })\n    }"
}