{
  "name": "std::sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd",
  "span": "$library/std/src/sys/process/unix/unix.rs:832:5: 832:57",
  "src": "fn send_pidfd(&self, sock: &crate::sys::net::Socket) {\n        use libc::{CMSG_DATA, CMSG_FIRSTHDR, CMSG_LEN, CMSG_SPACE, SCM_RIGHTS, SOL_SOCKET};\n\n        use crate::io::IoSlice;\n        use crate::os::fd::RawFd;\n        use crate::sys::cvt_r;\n\n        unsafe {\n            let child_pid = libc::getpid();\n            // pidfd_open sets CLOEXEC by default\n            let pidfd = libc::syscall(libc::SYS_pidfd_open, child_pid, 0);\n\n            let fds: [c_int; 1] = [pidfd as RawFd];\n\n            const SCM_MSG_LEN: usize = size_of::<[c_int; 1]>();\n\n            #[repr(C)]\n            union Cmsg {\n                buf: [u8; unsafe { CMSG_SPACE(SCM_MSG_LEN as u32) as usize }],\n                _align: libc::cmsghdr,\n            }\n\n            let mut cmsg: Cmsg = mem::zeroed();\n\n            // 0-length message to send through the socket so we can pass along the fd\n            let mut iov = [IoSlice::new(b\"\")];\n            let mut msg: libc::msghdr = mem::zeroed();\n\n            msg.msg_iov = (&raw mut iov) as *mut _;\n            msg.msg_iovlen = 1;\n\n            // only attach cmsg if we successfully acquired the pidfd\n            if pidfd >= 0 {\n                msg.msg_controllen = size_of_val(&cmsg.buf) as _;\n                msg.msg_control = (&raw mut cmsg.buf) as *mut _;\n\n                let hdr = CMSG_FIRSTHDR((&raw mut msg) as *mut _);\n                (*hdr).cmsg_level = SOL_SOCKET;\n                (*hdr).cmsg_type = SCM_RIGHTS;\n                (*hdr).cmsg_len = CMSG_LEN(SCM_MSG_LEN as _) as _;\n                let data = CMSG_DATA(hdr);\n                crate::ptr::copy_nonoverlapping(\n                    fds.as_ptr().cast::<u8>(),\n                    data as *mut _,\n                    SCM_MSG_LEN,\n                );\n            }\n\n            // we send the 0-length message even if we failed to acquire the pidfd\n            // so we get a consistent SEQPACKET order\n            match cvt_r(|| libc::sendmsg(sock.as_raw(), &msg, 0)) {\n                Ok(0) => {}\n                other => rtabort!(\"failed to communicate with parent process. {:?}\", other),\n            }\n        }\n    }"
}