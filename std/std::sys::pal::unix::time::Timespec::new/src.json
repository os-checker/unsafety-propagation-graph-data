{
  "name": "std::sys::pal::unix::time::Timespec::new",
  "span": "$library/std/src/sys/pal/unix/time.rs:72:5: 72:75",
  "src": "const fn new(tv_sec: i64, tv_nsec: i64) -> Result<Timespec, io::Error> {\n        // On Apple OS, dates before epoch are represented differently than on other\n        // Unix platforms: e.g. 1/10th of a second before epoch is represented as `seconds=-1`\n        // and `nanoseconds=100_000_000` on other platforms, but is `seconds=0` and\n        // `nanoseconds=-900_000_000` on Apple OS.\n        //\n        // To compensate, we first detect this special case by checking if both\n        // seconds and nanoseconds are in range, and then correct the value for seconds\n        // and nanoseconds to match the common unix representation.\n        //\n        // Please note that Apple OS nonetheless accepts the standard unix format when\n        // setting file times, which makes this compensation round-trippable and generally\n        // transparent.\n        #[cfg(target_vendor = \"apple\")]\n        let (tv_sec, tv_nsec) =\n            if (tv_sec <= 0 && tv_sec > i64::MIN) && (tv_nsec < 0 && tv_nsec > -1_000_000_000) {\n                (tv_sec - 1, tv_nsec + 1_000_000_000)\n            } else {\n                (tv_sec, tv_nsec)\n            };\n        if tv_nsec >= 0 && tv_nsec < NSEC_PER_SEC as i64 {\n            Ok(unsafe { Self::new_unchecked(tv_sec, tv_nsec) })\n        } else {\n            Err(io::const_error!(io::ErrorKind::InvalidData, \"invalid timestamp\"))\n        }\n    }"
}