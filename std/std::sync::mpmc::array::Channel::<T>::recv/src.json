{
  "name": "std::sync::mpmc::array::Channel::<T>::recv",
  "span": "$library/std/src/sync/mpmc/array.rs:375:5: 375:88",
  "src": "pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n        let token = &mut Token::default();\n        loop {\n            // Try receiving a message.\n            if self.start_recv(token) {\n                let res = unsafe { self.read(token) };\n                return res.map_err(|_| RecvTimeoutError::Disconnected);\n            }\n\n            if let Some(d) = deadline {\n                if Instant::now() >= d {\n                    return Err(RecvTimeoutError::Timeout);\n                }\n            }\n\n            Context::with(|cx| {\n                // Prepare for blocking until a sender wakes us up.\n                let oper = Operation::hook(token);\n                self.receivers.register(oper, cx);\n\n                // Has the channel become ready just now?\n                if !self.is_empty() || self.is_disconnected() {\n                    let _ = cx.try_select(Selected::Aborted);\n                }\n\n                // Block the current thread.\n                // SAFETY: the context belongs to the current thread.\n                let sel = unsafe { cx.wait_until(deadline) };\n\n                match sel {\n                    Selected::Waiting => unreachable!(),\n                    Selected::Aborted | Selected::Disconnected => {\n                        self.receivers.unregister(oper).unwrap();\n                        // If the channel was disconnected, we still have to check for remaining\n                        // messages.\n                    }\n                    Selected::Operation(_) => {}\n                }\n            });\n        }\n    }"
}