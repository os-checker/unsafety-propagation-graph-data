{
  "name": "std::sys::net::connection::socket::unix::Socket::accept",
  "span": "$library/std/src/sys/net/connection/socket/unix.rs:241:5: 241:92",
  "src": "pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n        // Unfortunately the only known way right now to accept a socket and\n        // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n        // platforms that support it. On Linux, this was added in 2.6.28,\n        // glibc 2.10 and musl 0.9.5.\n        cfg_select! {\n            any(\n                target_os = \"android\",\n                target_os = \"dragonfly\",\n                target_os = \"freebsd\",\n                target_os = \"illumos\",\n                target_os = \"linux\",\n                target_os = \"hurd\",\n                target_os = \"netbsd\",\n                target_os = \"openbsd\",\n                target_os = \"cygwin\",\n            ) => {\n                unsafe {\n                    let fd = cvt_r(|| libc::accept4(self.as_raw_fd(), storage, len, libc::SOCK_CLOEXEC))?;\n                    Ok(Socket(FileDesc::from_raw_fd(fd)))\n                }\n            }\n            _ => {\n                unsafe {\n                    let fd = cvt_r(|| libc::accept(self.as_raw_fd(), storage, len))?;\n                    let fd = FileDesc::from_raw_fd(fd);\n                    fd.set_cloexec()?;\n                    Ok(Socket(fd))\n                }\n            }\n        }\n    }"
}