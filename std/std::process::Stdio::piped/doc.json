{
  "name": "std::process::Stdio::piped",
  "span": "$library/std/src/process.rs:1481:5: 1481:28",
  "doc": " A new pipe should be arranged to connect the parent and child processes.\n\n # Examples\n\n With stdout:\n\n ```no_run\n use std::process::{Command, Stdio};\n\n let output = Command::new(\"echo\")\n     .arg(\"Hello, world!\")\n     .stdout(Stdio::piped())\n     .output()\n     .expect(\"Failed to execute command\");\n\n assert_eq!(String::from_utf8_lossy(&output.stdout), \"Hello, world!\\n\");\n // Nothing echoed to console\n ```\n\n With stdin:\n\n ```no_run\n use std::io::Write;\n use std::process::{Command, Stdio};\n\n let mut child = Command::new(\"rev\")\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .spawn()\n     .expect(\"Failed to spawn child process\");\n\n let mut stdin = child.stdin.take().expect(\"Failed to open stdin\");\n std::thread::spawn(move || {\n     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n });\n\n let output = child.wait_with_output().expect(\"Failed to read stdout\");\n assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n ```\n\n Writing more than a pipe buffer's worth of input to stdin without also reading\n stdout and stderr at the same time may cause a deadlock.\n This is an issue when running any program that doesn't guarantee that it reads\n its entire stdin before writing more than a pipe buffer's worth of output.\n The size of a pipe buffer varies on different targets.\n\n"
}