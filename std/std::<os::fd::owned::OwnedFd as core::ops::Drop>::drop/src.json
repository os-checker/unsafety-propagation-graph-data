{
  "name": "std::<os::fd::owned::OwnedFd as core::ops::Drop>::drop",
  "span": "$library/std/src/os/fd/owned.rs:190:5: 190:23",
  "src": "fn drop(&mut self) {\n        unsafe {\n            // Note that errors are ignored when closing a file descriptor. According to POSIX 2024,\n            // we can and indeed should retry `close` on `EINTR`\n            // (https://pubs.opengroup.org/onlinepubs/9799919799.2024edition/functions/close.html),\n            // but it is not clear yet how well widely-used implementations are conforming with this\n            // mandate since older versions of POSIX left the state of the FD after an `EINTR`\n            // unspecified. Ignoring errors is \"fine\" because some of the major Unices (in\n            // particular, Linux) do make sure to always close the FD, even when `close()` is\n            // interrupted, and the scenario is rare to begin with. If we retried on a\n            // not-POSIX-compliant implementation, the consequences could be really bad since we may\n            // close the wrong FD. Helpful link to an epic discussion by POSIX workgroup that led to\n            // the latest POSIX wording: http://austingroupbugs.net/view.php?id=529\n            #[cfg(not(target_os = \"hermit\"))]\n            {\n                #[cfg(unix)]\n                crate::sys::fs::debug_assert_fd_is_open(self.fd.as_inner());\n\n                let _ = libc::close(self.fd.as_inner());\n            }\n            #[cfg(target_os = \"hermit\")]\n            let _ = hermit_abi::close(self.fd.as_inner());\n        }\n    }"
}