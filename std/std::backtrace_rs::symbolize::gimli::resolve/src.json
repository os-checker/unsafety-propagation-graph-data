{
  "name": "std::backtrace_rs::symbolize::gimli::resolve",
  "span": "$library/std/src/../../backtrace/src/symbolize/gimli.rs:441:1: 441:81",
  "src": "pub unsafe fn resolve(what: ResolveWhat<'_>, cb: &mut dyn FnMut(&super::Symbol)) {\n    let addr = what.address_or_ip();\n    let mut call = |sym: Symbol<'_>| {\n        // Extend the lifetime of `sym` to `'static` since we are unfortunately\n        // required to here, but it's only ever going out as a reference so no\n        // reference to it should be persisted beyond this frame anyway.\n        // SAFETY: praying the above is correct\n        let sym = unsafe { mem::transmute::<Symbol<'_>, Symbol<'static>>(sym) };\n        (cb)(&super::Symbol { inner: sym });\n    };\n\n    unsafe {\n        Cache::with_global(|cache| {\n            let (lib, addr) = match cache.avma_to_svma(addr.cast_const().cast::<u8>()) {\n                Some(pair) => pair,\n                None => return,\n            };\n\n            // Finally, get a cached mapping or create a new mapping for this file, and\n            // evaluate the DWARF info to find the file/line/name for this address.\n            let (cx, stash) = match cache.mapping_for_lib(lib) {\n                Some((cx, stash)) => (cx, stash),\n                None => return,\n            };\n            let mut any_frames = false;\n            if let Ok(mut frames) = cx.find_frames(stash, addr as u64) {\n                while let Ok(Some(frame)) = frames.next() {\n                    any_frames = true;\n                    let name = match frame.function {\n                        Some(f) => Some(f.name.slice()),\n                        None => cx.object.search_symtab(addr as u64),\n                    };\n                    call(Symbol::Frame {\n                        addr: addr as *mut c_void,\n                        location: frame.location,\n                        name,\n                    });\n                }\n            }\n            if !any_frames {\n                if let Some((object_cx, object_addr)) = cx.object.search_object_map(addr as u64) {\n                    if let Ok(mut frames) = object_cx.find_frames(stash, object_addr) {\n                        while let Ok(Some(frame)) = frames.next() {\n                            any_frames = true;\n                            call(Symbol::Frame {\n                                addr: addr as *mut c_void,\n                                location: frame.location,\n                                name: frame.function.map(|f| f.name.slice()),\n                            });\n                        }\n                    }\n                }\n            }\n            if !any_frames {\n                if let Some(name) = cx.object.search_symtab(addr as u64) {\n                    call(Symbol::Symtab { name });\n                }\n            }\n        });\n    }\n}"
}