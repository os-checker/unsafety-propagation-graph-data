{
  "name": "std::<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::ops::Drop>::drop",
  "span": "$library/std/src/sync/reentrant_lock.rs:422:5: 422:23",
  "mir": "fn std::<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::ops::Drop>::drop(_1: &mut sync::reentrant_lock::ReentrantLockGuard<'_, T>) -> () {\n    let mut _0: ();\n    let mut _2: *mut u32;\n    let mut _3: &core::cell::UnsafeCell<u32>;\n    let mut _4: (u32, bool);\n    let mut _5: u32;\n    let mut _6: *mut u32;\n    let mut _7: &core::cell::UnsafeCell<u32>;\n    let  _8: ();\n    let mut _9: &sync::reentrant_lock::Tid;\n    let mut _10: core::option::Option<thread::id::ThreadId>;\n    let  _11: ();\n    let mut _12: &sys::sync::mutex::futex::Mutex;\n    let mut _13: &sync::reentrant_lock::ReentrantLock<T>;\n    let mut _14: &sync::reentrant_lock::ReentrantLock<T>;\n    let mut _15: &sync::reentrant_lock::ReentrantLock<T>;\n    let mut _16: &sync::reentrant_lock::ReentrantLock<T>;\n    let mut _17: *const ();\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: bool;\n    let mut _22: *const ();\n    let mut _23: usize;\n    let mut _24: usize;\n    let mut _25: usize;\n    let mut _26: bool;\n    let mut _27: *const ();\n    let mut _28: usize;\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: bool;\n    let mut _32: *const ();\n    let mut _33: usize;\n    let mut _34: bool;\n    let mut _35: bool;\n    let mut _36: bool;\n    let mut _37: bool;\n    let mut _38: *const ();\n    let mut _39: usize;\n    let mut _40: bool;\n    let mut _41: bool;\n    let mut _42: bool;\n    let mut _43: bool;\n    let mut _44: *const ();\n    let mut _45: usize;\n    let mut _46: bool;\n    let mut _47: bool;\n    let mut _48: bool;\n    let mut _49: bool;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _13 = ((*_1).0: &sync::reentrant_lock::ReentrantLock<T>);\n        _3 = &((*_13).2: core::cell::UnsafeCell<u32>);\n        _2 = core::cell::UnsafeCell::<u32>::get(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _27 = _2 as *const ();\n        _28 = _27 as usize;\n        _29 = Sub(<u32 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _30 = BitAnd(_28, _29);\n        _31 = Eq(_30, 0_usize);\n        assert(_31, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<u32 as core::mem::SizedTypeProperties>::ALIGN, _28) -> [success: bb11, unwind unreachable];\n    }\n    bb2: {\n        _22 = _2 as *const ();\n        _23 = _22 as usize;\n        _24 = Sub(<u32 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _25 = BitAnd(_23, _24);\n        _26 = Eq(_25, 0_usize);\n        assert(_26, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<u32 as core::mem::SizedTypeProperties>::ALIGN, _23) -> [success: bb10, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _17 = _6 as *const ();\n        _18 = _17 as usize;\n        _19 = Sub(<u32 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _20 = BitAnd(_18, _19);\n        _21 = Eq(_20, 0_usize);\n        assert(_21, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<u32 as core::mem::SizedTypeProperties>::ALIGN, _18) -> [success: bb9, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_9);\n        _15 = ((*_1).0: &sync::reentrant_lock::ReentrantLock<T>);\n        _9 = &((*_15).1: sync::reentrant_lock::Tid);\n        StorageLive(_10);\n        _10 = core::option::Option::None;\n        _8 = sync::reentrant_lock::Tid::set(move _9, move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_12);\n        _16 = ((*_1).0: &sync::reentrant_lock::ReentrantLock<T>);\n        _12 = &((*_16).0: sys::sync::mutex::futex::Mutex);\n        _11 = sys::sync::mutex::futex::Mutex::unlock(move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        goto -> bb8;\n    }\n    bb7: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb8;\n    }\n    bb8: {\n        return;\n    }\n    bb9: {\n        _44 = _6 as *const ();\n        _45 = _44 as usize;\n        _46 = Ne(<u32 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _47 = Eq(_45, 0_usize);\n        _48 = BitAnd(_47, _46);\n        _49 = Not(_48);\n        assert(_49, \"null pointer dereference occurred\") -> [success: bb14, unwind unreachable];\n    }\n    bb10: {\n        _38 = _2 as *const ();\n        _39 = _38 as usize;\n        _40 = Ne(<u32 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _41 = Eq(_39, 0_usize);\n        _42 = BitAnd(_41, _40);\n        _43 = Not(_42);\n        assert(_43, \"null pointer dereference occurred\") -> [success: bb13, unwind unreachable];\n    }\n    bb11: {\n        _32 = _2 as *const ();\n        _33 = _32 as usize;\n        _34 = Ne(<u32 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _35 = Eq(_33, 0_usize);\n        _36 = BitAnd(_35, _34);\n        _37 = Not(_36);\n        assert(_37, \"null pointer dereference occurred\") -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _4 = CheckedSub((*_2), 1_u32);\n        assert(!move (_4.1: bool), \"attempt to compute `{} - {}`, which would overflow\", (*_2), 1_u32) -> [success: bb2, unwind unreachable];\n    }\n    bb13: {\n        (*_2) = move (_4.0: u32);\n        StorageDead(_2);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _14 = ((*_1).0: &sync::reentrant_lock::ReentrantLock<T>);\n        _7 = &((*_14).2: core::cell::UnsafeCell<u32>);\n        _6 = core::cell::UnsafeCell::<u32>::get(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb14: {\n        _5 = (*_6);\n        switchInt(move _5) -> [0: bb4, otherwise: bb7];\n    }\n}\n"
}