{
  "name": "std::<alloc::System as core::alloc::Allocator>::shrink",
  "span": "$library/std/src/alloc.rs:254:5: 259:43",
  "src": "unsafe fn shrink(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        debug_assert!(\n            new_layout.size() <= old_layout.size(),\n            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n        );\n\n        match new_layout.size() {\n            // SAFETY: conditions must be upheld by the caller\n            0 => unsafe {\n                Allocator::deallocate(self, ptr, old_layout);\n                Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n            },\n\n            // SAFETY: `new_size` is non-zero. Other conditions must be upheld by the caller\n            new_size if old_layout.align() == new_layout.align() => unsafe {\n                // `realloc` probably checks for `new_size <= old_layout.size()` or something similar.\n                hint::assert_unchecked(new_size <= old_layout.size());\n\n                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);\n                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n            },\n\n            // SAFETY: because `new_size` must be smaller than or equal to `old_layout.size()`,\n            // both the old and new memory allocation are valid for reads and writes for `new_size`\n            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n            // for `dealloc` must be upheld by the caller.\n            new_size => unsafe {\n                let new_ptr = Allocator::allocate(self, new_layout)?;\n                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n                Allocator::deallocate(self, ptr, old_layout);\n                Ok(new_ptr)\n            },\n        }\n    }"
}