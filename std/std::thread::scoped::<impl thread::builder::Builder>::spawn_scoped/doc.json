{
  "name": "std::thread::scoped::<impl thread::builder::Builder>::spawn_scoped",
  "span": "$library/std/src/thread/scoped.rs:255:5: 262:26",
  "doc": " Spawns a new scoped thread using the settings set through this `Builder`.\n\n Unlike [`Scope::spawn`], this method yields an [`io::Result`] to\n capture any failure to create the thread at the OS level.\n\n [`io::Result`]: crate::io::Result\n\n # Panics\n\n Panics if a thread name was set and it contained null bytes.\n\n # Example\n\n ```\n use std::thread;\n\n let mut a = vec![1, 2, 3];\n let mut x = 0;\n\n thread::scope(|s| {\n     thread::Builder::new()\n         .name(\"first\".to_string())\n         .spawn_scoped(s, ||\n     {\n         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n         // We can borrow `a` here.\n         dbg!(&a);\n     })\n     .unwrap();\n     thread::Builder::new()\n         .name(\"second\".to_string())\n         .spawn_scoped(s, ||\n     {\n         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n         // We can even mutably borrow `x` here,\n         // because no other threads are using it.\n         x += a[0] + a[2];\n     })\n     .unwrap();\n     println!(\"hello from the main thread\");\n });\n\n // After the scope, we can modify and access our variables again:\n a.push(4);\n assert_eq!(x, a.len());\n ```\n"
}