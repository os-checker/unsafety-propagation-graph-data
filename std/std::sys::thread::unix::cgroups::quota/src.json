{
  "name": "std::sys::thread::unix::cgroups::quota",
  "span": "$library/std/src/sys/thread/unix.rs:658:5: 658:35",
  "src": "pub(super) fn quota() -> usize {\n        let mut quota = usize::MAX;\n        if cfg!(miri) {\n            // Attempting to open a file fails under default flags due to isolation.\n            // And Miri does not have parallelism anyway.\n            return quota;\n        }\n\n        let _: Option<()> = try {\n            let mut buf = Vec::with_capacity(128);\n            // find our place in the cgroup hierarchy\n            File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n            let (cgroup_path, version) =\n                buf.split(|&c| c == b'\\n').fold(None, |previous, line| {\n                    let mut fields = line.splitn(3, |&c| c == b':');\n                    // 2nd field is a list of controllers for v1 or empty for v2\n                    let version = match fields.nth(1) {\n                        Some(b\"\") => Cgroup::V2,\n                        Some(controllers)\n                            if from_utf8(controllers)\n                                .is_ok_and(|c| c.split(',').any(|c| c == \"cpu\")) =>\n                        {\n                            Cgroup::V1\n                        }\n                        _ => return previous,\n                    };\n\n                    // already-found v1 trumps v2 since it explicitly specifies its controllers\n                    if previous.is_some() && version == Cgroup::V2 {\n                        return previous;\n                    }\n\n                    let path = fields.last()?;\n                    // skip leading slash\n                    Some((path[1..].to_owned(), version))\n                })?;\n            let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n\n            quota = match version {\n                Cgroup::V1 => quota_v1(cgroup_path),\n                Cgroup::V2 => quota_v2(cgroup_path),\n            };\n        };\n\n        quota\n    }"
}