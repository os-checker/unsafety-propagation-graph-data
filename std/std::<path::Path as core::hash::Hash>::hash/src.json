{
  "name": "std::<path::Path as core::hash::Hash>::hash",
  "span": "$library/std/src/path.rs:3658:5: 3658:41",
  "src": "fn hash<H: Hasher>(&self, h: &mut H) {\n        let bytes = self.as_u8_slice();\n        let (prefix_len, verbatim) = match parse_prefix(&self.inner) {\n            Some(prefix) => {\n                prefix.hash(h);\n                (prefix.len(), prefix.is_verbatim())\n            }\n            None => (0, false),\n        };\n        let bytes = &bytes[prefix_len..];\n\n        let mut component_start = 0;\n        // track some extra state to avoid prefix collisions.\n        // [\"foo\", \"bar\"] and [\"foobar\"], will have the same payload bytes\n        // but result in different chunk_bits\n        let mut chunk_bits: usize = 0;\n\n        for i in 0..bytes.len() {\n            let is_sep = if verbatim { is_verbatim_sep(bytes[i]) } else { is_sep_byte(bytes[i]) };\n            if is_sep {\n                if i > component_start {\n                    let to_hash = &bytes[component_start..i];\n                    chunk_bits = chunk_bits.wrapping_add(to_hash.len());\n                    chunk_bits = chunk_bits.rotate_right(2);\n                    h.write(to_hash);\n                }\n\n                // skip over separator and optionally a following CurDir item\n                // since components() would normalize these away.\n                component_start = i + 1;\n\n                let tail = &bytes[component_start..];\n\n                if !verbatim {\n                    component_start += match tail {\n                        [b'.'] => 1,\n                        [b'.', sep, ..] if is_sep_byte(*sep) => 1,\n                        _ => 0,\n                    };\n                }\n            }\n        }\n\n        if component_start < bytes.len() {\n            let to_hash = &bytes[component_start..];\n            chunk_bits = chunk_bits.wrapping_add(to_hash.len());\n            chunk_bits = chunk_bits.rotate_right(2);\n            h.write(to_hash);\n        }\n\n        h.write_usize(chunk_bits);\n    }"
}