{
  "name": "std::sys::pal::unix::init::sanitize_standard_fds",
  "span": "$library/std/src/sys/pal/unix/mod.rs:55:5: 55:38",
  "src": "unsafe fn sanitize_standard_fds() {\n        #[allow(dead_code, unused_variables, unused_mut)]\n        let mut opened_devnull = -1;\n        #[allow(dead_code, unused_variables, unused_mut)]\n        let mut open_devnull = || {\n            #[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n            use libc::open;\n            #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n            use libc::open64 as open;\n\n            if opened_devnull != -1 {\n                if libc::dup(opened_devnull) != -1 {\n                    return;\n                }\n            }\n            opened_devnull = open(c\"/dev/null\".as_ptr(), libc::O_RDWR, 0);\n            if opened_devnull == -1 {\n                // If the stream is closed but we failed to reopen it, abort the\n                // process. Otherwise we wouldn't preserve the safety of\n                // operations on the corresponding Rust object Stdin, Stdout, or\n                // Stderr.\n                libc::abort();\n            }\n        };\n\n        // fast path with a single syscall for systems with poll()\n        #[cfg(not(any(\n            miri,\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"vxworks\",\n            target_os = \"redox\",\n            target_os = \"l4re\",\n            target_os = \"horizon\",\n            target_os = \"vita\",\n            target_os = \"rtems\",\n            // The poll on Darwin doesn't set POLLNVAL for closed fds.\n            target_vendor = \"apple\",\n        )))]\n        'poll: {\n            use crate::sys::os::errno;\n            let pfds: &mut [_] = &mut [\n                libc::pollfd { fd: 0, events: 0, revents: 0 },\n                libc::pollfd { fd: 1, events: 0, revents: 0 },\n                libc::pollfd { fd: 2, events: 0, revents: 0 },\n            ];\n\n            while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n                match errno() {\n                    libc::EINTR => continue,\n                    #[cfg(target_vendor = \"unikraft\")]\n                    libc::ENOSYS => {\n                        // Not all configurations of Unikraft enable `LIBPOSIX_EVENT`.\n                        break 'poll;\n                    }\n                    libc::EINVAL | libc::EAGAIN | libc::ENOMEM => {\n                        // RLIMIT_NOFILE or temporary allocation failures\n                        // may be preventing use of poll(), fall back to fcntl\n                        break 'poll;\n                    }\n                    _ => libc::abort(),\n                }\n            }\n            for pfd in pfds {\n                if pfd.revents & libc::POLLNVAL == 0 {\n                    continue;\n                }\n                open_devnull();\n            }\n            return;\n        }\n\n        // fallback in case poll isn't available or limited by RLIMIT_NOFILE\n        #[cfg(not(any(\n            // The standard fds are always available in Miri.\n            miri,\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"vxworks\",\n            target_os = \"l4re\",\n            target_os = \"horizon\",\n            target_os = \"vita\",\n        )))]\n        {\n            use crate::sys::os::errno;\n            for fd in 0..3 {\n                if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n                    open_devnull();\n                }\n            }\n        }\n    }"
}