{
  "name": "std::io::Read::read_to_string",
  "span": "$library/std/src/io/mod.rs:966:5: 966:68",
  "doc": " Reads all bytes until EOF in this source, appending them to `buf`.\n\n If successful, this function returns the number of bytes which were read\n and appended to `buf`.\n\n # Errors\n\n If the data in this stream is *not* valid UTF-8 then an error is\n returned and `buf` is unchanged.\n\n See [`read_to_end`] for other error semantics.\n\n [`read_to_end`]: Read::read_to_end\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = String::new();\n\n     f.read_to_string(&mut buffer)?;\n     Ok(())\n }\n ```\n\n (See also the [`std::fs::read_to_string`] convenience function for\n reading from a file.)\n\n # Usage Notes\n\n `read_to_string` attempts to read a source until EOF, but many sources are continuous streams\n that do not send EOF. In these cases, `read_to_string` will block indefinitely. Standard input\n is one such stream which may be finite if piped, but is typically continuous. For example,\n `cat file | my-rust-program` will correctly terminate with an `EOF` upon closure of cat.\n Reading user input or running programs that remain open indefinitely will never terminate\n the stream with `EOF` (e.g. `yes | my-rust-program`).\n\n Using `.lines()` with a [`BufReader`] or using [`read`] can provide a better solution\n\n[`read`]: Read::read\n\n [`std::fs::read_to_string`]: crate::fs::read_to_string\n"
}