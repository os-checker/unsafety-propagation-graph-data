{
  "name": "std::sys::net::connection::socket::unix::Socket::connect_timeout",
  "span": "$library/std/src/sys/net/connection/socket/unix.rs:165:5: 165:90",
  "src": "pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n        self.set_nonblocking(true)?;\n        let r = unsafe {\n            let (addr, len) = socket_addr_to_c(addr);\n            cvt(libc::connect(self.as_raw_fd(), addr.as_ptr(), len))\n        };\n        self.set_nonblocking(false)?;\n\n        match r {\n            Ok(_) => return Ok(()),\n            // there's no ErrorKind for EINPROGRESS :(\n            Err(ref e) if e.raw_os_error() == Some(libc::EINPROGRESS) => {}\n            Err(e) => return Err(e),\n        }\n\n        let mut pollfd = libc::pollfd { fd: self.as_raw_fd(), events: libc::POLLOUT, revents: 0 };\n\n        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n            return Err(io::Error::ZERO_TIMEOUT);\n        }\n\n        let start = Instant::now();\n\n        loop {\n            let elapsed = start.elapsed();\n            if elapsed >= timeout {\n                return Err(io::const_error!(io::ErrorKind::TimedOut, \"connection timed out\"));\n            }\n\n            let timeout = timeout - elapsed;\n            let mut timeout = timeout\n                .as_secs()\n                .saturating_mul(1_000)\n                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n            if timeout == 0 {\n                timeout = 1;\n            }\n\n            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n\n            match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n                -1 => {\n                    let err = io::Error::last_os_error();\n                    if !err.is_interrupted() {\n                        return Err(err);\n                    }\n                }\n                0 => {}\n                _ => {\n                    if cfg!(target_os = \"vxworks\") {\n                        // VxWorks poll does not return  POLLHUP or POLLERR in revents. Check if the\n                        // connection actually succeeded and return ok only when the socket is\n                        // ready and no errors were found.\n                        if let Some(e) = self.take_error()? {\n                            return Err(e);\n                        }\n                    } else {\n                        // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n                        // for POLLHUP or POLLERR rather than read readiness\n                        if pollfd.revents & (libc::POLLHUP | libc::POLLERR) != 0 {\n                            let e = self.take_error()?.unwrap_or_else(|| {\n                                io::const_error!(\n                                    io::ErrorKind::Uncategorized,\n                                    \"no error set after POLLHUP\",\n                                )\n                            });\n                            return Err(e);\n                        }\n                    }\n\n                    return Ok(());\n                }\n            }\n        }\n    }"
}