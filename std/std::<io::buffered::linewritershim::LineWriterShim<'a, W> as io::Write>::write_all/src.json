{
  "name": "std::<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_all",
  "span": "$library/std/src/io/buffered/linewritershim.rs:268:5: 268:58",
  "src": "fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                self.buffer.write_all(buf)\n            }\n            Some(newline_idx) => {\n                let (lines, tail) = buf.split_at(newline_idx + 1);\n\n                if self.buffered().is_empty() {\n                    self.inner_mut().write_all(lines)?;\n                } else {\n                    // If there is any buffered data, we add the incoming lines\n                    // to that buffer before flushing, which saves us at least\n                    // one write call. We can't really do this with `write`,\n                    // since we can't do this *and* not suppress errors *and*\n                    // report a consistent state to the caller in a return\n                    // value, but here in write_all it's fine.\n                    self.buffer.write_all(lines)?;\n                    self.buffer.flush_buf()?;\n                }\n\n                self.buffer.write_all(tail)\n            }\n        }\n    }"
}