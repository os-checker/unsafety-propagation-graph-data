{
  "name": "std::os::unix::fs::FileExt::read_exact_at",
  "span": "$library/std/src/os/unix/fs.rs:118:5: 118:83",
  "doc": " Reads the exact number of bytes required to fill `buf` from the given offset.\n\n The offset is relative to the start of the file and thus independent\n from the current cursor.\n\n The current file cursor is not affected by this function.\n\n Similar to [`io::Read::read_exact`] but uses [`read_at`] instead of `read`.\n\n [`read_at`]: FileExt::read_at\n\n # Errors\n\n If this function encounters an error of the kind\n [`io::ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If this function encounters an \"end of file\" before completely filling\n the buffer, it returns an error of the kind [`io::ErrorKind::UnexpectedEof`].\n The contents of `buf` are unspecified in this case.\n\n If any other read error is encountered then this function immediately\n returns. The contents of `buf` are unspecified in this case.\n\n If this function returns an error, it is unspecified how many bytes it\n has read, but it will never read more than would be necessary to\n completely fill the buffer.\n\n # Examples\n\n ```no_run\n use std::io;\n use std::fs::File;\n use std::os::unix::prelude::FileExt;\n\n fn main() -> io::Result<()> {\n     let mut buf = [0u8; 8];\n     let file = File::open(\"foo.txt\")?;\n\n     // We now read exactly 8 bytes from the offset 10.\n     file.read_exact_at(&mut buf, 10)?;\n     println!(\"read {} bytes: {:?}\", buf.len(), buf);\n     Ok(())\n }\n ```\n"
}