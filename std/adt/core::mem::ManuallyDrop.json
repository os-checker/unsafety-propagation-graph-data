{
  "name": "core::mem::ManuallyDrop",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "std::<os::fd::owned::OwnedFd as os::fd::raw::IntoRawFd>::into_raw_fd",
      "std::<sys::stdio::unix::Stderr as io::Write>::write",
      "std::<sys::stdio::unix::Stderr as io::Write>::write_vectored",
      "std::<sys::stdio::unix::Stdin as io::Read>::read",
      "std::<sys::stdio::unix::Stdin as io::Read>::read_buf",
      "std::<sys::stdio::unix::Stdin as io::Read>::read_vectored",
      "std::<sys::stdio::unix::Stdout as io::Write>::write",
      "std::<sys::stdio::unix::Stdout as io::Write>::write_vectored",
      "std::io::buffered::bufwriter::BufWriter::<W>::into_parts",
      "std::io::error::repr_bitpacked::Repr::into_data",
      "std::sync::lazy_lock::LazyLock::<T, F>::force",
      "std::sync::lazy_lock::LazyLock::<T, F>::get",
      "std::sync::lazy_lock::LazyLock::<T, F>::into_inner",
      "std::sync::nonpoison::mutex::MappedMutexGuard::<'a, T>::filter_map",
      "std::sync::nonpoison::mutex::MappedMutexGuard::<'a, T>::map",
      "std::sync::nonpoison::mutex::MutexGuard::<'a, T>::filter_map",
      "std::sync::nonpoison::mutex::MutexGuard::<'a, T>::map",
      "std::sync::nonpoison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::map",
      "std::sync::nonpoison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::map",
      "std::sync::nonpoison::rwlock::RwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::RwLockReadGuard::<'rwlock, T>::map",
      "std::sync::nonpoison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
      "std::sync::poison::mutex::MappedMutexGuard::<'a, T>::filter_map",
      "std::sync::poison::mutex::MappedMutexGuard::<'a, T>::map",
      "std::sync::poison::mutex::MutexGuard::<'a, T>::filter_map",
      "std::sync::poison::mutex::MutexGuard::<'a, T>::map",
      "std::sync::poison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::map",
      "std::sync::poison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::map",
      "std::sync::poison::rwlock::RwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::RwLockReadGuard::<'rwlock, T>::map",
      "std::sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
      "std::sys::io::kernel_copy::linux::fd_to_meta",
      "std::sys::thread::unix::Thread::into_id",
      "std::thread::current::current",
      "std::thread::current::current_or_unnamed",
      "std::thread::current::try_with_current",
      "std::thread::lifecycle::spawn_unchecked::MaybeDangling::<T>::into_inner"
    ],
    "write": [
      "std::<sync::lazy_lock::LazyLock<T, F> as core::ops::Drop>::drop",
      "std::io::buffered::bufwriter::BufWriter::<W>::into_parts",
      "std::panicking::catch_unwind::do_call",
      "std::sync::lazy_lock::LazyLock::<T, F>::force_mut",
      "std::sync::lazy_lock::LazyLock::<T, F>::force_mut::really_init_mut",
      "std::sync::lazy_lock::LazyLock::<T, F>::get_mut"
    ],
    "other": [
      "std::<os::fd::owned::OwnedFd as os::fd::raw::IntoRawFd>::into_raw_fd",
      "std::<sys::stdio::unix::Stderr as io::Write>::write",
      "std::<sys::stdio::unix::Stderr as io::Write>::write_vectored",
      "std::<sys::stdio::unix::Stdin as io::Read>::read",
      "std::<sys::stdio::unix::Stdin as io::Read>::read_buf",
      "std::<sys::stdio::unix::Stdin as io::Read>::read_vectored",
      "std::<sys::stdio::unix::Stdout as io::Write>::write",
      "std::<sys::stdio::unix::Stdout as io::Write>::write_vectored",
      "std::io::buffered::bufwriter::BufWriter::<W>::into_parts",
      "std::io::error::repr_bitpacked::Repr::into_data",
      "std::panicking::catch_unwind",
      "std::panicking::catch_unwind::do_call",
      "std::panicking::catch_unwind::do_catch",
      "std::sync::lazy_lock::LazyLock::<T, F>::force_mut::really_init_mut",
      "std::sync::lazy_lock::LazyLock::<T, F>::into_inner",
      "std::sync::lazy_lock::LazyLock::<T, F>::new",
      "std::sync::nonpoison::mutex::MappedMutexGuard::<'a, T>::filter_map",
      "std::sync::nonpoison::mutex::MappedMutexGuard::<'a, T>::map",
      "std::sync::nonpoison::mutex::MutexGuard::<'a, T>::filter_map",
      "std::sync::nonpoison::mutex::MutexGuard::<'a, T>::map",
      "std::sync::nonpoison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::map",
      "std::sync::nonpoison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::map",
      "std::sync::nonpoison::rwlock::RwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::RwLockReadGuard::<'rwlock, T>::map",
      "std::sync::nonpoison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::nonpoison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
      "std::sync::poison::mutex::MappedMutexGuard::<'a, T>::filter_map",
      "std::sync::poison::mutex::MappedMutexGuard::<'a, T>::map",
      "std::sync::poison::mutex::MutexGuard::<'a, T>::filter_map",
      "std::sync::poison::mutex::MutexGuard::<'a, T>::map",
      "std::sync::poison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::MappedRwLockReadGuard::<'rwlock, T>::map",
      "std::sync::poison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::MappedRwLockWriteGuard::<'rwlock, T>::map",
      "std::sync::poison::rwlock::RwLockReadGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::RwLockReadGuard::<'rwlock, T>::map",
      "std::sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
      "std::sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
      "std::sys::io::kernel_copy::linux::fd_to_meta",
      "std::sys::thread::unix::Thread::into_id",
      "std::thread::current::current",
      "std::thread::current::current_or_unnamed",
      "std::thread::current::try_with_current",
      "std::thread::lifecycle::spawn_unchecked::MaybeDangling::<T>::into_inner"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/mem/manually_drop.rs:158:1: 158:35",
  "src": "pub struct ManuallyDrop<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A wrapper to inhibit the compiler from automatically calling `T`â€™s\n destructor. This wrapper is 0-cost.\n\n `ManuallyDrop<T>` is guaranteed to have the same layout and bit validity as\n `T`, and is subject to the same layout optimizations as `T`. As a\n consequence, it has *no effect* on the assumptions that the compiler makes\n about its contents. For example, initializing a `ManuallyDrop<&mut T>` with\n [`mem::zeroed`] is undefined behavior. If you need to handle uninitialized\n data, use [`MaybeUninit<T>`] instead.\n\n Note that accessing the value inside a `ManuallyDrop<T>` is safe. This means\n that a `ManuallyDrop<T>` whose content has been dropped must not be exposed\n through a public safe API. Correspondingly, `ManuallyDrop::drop` is unsafe.\n\n # `ManuallyDrop` and drop order\n\n Rust has a well-defined [drop order] of values. To make sure that fields or\n locals are dropped in a specific order, reorder the declarations such that\n the implicit drop order is the correct one.\n\n It is possible to use `ManuallyDrop` to control the drop order, but this\n requires unsafe code and is hard to do correctly in the presence of\n unwinding.\n\n For example, if you want to make sure that a specific field is dropped after\n the others, make it the last field of a struct:\n\n ```\n struct Context;\n\n struct Widget {\n     children: Vec<Widget>,\n     // `context` will be dropped after `children`.\n     // Rust guarantees that fields are dropped in the order of declaration.\n     context: Context,\n }\n ```\n\n # Interaction with `Box`\n\n Currently, if you have a `ManuallyDrop<T>`, where the type `T` is a `Box` or\n contains a `Box` inside, then dropping the `T` followed by moving the\n `ManuallyDrop<T>` is [considered to be undefined\n behavior](https://github.com/rust-lang/unsafe-code-guidelines/issues/245).\n That is, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n let mut x = ManuallyDrop::new(Box::new(42));\n unsafe {\n     ManuallyDrop::drop(&mut x);\n }\n let y = x; // Undefined behavior!\n ```\n\n This is [likely to change in the\n future](https://rust-lang.github.io/rfcs/3336-maybe-dangling.html). In the\n meantime, consider using [`MaybeUninit`] instead.\n\n # Safety hazards when storing `ManuallyDrop` in a struct or an enum.\n\n Special care is needed when all of the conditions below are met:\n * A struct or enum contains a `ManuallyDrop`.\n * The `ManuallyDrop` is not inside a `union`.\n * The struct or enum is part of public API, or is stored in a struct or an\n   enum that is part of public API.\n * There is code that drops the contents of the `ManuallyDrop` field, and\n   this code is outside the struct or enum's `Drop` implementation.\n\n In particular, the following hazards may occur:\n\n #### Storing generic types\n\n If the `ManuallyDrop` contains a client-supplied generic type, the client\n might provide a `Box` as that type. This would cause undefined behavior when\n the struct or enum is later moved, as mentioned in the previous section. For\n example, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n pub struct BadOption<T> {\n     // Invariant: Has been dropped if `is_some` is false.\n     value: ManuallyDrop<T>,\n     is_some: bool,\n }\n impl<T> BadOption<T> {\n     pub fn new(value: T) -> Self {\n         Self { value: ManuallyDrop::new(value), is_some: true }\n     }\n     pub fn change_to_none(&mut self) {\n         if self.is_some {\n             self.is_some = false;\n             unsafe {\n                 // SAFETY: `value` hasn't been dropped yet, as per the invariant\n                 // (This is actually unsound!)\n                 ManuallyDrop::drop(&mut self.value);\n             }\n         }\n     }\n }\n\n // In another crate:\n\n let mut option = BadOption::new(Box::new(42));\n option.change_to_none();\n let option2 = option; // Undefined behavior!\n ```\n\n #### Deriving traits\n\n Deriving `Debug`, `Clone`, `PartialEq`, `PartialOrd`, `Ord`, or `Hash` on\n the struct or enum could be unsound, since the derived implementations of\n these traits would access the `ManuallyDrop` field. For example, the\n following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n // This derive is unsound in combination with the `ManuallyDrop::drop` call.\n #[derive(Debug)]\n pub struct Foo {\n     value: ManuallyDrop<String>,\n }\n impl Foo {\n     pub fn new() -> Self {\n         let mut temp = Self {\n             value: ManuallyDrop::new(String::from(\"Unsafe rust is hard.\"))\n         };\n         unsafe {\n             // SAFETY: `value` hasn't been dropped yet.\n             ManuallyDrop::drop(&mut temp.value);\n         }\n         temp\n     }\n }\n\n // In another crate:\n\n let foo = Foo::new();\n println!(\"{:?}\", foo); // Undefined behavior!\n ```\n\n [drop order]: https://doc.rust-lang.org/reference/destructors.html\n [`mem::zeroed`]: crate::mem::zeroed\n [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n [`MaybeUninit`]: crate::mem::MaybeUninit\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}