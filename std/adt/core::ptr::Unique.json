{
  "name": "core::ptr::Unique",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "<(&str, u16) as net::socket_addr::ToSocketAddrs>::to_socket_addrs",
      "<str as net::socket_addr::ToSocketAddrs>::to_socket_addrs"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ptr/unique.rs:36:1: 36:35",
  "src": "pub struct Unique<T: PointeeSized>",
  "kind": "Struct",
  "doc_adt": " A wrapper around a raw non-null `*mut T` that indicates that the possessor\n of this wrapper owns the referent. Useful for building abstractions like\n `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n\n Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n the kind of strong aliasing guarantees an instance of `T` can expect:\n the referent of the pointer should not be modified without a unique path to\n its owning Unique.\n\n If you're uncertain of whether it's correct to use `Unique` for your purposes,\n consider using `NonNull`, which has weaker semantics.\n\n Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n is never dereferenced. This is so that enums may use this forbidden value\n as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n However the pointer may still dangle if it isn't dereferenced.\n\n Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n for any type which upholds Unique's aliasing requirements.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "pointer",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    }
  }
}