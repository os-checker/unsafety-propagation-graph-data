{
  "name": "net::tcp::TcpStream",
  "constructors": [
    "net::tcp::TcpStream::connect",
    "net::tcp::TcpStream::connect_timeout",
    "net::tcp::TcpStream::try_clone",
    "<net::tcp::TcpStream as sys_common::FromInner<sys::net::connection::socket::TcpStream>>::from_inner",
    "net::tcp::TcpListener::accept",
    "<net::tcp::Incoming<'a> as core::iter::Iterator>::next",
    "<net::tcp::IntoIncoming as core::iter::Iterator>::next",
    "os::fd::owned::<impl core::convert::From<os::fd::owned::OwnedFd> for net::tcp::TcpStream>::from",
    "os::fd::net::<impl os::fd::raw::FromRawFd for net::tcp::TcpStream>::from_raw_fd"
  ],
  "access_self_as_arg": {
    "read": [
      "net::tcp::TcpStream::peer_addr",
      "net::tcp::TcpStream::local_addr",
      "net::tcp::TcpStream::shutdown",
      "net::tcp::TcpStream::try_clone",
      "net::tcp::TcpStream::set_read_timeout",
      "net::tcp::TcpStream::set_write_timeout",
      "net::tcp::TcpStream::read_timeout",
      "net::tcp::TcpStream::write_timeout",
      "net::tcp::TcpStream::peek",
      "net::tcp::TcpStream::set_linger",
      "net::tcp::TcpStream::linger",
      "net::tcp::TcpStream::set_nodelay",
      "net::tcp::TcpStream::nodelay",
      "net::tcp::TcpStream::set_ttl",
      "net::tcp::TcpStream::ttl",
      "net::tcp::TcpStream::take_error",
      "net::tcp::TcpStream::set_nonblocking",
      "<net::tcp::TcpStream as io::Read>::is_read_vectored",
      "<net::tcp::TcpStream as io::Write>::is_write_vectored",
      "<net::tcp::TcpStream as sys_common::AsInner<sys::net::connection::socket::TcpStream>>::as_inner",
      "<net::tcp::TcpStream as core::fmt::Debug>::fmt",
      "<net::tcp::TcpStream as os::fd::owned::AsFd>::as_fd",
      "<net::tcp::TcpStream as os::net::linux_ext::tcp::TcpStreamExt>::set_quickack",
      "<net::tcp::TcpStream as os::net::linux_ext::tcp::TcpStreamExt>::quickack",
      "<net::tcp::TcpStream as os::net::linux_ext::tcp::TcpStreamExt>::set_deferaccept",
      "<net::tcp::TcpStream as os::net::linux_ext::tcp::TcpStreamExt>::deferaccept",
      "os::fd::net::<impl os::fd::raw::AsRawFd for net::tcp::TcpStream>::as_raw_fd",
      "<net::tcp::TcpStream as sys::io::kernel_copy::linux::CopyRead>::properties",
      "<net::tcp::TcpStream as sys::io::kernel_copy::linux::CopyWrite>::properties"
    ],
    "write": [
      "<net::tcp::TcpStream as io::Read>::read",
      "<net::tcp::TcpStream as io::Read>::read_buf",
      "<net::tcp::TcpStream as io::Read>::read_vectored",
      "<net::tcp::TcpStream as io::Write>::write",
      "<net::tcp::TcpStream as io::Write>::write_vectored",
      "<net::tcp::TcpStream as io::Write>::flush"
    ],
    "other": [
      "<net::tcp::TcpStream as sys_common::IntoInner<sys::net::connection::socket::TcpStream>>::into_inner",
      "<os::fd::owned::OwnedFd as core::convert::From<net::tcp::TcpStream>>::from",
      "os::fd::net::<impl os::fd::raw::IntoRawFd for net::tcp::TcpStream>::into_raw_fd",
      "<net::tcp::TcpStream as sys_common::IntoInner<sys::net::connection::socket::TcpStream>>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "<&net::tcp::TcpStream as io::Read>::read",
      "<&net::tcp::TcpStream as io::Read>::read_buf",
      "<&net::tcp::TcpStream as io::Read>::read_vectored",
      "<&net::tcp::TcpStream as io::Read>::is_read_vectored",
      "<&net::tcp::TcpStream as io::Write>::write",
      "<&net::tcp::TcpStream as io::Write>::write_vectored",
      "<&net::tcp::TcpStream as io::Write>::is_write_vectored",
      "<&net::tcp::TcpStream as sys::io::kernel_copy::linux::CopyRead>::properties",
      "<&net::tcp::TcpStream as sys::io::kernel_copy::linux::CopyWrite>::properties"
    ],
    "write": [],
    "other": [
      "<net::tcp::TcpStream as sys_common::FromInner<sys::net::connection::socket::TcpStream>>::from_inner",
      "os::fd::owned::<impl core::convert::From<os::fd::owned::OwnedFd> for net::tcp::TcpStream>::from",
      "os::fd::net::<impl os::fd::raw::FromRawFd for net::tcp::TcpStream>::from_raw_fd"
    ]
  },
  "access_field": [
    {
      "read": [
        "net::tcp::TcpStream::peer_addr",
        "net::tcp::TcpStream::local_addr",
        "net::tcp::TcpStream::shutdown",
        "net::tcp::TcpStream::try_clone",
        "net::tcp::TcpStream::set_read_timeout",
        "net::tcp::TcpStream::set_write_timeout",
        "net::tcp::TcpStream::read_timeout",
        "net::tcp::TcpStream::write_timeout",
        "net::tcp::TcpStream::peek",
        "net::tcp::TcpStream::set_linger",
        "net::tcp::TcpStream::linger",
        "net::tcp::TcpStream::set_nodelay",
        "net::tcp::TcpStream::nodelay",
        "net::tcp::TcpStream::set_ttl",
        "net::tcp::TcpStream::ttl",
        "net::tcp::TcpStream::take_error",
        "net::tcp::TcpStream::set_nonblocking",
        "<net::tcp::TcpStream as io::Read>::is_read_vectored",
        "<net::tcp::TcpStream as io::Write>::is_write_vectored",
        "<&net::tcp::TcpStream as io::Read>::read",
        "<&net::tcp::TcpStream as io::Read>::read_buf",
        "<&net::tcp::TcpStream as io::Read>::read_vectored",
        "<&net::tcp::TcpStream as io::Read>::is_read_vectored",
        "<&net::tcp::TcpStream as io::Write>::write",
        "<&net::tcp::TcpStream as io::Write>::write_vectored",
        "<&net::tcp::TcpStream as io::Write>::is_write_vectored",
        "<net::tcp::TcpStream as sys_common::AsInner<sys::net::connection::socket::TcpStream>>::as_inner",
        "<net::tcp::TcpStream as core::fmt::Debug>::fmt"
      ],
      "write": [
        "<net::tcp::TcpStream as io::Read>::read",
        "<net::tcp::TcpStream as io::Read>::read_buf",
        "<net::tcp::TcpStream as io::Read>::read_vectored",
        "<net::tcp::TcpStream as io::Write>::write",
        "<net::tcp::TcpStream as io::Write>::write_vectored"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/net/tcp.rs:63:1: 63:21",
  "src": "pub struct TcpStream",
  "kind": "Struct",
  "doc_adt": " A TCP stream between a local and a remote socket.\n\n After creating a `TcpStream` by either [`connect`]ing to a remote host or\n [`accept`]ing a connection on a [`TcpListener`], data can be transmitted\n by [reading] and [writing] to it.\n\n The connection will be closed when the value is dropped. The reading and writing\n portions of the connection can also be shut down individually with the [`shutdown`]\n method.\n\n The Transmission Control Protocol is specified in [IETF RFC 793].\n\n [`accept`]: TcpListener::accept\n [`connect`]: TcpStream::connect\n [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n [reading]: Read\n [`shutdown`]: TcpStream::shutdown\n [writing]: Write\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::net::TcpStream;\n\n fn main() -> std::io::Result<()> {\n     let mut stream = TcpStream::connect(\"127.0.0.1:34254\")?;\n\n     stream.write(&[1])?;\n     stream.read(&mut [0; 128])?;\n     Ok(())\n } // the stream is closed here\n ```\n\n # Platform-specific Behavior\n\n On Unix, writes to the underlying socket in `SOCK_STREAM` mode are made with\n `MSG_NOSIGNAL` flag. This suppresses the emission of the  `SIGPIPE` signal when writing\n to disconnected socket. In some cases, getting a `SIGPIPE` would trigger process termination.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}