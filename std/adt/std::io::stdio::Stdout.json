{
  "name": "std::io::stdio::Stdout",
  "constructors": [
    "std::io::stdio::stdout"
  ],
  "access_self_as_arg": {
    "read": [
      "std::io::stdio::Stdout::lock",
      "std::<io::stdio::Stdout as core::fmt::Debug>::fmt",
      "std::<io::stdio::Stdout as io::Write>::write",
      "std::<io::stdio::Stdout as io::Write>::write_vectored",
      "std::<io::stdio::Stdout as io::Write>::is_write_vectored",
      "std::<io::stdio::Stdout as io::Write>::flush",
      "std::<io::stdio::Stdout as io::Write>::write_all",
      "std::<io::stdio::Stdout as io::Write>::write_all_vectored",
      "std::<io::stdio::Stdout as io::Write>::write_fmt",
      "std::<io::stdio::Stdout as os::fd::raw::AsRawFd>::as_raw_fd",
      "std::<io::stdio::Stdout as os::fd::owned::AsFd>::as_fd",
      "std::<io::stdio::Stdout as io::stdio::IsTerminal>::is_terminal"
    ],
    "write": [
      "std::<io::stdio::Stdout as io::Write>::write",
      "std::<io::stdio::Stdout as io::Write>::write_vectored",
      "std::<io::stdio::Stdout as io::Write>::flush",
      "std::<io::stdio::Stdout as io::Write>::write_all",
      "std::<io::stdio::Stdout as io::Write>::write_all_vectored",
      "std::<io::stdio::Stdout as io::Write>::write_fmt",
      "std::<io::stdio::Stdout as io::Write>::write",
      "std::<io::stdio::Stdout as io::Write>::write_vectored",
      "std::<io::stdio::Stdout as io::Write>::flush",
      "std::<io::stdio::Stdout as io::Write>::write_all",
      "std::<io::stdio::Stdout as io::Write>::write_all_vectored",
      "std::<io::stdio::Stdout as io::Write>::write_fmt"
    ],
    "other": [
      "std::<process::Stdio as core::convert::From<io::stdio::Stdout>>::from"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "std::<&io::stdio::Stdout as io::Write>::write",
      "std::<&io::stdio::Stdout as io::Write>::write_vectored",
      "std::<&io::stdio::Stdout as io::Write>::is_write_vectored",
      "std::<&io::stdio::Stdout as io::Write>::flush",
      "std::<&io::stdio::Stdout as io::Write>::write_all",
      "std::<&io::stdio::Stdout as io::Write>::write_all_vectored",
      "std::<&io::stdio::Stdout as io::Write>::write_fmt"
    ],
    "write": [],
    "other": [
      "std::io::stdio::stdout"
    ]
  },
  "access_field": [
    {
      "read": [
        "std::io::stdio::Stdout::lock"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/std/src/io/stdio.rs:608:1: 608:18",
  "src": "pub struct Stdout",
  "kind": "Struct",
  "doc_adt": " A handle to the global standard output stream of the current process.\n\n Each handle shares a global buffer of data to be written to the standard\n output stream. Access is also synchronized via a lock and explicit control\n over locking is available via the [`lock`] method.\n\n By default, the handle is line-buffered when connected to a terminal, meaning\n it flushes automatically when a newline (`\\n`) is encountered. For immediate\n output, you can manually call the [`flush`] method. When the handle goes out\n of scope, the buffer is automatically flushed.\n\n Created by the [`io::stdout`] method.\n\n ### Note: Windows Portability Considerations\n\n When operating in a console, the Windows implementation of this stream does not support\n non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n an error.\n\n In a process with a detached console, such as one using\n `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n the contained handle will be null. In such cases, the standard library's `Read` and\n `Write` will do nothing and silently succeed. All other I/O operations, via the\n standard library or via raw Windows API calls, will fail.\n\n [`lock`]: Stdout::lock\n [`flush`]: Write::flush\n [`io::stdout`]: stdout\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}