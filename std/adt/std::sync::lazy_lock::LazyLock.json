{
  "name": "std::sync::lazy_lock::LazyLock",
  "constructors": [
    "std::sync::lazy_lock::LazyLock::<T, F>::new",
    "std::<sync::lazy_lock::LazyLock<T> as core::default::Default>::default"
  ],
  "access_self_as_arg": {
    "read": [
      "std::sync::lazy_lock::LazyLock::<T, F>::into_inner",
      "std::sync::lazy_lock::LazyLock::<T, F>::force",
      "std::sync::lazy_lock::LazyLock::<T, F>::get",
      "std::<sync::lazy_lock::LazyLock<T, F> as core::ops::Deref>::deref",
      "std::<sync::lazy_lock::LazyLock<T, F> as core::fmt::Debug>::fmt"
    ],
    "write": [
      "std::sync::lazy_lock::LazyLock::<T, F>::force_mut",
      "std::sync::lazy_lock::LazyLock::<T, F>::force_mut::really_init_mut",
      "std::sync::lazy_lock::LazyLock::<T, F>::get_mut",
      "std::<sync::lazy_lock::LazyLock<T, F> as core::ops::Drop>::drop",
      "std::<sync::lazy_lock::LazyLock<T, F> as core::ops::DerefMut>::deref_mut"
    ],
    "other": [
      "std::sync::lazy_lock::LazyLock::<T, F>::into_inner",
      "std::sync::lazy_lock::LazyLock::<T, F>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "std::<backtrace::Backtrace as core::fmt::Debug>::fmt",
      "std::backtrace::Backtrace::frames",
      "std::<backtrace::Backtrace as core::fmt::Display>::fmt"
    ],
    "write": [
      "std::<sync::lazy_lock::LazyLock<T, F>::force_mut::really_init_mut::PoisonOnPanic<'_, T, F> as core::ops::Drop>::drop"
    ],
    "other": [
      "std::backtrace::Backtrace::create",
      "std::sync::lazy_lock::LazyLock::<T, F>::new",
      "std::<sync::lazy_lock::LazyLock<T> as core::default::Default>::default"
    ]
  },
  "access_field": [
    {
      "read": [
        "std::sync::lazy_lock::LazyLock::<T, F>::force",
        "std::sync::lazy_lock::LazyLock::<T, F>::get"
      ],
      "write": [
        "std::sync::lazy_lock::LazyLock::<T, F>::force_mut",
        "std::sync::lazy_lock::LazyLock::<T, F>::force_mut::really_init_mut",
        "std::<sync::lazy_lock::LazyLock<T, F>::force_mut::really_init_mut::PoisonOnPanic<'_, T, F> as core::ops::Drop>::drop",
        "std::sync::lazy_lock::LazyLock::<T, F>::get_mut",
        "std::<sync::lazy_lock::LazyLock<T, F> as core::ops::Drop>::drop"
      ],
      "other": []
    },
    {
      "read": [
        "std::sync::lazy_lock::LazyLock::<T, F>::into_inner",
        "std::sync::lazy_lock::LazyLock::<T, F>::force",
        "std::sync::lazy_lock::LazyLock::<T, F>::get"
      ],
      "write": [
        "std::sync::lazy_lock::LazyLock::<T, F>::force_mut",
        "std::sync::lazy_lock::LazyLock::<T, F>::force_mut::really_init_mut",
        "std::sync::lazy_lock::LazyLock::<T, F>::get_mut",
        "std::<sync::lazy_lock::LazyLock<T, F> as core::ops::Drop>::drop"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/sync/lazy_lock.rs:81:1: 81:38",
  "src": "pub struct LazyLock<T, F = fn() -> T>",
  "kind": "Struct",
  "doc_adt": " A value which is initialized on the first access.\n\n This type is a thread-safe [`LazyCell`], and can be used in statics.\n Since initialization may be called from multiple threads, any\n dereferencing call will block the calling thread if another\n initialization routine is currently running.\n\n [`LazyCell`]: crate::cell::LazyCell\n\n # Poisoning\n\n If the initialization closure passed to [`LazyLock::new`] panics, the lock will be poisoned.\n Once the lock is poisoned, any threads that attempt to access this lock (via a dereference\n or via an explicit call to [`force()`]) will panic.\n\n This concept is similar to that of poisoning in the [`std::sync::poison`] module. A key\n difference, however, is that poisoning in `LazyLock` is _unrecoverable_. All future accesses of\n the lock from other threads will panic, whereas a type in [`std::sync::poison`] like\n [`std::sync::poison::Mutex`] allows recovery via [`PoisonError::into_inner()`].\n\n [`force()`]: LazyLock::force\n [`std::sync::poison`]: crate::sync::poison\n [`std::sync::poison::Mutex`]: crate::sync::poison::Mutex\n [`PoisonError::into_inner()`]: crate::sync::poison::PoisonError::into_inner\n\n # Examples\n\n Initialize static variables with `LazyLock`.\n ```\n use std::sync::LazyLock;\n\n // Note: static items do not call [`Drop`] on program termination, so this won't be deallocated.\n // this is fine, as the OS can deallocate the terminated program faster than we can free memory\n // but tools like valgrind might report \"memory leaks\" as it isn't obvious this is intentional.\n static DEEP_THOUGHT: LazyLock<String> = LazyLock::new(|| {\n # mod another_crate {\n #     pub fn great_question() -> String { \"42\".to_string() }\n # }\n     // M3 Ultra takes about 16 million years in --release config\n     another_crate::great_question()\n });\n\n // The `String` is built, stored in the `LazyLock`, and returned as `&String`.\n let _ = &*DEEP_THOUGHT;\n ```\n\n Initialize fields with `LazyLock`.\n ```\n use std::sync::LazyLock;\n\n #[derive(Debug)]\n struct UseCellLock {\n     number: LazyLock<u32>,\n }\n fn main() {\n     let lock: LazyLock<u32> = LazyLock::new(|| 0u32);\n\n     let data = UseCellLock { number: lock };\n     println!(\"{}\", *data.number);\n }\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "once",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "data",
      "doc": ""
    }
  }
}