{
  "name": "core::num::NonZero",
  "constructors": [
    "thread::functions::available_parallelism",
    "thread::id::ThreadId::as_u64",
    "<env::ArgsOs as core::iter::Iterator>::advance_by",
    "<env::ArgsOs as core::iter::DoubleEndedIterator>::advance_back_by",
    "process::ExitStatusError::code_nonzero",
    "<sys::args::common::Args as core::iter::Iterator>::advance_by",
    "<sys::args::common::Args as core::iter::DoubleEndedIterator>::advance_back_by",
    "sys_common::wstr::WStrUnits::<'_>::peek",
    "<sys_common::wstr::WStrUnits<'_> as core::iter::Iterator>::next",
    "sys::process::unix::unix::ExitStatusError::code",
    "sys::thread::unix::available_parallelism",
    "sys::thread::unsupported::available_parallelism"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "<thread::id::ThreadId as core::cmp::PartialEq>::eq",
      "<thread::id::ThreadId as core::hash::Hash>::hash",
      "<thread::id::ThreadId as core::fmt::Debug>::fmt",
      "<sys::process::unix::unix::ExitStatusError as core::fmt::Debug>::fmt",
      "<sys::process::unix::unix::ExitStatusError as core::cmp::PartialEq>::eq"
    ],
    "write": [],
    "other": [
      "thread::id::ThreadId::new",
      "thread::id::ThreadId::as_u64",
      "io::error::repr_bitpacked::Repr::new_os",
      "io::error::repr_bitpacked::Repr::new_simple",
      "sys_common::wstr::WStrUnits::<'_>::advance_while",
      "<sys_common::wstr::WStrUnits<'_> as core::iter::Iterator>::next",
      "thread::main_thread::set",
      "sync::reentrant_lock::Tid::contains",
      "sys::process::unix::unix::ExitStatus::exit_ok",
      "<sys::process::unix::unix::ExitStatusError as core::convert::Into<sys::process::unix::unix::ExitStatus>>::into",
      "sys::process::unix::unix::ExitStatusError::code",
      "sys::thread::unix::available_parallelism"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/num/nonzero.rs:127:1: 127:41",
  "src": "pub struct NonZero<T: ZeroablePrimitive>",
  "kind": "Struct",
  "doc_adt": " A value that is known not to equal zero.\n\n This enables some memory layout optimization.\n For example, `Option<NonZero<u32>>` is the same size as `u32`:\n\n ```\n use core::{num::NonZero};\n\n assert_eq!(size_of::<Option<NonZero<u32>>>(), size_of::<u32>());\n ```\n\n # Layout\n\n `NonZero<T>` is guaranteed to have the same layout and bit validity as `T`\n with the exception that the all-zero bit pattern is invalid.\n `Option<NonZero<T>>` is guaranteed to be compatible with `T`, including in\n FFI.\n\n Thanks to the [null pointer optimization], `NonZero<T>` and\n `Option<NonZero<T>>` are guaranteed to have the same size and alignment:\n\n ```\n use std::num::NonZero;\n\n assert_eq!(size_of::<NonZero<u32>>(), size_of::<Option<NonZero<u32>>>());\n assert_eq!(align_of::<NonZero<u32>>(), align_of::<Option<NonZero<u32>>>());\n ```\n\n [null pointer optimization]: crate::option#representation\n\n # Note on generic usage\n\n `NonZero<T>` can only be used with some standard library primitive types\n (such as `u8`, `i32`, and etc.). The type parameter `T` must implement the\n internal trait [`ZeroablePrimitive`], which is currently permanently unstable\n and cannot be implemented by users. Therefore, you cannot use `NonZero<T>`\n with your own types, nor can you implement traits for all `NonZero<T>`,\n only for concrete types.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}