{
  "name": "hashbrown::HashMap",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone",
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone_from",
      "std::collections::hash::map::HashMap::<K, V, S>::capacity",
      "std::collections::hash::map::HashMap::<K, V, S>::contains_key",
      "std::collections::hash::map::HashMap::<K, V, S>::get",
      "std::collections::hash::map::HashMap::<K, V, S>::get_key_value",
      "std::collections::hash::map::HashMap::<K, V, S>::hasher",
      "std::collections::hash::map::HashMap::<K, V, S>::is_empty",
      "std::collections::hash::map::HashMap::<K, V, S>::iter",
      "std::collections::hash::map::HashMap::<K, V, S>::len"
    ],
    "write": [
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone_from",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend_one",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend_one",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend_reserve",
      "std::collections::hash::map::HashMap::<K, V, S>::clear",
      "std::collections::hash::map::HashMap::<K, V, S>::drain",
      "std::collections::hash::map::HashMap::<K, V, S>::entry",
      "std::collections::hash::map::HashMap::<K, V, S>::extract_if",
      "std::collections::hash::map::HashMap::<K, V, S>::get_disjoint_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::get_disjoint_unchecked_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::get_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::insert",
      "std::collections::hash::map::HashMap::<K, V, S>::iter_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::remove",
      "std::collections::hash::map::HashMap::<K, V, S>::remove_entry",
      "std::collections::hash::map::HashMap::<K, V, S>::reserve",
      "std::collections::hash::map::HashMap::<K, V, S>::retain",
      "std::collections::hash::map::HashMap::<K, V, S>::shrink_to",
      "std::collections::hash::map::HashMap::<K, V, S>::shrink_to_fit",
      "std::collections::hash::map::HashMap::<K, V, S>::try_reserve"
    ],
    "other": [
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::IntoIterator>::into_iter",
      "std::collections::hash::map::HashMap::<K, V, S>::with_capacity_and_hasher",
      "std::collections::hash::map::HashMap::<K, V, S>::with_hasher"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hashbrown-0.16.1/src/map.rs:185:1: 185:72",
  "src": "pub struct HashMap<K, V, S = DefaultHashBuilder, A: Allocator = Global>",
  "kind": "Struct",
  "doc_adt": " A hash map implemented with quadratic probing and SIMD lookup.\n\n The default hashing algorithm is currently [`foldhash`], though this is\n subject to change at any point in the future. This hash function is very\n fast for all types of keys, but this algorithm will typically *not* protect\n against attacks such as HashDoS.\n\n The hashing algorithm can be replaced on a per-`HashMap` basis using the\n [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods. Many\n alternative algorithms are available on crates.io, such as the [`fnv`] crate.\n\n It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n If you implement these yourself, it is important that the following\n property holds:\n\n ```text\n k1 == k2 -> hash(k1) == hash(k2)\n ```\n\n In other words, if two keys are equal, their hashes must be equal.\n\n It is a logic error for a key to be modified in such a way that the key's\n hash, as determined by the [`Hash`] trait, or its equality, as determined by\n the [`Eq`] trait, changes while it is in the map. This is normally only\n possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n\n It is also a logic error for the [`Hash`] implementation of a key to panic.\n This is generally only possible if the trait is implemented manually. If a\n panic does occur then the contents of the `HashMap` may become corrupted and\n some items may be dropped from the table.\n\n # Examples\n\n ```\n use hashbrown::HashMap;\n\n // Type inference lets us omit an explicit type signature (which\n // would be `HashMap<String, String>` in this example).\n let mut book_reviews = HashMap::new();\n\n // Review some books.\n book_reviews.insert(\n     \"Adventures of Huckleberry Finn\".to_string(),\n     \"My favorite book.\".to_string(),\n );\n book_reviews.insert(\n     \"Grimms' Fairy Tales\".to_string(),\n     \"Masterpiece.\".to_string(),\n );\n book_reviews.insert(\n     \"Pride and Prejudice\".to_string(),\n     \"Very enjoyable.\".to_string(),\n );\n book_reviews.insert(\n     \"The Adventures of Sherlock Holmes\".to_string(),\n     \"Eye lyked it alot.\".to_string(),\n );\n\n // Check for a specific one.\n // When collections store owned values (String), they can still be\n // queried using references (&str).\n if !book_reviews.contains_key(\"Les Misérables\") {\n     println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n              book_reviews.len());\n }\n\n // oops, this review has a lot of spelling mistakes, let's delete it.\n book_reviews.remove(\"The Adventures of Sherlock Holmes\");\n\n // Look up the values associated with some keys.\n let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n for &book in &to_find {\n     match book_reviews.get(book) {\n         Some(review) => println!(\"{}: {}\", book, review),\n         None => println!(\"{} is unreviewed.\", book)\n     }\n }\n\n // Look up the value for a key (will panic if the key is not found).\n println!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]);\n\n // Iterate over everything.\n for (book, review) in &book_reviews {\n     println!(\"{}: \\\"{}\\\"\", book, review);\n }\n ```\n\n `HashMap` also implements an [`Entry API`](#method.entry), which allows\n for more complex methods of getting, setting, updating and removing keys and\n their values:\n\n ```\n use hashbrown::HashMap;\n\n // type inference lets us omit an explicit type signature (which\n // would be `HashMap<&str, u8>` in this example).\n let mut player_stats = HashMap::new();\n\n fn random_stat_buff() -> u8 {\n     // could actually return some random value here - let's just return\n     // some fixed value for now\n     42\n }\n\n // insert a key only if it doesn't already exist\n player_stats.entry(\"health\").or_insert(100);\n\n // insert a key using a function that provides a new value only if it\n // doesn't already exist\n player_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n\n // update a key, guarding against the key possibly not being set\n let stat = player_stats.entry(\"attack\").or_insert(100);\n *stat += random_stat_buff();\n ```\n\n The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n We must also derive [`PartialEq`].\n\n [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n [`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\n [`RefCell`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html\n [`Cell`]: https://doc.rust-lang.org/std/cell/struct.Cell.html\n [`default`]: #method.default\n [`with_hasher`]: #method.with_hasher\n [`with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n [`fnv`]: https://crates.io/crates/fnv\n [`foldhash`]: https://crates.io/crates/foldhash\n\n ```\n use hashbrown::HashMap;\n\n #[derive(Hash, Eq, PartialEq, Debug)]\n struct Viking {\n     name: String,\n     country: String,\n }\n\n impl Viking {\n     /// Creates a new Viking.\n     fn new(name: &str, country: &str) -> Viking {\n         Viking { name: name.to_string(), country: country.to_string() }\n     }\n }\n\n // Use a HashMap to store the vikings' health points.\n let mut vikings = HashMap::new();\n\n vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n\n // Use derived implementation to print the status of the vikings.\n for (viking, health) in &vikings {\n     println!(\"{:?} has {} hp\", viking, health);\n }\n ```\n\n A `HashMap` with fixed list of elements can be initialized from an array:\n\n ```\n use hashbrown::HashMap;\n\n let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n     .into_iter().collect();\n // use the values stored in map\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "hash_builder",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "table",
      "doc": ""
    }
  }
}