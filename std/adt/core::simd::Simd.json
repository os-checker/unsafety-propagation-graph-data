{
  "name": "core::simd::Simd",
  "constructors": [
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::fract",
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::sin",
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::cos",
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::exp",
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::exp2",
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::ln",
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::log2",
    "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::log10",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::fract",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::sin",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::cos",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp2",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::ln",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log2",
    "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log10"
  ],
  "access_self_as_arg": {
    "read": [
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::sin",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::cos",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp2",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::ln",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log2",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log10"
    ],
    "write": [
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::sin",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::cos",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp2",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::ln",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log2",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log10"
    ],
    "other": [
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::fract",
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::sin",
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::cos",
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::exp",
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::exp2",
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::ln",
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::log2",
      "std::<core::simd::Simd<f32, N> as std_float::StdFloat>::log10",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::fract",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::sin",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::cos",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::exp2",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::ln",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log2",
      "std::<core::simd::Simd<f64, N> as std_float::StdFloat>::log10"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:103:1: 103:35",
  "src": "pub struct Simd<T, const N: usize>",
  "kind": "Struct",
  "doc_adt": " A SIMD vector with the shape of `[T; N]` but the operations of `T`.\n\n `Simd<T, N>` supports the operators (+, *, etc.) that `T` does in \"elementwise\" fashion.\n These take the element at each index from the left-hand side and right-hand side,\n perform the operation, then return the result in the same index in a vector of equal size.\n However, `Simd` differs from normal iteration and normal arrays:\n - `Simd<T, N>` executes `N` operations in a single step with no `break`s\n - `Simd<T, N>` can have an alignment greater than `T`, for better mechanical sympathy\n\n By always imposing these constraints on `Simd`, it is easier to compile elementwise operations\n into machine instructions that can themselves be executed in parallel.\n\n ```rust\n # #![feature(portable_simd)]\n # use core::simd::{Simd};\n # use core::array;\n let a: [i32; 4] = [-2, 0, 2, 4];\n let b = [10, 9, 8, 7];\n let sum = array::from_fn(|i| a[i] + b[i]);\n let prod = array::from_fn(|i| a[i] * b[i]);\n\n // `Simd<T, N>` implements `From<[T; N]>`\n let (v, w) = (Simd::from(a), Simd::from(b));\n // Which means arrays implement `Into<Simd<T, N>>`.\n assert_eq!(v + w, sum.into());\n assert_eq!(v * w, prod.into());\n ```\n\n\n `Simd` with integer elements treats operators as wrapping, as if `T` was [`Wrapping<T>`].\n Thus, `Simd` does not implement `wrapping_add`, because that is the default behavior.\n This means there is no warning on overflows, even in \"debug\" builds.\n For most applications where `Simd` is appropriate, it is \"not a bug\" to wrap,\n and even \"debug builds\" are unlikely to tolerate the loss of performance.\n You may want to consider using explicitly checked arithmetic if such is required.\n Division by zero on integers still causes a panic, so\n you may want to consider using `f32` or `f64` if that is unacceptable.\n\n [`Wrapping<T>`]: core::num::Wrapping\n\n # Layout\n `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), with a greater alignment.\n `[T; N]` is aligned to `T`, but `Simd<T, N>` will have an alignment based on both `T` and `N`.\n Thus it is sound to [`transmute`] `Simd<T, N>` to `[T; N]` and should optimize to \"zero cost\",\n but the reverse transmutation may require a copy the compiler cannot simply elide.\n\n # ABI \"Features\"\n Due to Rust's safety guarantees, `Simd<T, N>` is currently passed and returned via memory,\n not SIMD registers, except as an optimization. Using `#[inline]` on functions that accept\n `Simd<T, N>` or return it is recommended, at the cost of code generation time, as\n inlining SIMD-using functions can omit a large function prolog or epilog and thus\n improve both speed and code size. The need for this may be corrected in the future.\n\n Using `#[inline(always)]` still requires additional care.\n\n # Safe SIMD with Unsafe Rust\n\n Operations with `Simd` are typically safe, but there are many reasons to want to combine SIMD with `unsafe` code.\n Care must be taken to respect differences between `Simd` and other types it may be transformed into or derived from.\n In particular, the layout of `Simd<T, N>` may be similar to `[T; N]`, and may allow some transmutations,\n but references to `[T; N]` are not interchangeable with those to `Simd<T, N>`.\n Thus, when using `unsafe` Rust to read and write `Simd<T, N>` through [raw pointers], it is a good idea to first try with\n [`read_unaligned`] and [`write_unaligned`]. This is because:\n - [`read`] and [`write`] require full alignment (in this case, `Simd<T, N>`'s alignment)\n - `Simd<T, N>` is often read from or written to [`[T]`](slice) and other types aligned to `T`\n - combining these actions violates the `unsafe` contract and explodes the program into\n   a puff of **undefined behavior**\n - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned\n   if it sees the optimization\n - most contemporary processors with \"aligned\" and \"unaligned\" read and write instructions\n   exhibit no performance difference if the \"unaligned\" variant is aligned at runtime\n\n Less obligations mean unaligned reads and writes are less likely to make the program unsound,\n and may be just as fast as stricter alternatives.\n When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for\n converting `[T]` to `[Simd<T, N>]`, and allows soundly operating on an aligned SIMD body,\n but it may cost more time when handling the scalar head and tail.\n If these are not enough, it is most ideal to design data structures to be already aligned\n to `align_of::<Simd<T, N>>()` before using `unsafe` Rust to read or write.\n Other ways to compensate for these facts, like materializing `Simd` to or from an array first,\n are handled by safe methods like [`Simd::from_array`] and [`Simd::from_slice`].\n\n [`transmute`]: core::mem::transmute\n [raw pointers]: pointer\n [`read_unaligned`]: pointer::read_unaligned\n [`write_unaligned`]: pointer::write_unaligned\n [`read`]: pointer::read\n [`write`]: pointer::write\n [as_simd]: slice::as_simd\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}