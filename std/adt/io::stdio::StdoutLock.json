{
  "name": "io::stdio::StdoutLock",
  "constructors": [
    "io::stdio::Stdout::lock"
  ],
  "access_self_as_arg": {
    "read": [
      "<io::stdio::StdoutLock<'_> as io::Write>::is_write_vectored",
      "<io::stdio::StdoutLock<'_> as core::fmt::Debug>::fmt",
      "<io::stdio::StdoutLock<'a> as os::fd::raw::AsRawFd>::as_raw_fd",
      "<io::stdio::StdoutLock<'a> as os::fd::owned::AsFd>::as_fd",
      "<io::stdio::StdoutLock<'_> as io::stdio::IsTerminal>::is_terminal",
      "<io::stdio::StdoutLock<'_> as sys::io::kernel_copy::linux::CopyWrite>::properties"
    ],
    "write": [
      "<io::stdio::StdoutLock<'_> as io::Write>::write",
      "<io::stdio::StdoutLock<'_> as io::Write>::write_vectored",
      "<io::stdio::StdoutLock<'_> as io::Write>::flush",
      "<io::stdio::StdoutLock<'_> as io::Write>::write_all",
      "<io::stdio::StdoutLock<'_> as io::Write>::write_all_vectored"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "<&io::stdio::Stdout as io::Write>::is_write_vectored"
    ],
    "write": [
      "<&io::stdio::Stdout as io::Write>::write",
      "<&io::stdio::Stdout as io::Write>::write_vectored",
      "<&io::stdio::Stdout as io::Write>::flush",
      "<&io::stdio::Stdout as io::Write>::write_all",
      "<&io::stdio::Stdout as io::Write>::write_all_vectored",
      "<&io::stdio::Stdout as io::Write>::write_fmt"
    ],
    "other": [
      "io::stdio::Stdout::lock",
      "<&io::stdio::Stdout as io::Write>::write",
      "<&io::stdio::Stdout as io::Write>::write_vectored",
      "<&io::stdio::Stdout as io::Write>::is_write_vectored",
      "<&io::stdio::Stdout as io::Write>::flush",
      "<&io::stdio::Stdout as io::Write>::write_all",
      "<&io::stdio::Stdout as io::Write>::write_all_vectored",
      "<&io::stdio::Stdout as io::Write>::write_fmt"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "<io::stdio::StdoutLock<'_> as io::Write>::write",
        "<io::stdio::StdoutLock<'_> as io::Write>::write_vectored",
        "<io::stdio::StdoutLock<'_> as io::Write>::is_write_vectored",
        "<io::stdio::StdoutLock<'_> as io::Write>::flush",
        "<io::stdio::StdoutLock<'_> as io::Write>::write_all",
        "<io::stdio::StdoutLock<'_> as io::Write>::write_all_vectored"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/io/stdio.rs:640:1: 640:26",
  "src": "pub struct StdoutLock<'a>",
  "kind": "Struct",
  "doc_adt": " A locked reference to the [`Stdout`] handle.\n\n This handle implements the [`Write`] trait, and is constructed via\n the [`Stdout::lock`] method. See its documentation for more.\n\n By default, the handle is line-buffered when connected to a terminal, meaning\n it flushes automatically when a newline (`\\n`) is encountered. For immediate\n output, you can manually call the [`flush`] method. When the handle goes out\n of scope, the buffer is automatically flushed.\n\n ### Note: Windows Portability Considerations\n\n When operating in a console, the Windows implementation of this stream does not support\n non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n an error.\n\n In a process with a detached console, such as one using\n `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n the contained handle will be null. In such cases, the standard library's `Read` and\n `Write` will do nothing and silently succeed. All other I/O operations, via the\n standard library or via raw Windows API calls, will fail.\n\n [`flush`]: Write::flush\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}