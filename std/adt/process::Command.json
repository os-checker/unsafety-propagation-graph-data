{
  "name": "process::Command",
  "constructors": [
    "process::Command::new"
  ],
  "access_self_as_arg": {
    "read": [
      "process::Command::get_program",
      "process::Command::get_args",
      "process::Command::get_envs",
      "process::Command::get_current_dir",
      "process::Command::get_env_clear",
      "<process::Command as core::fmt::Debug>::fmt",
      "<process::Command as sys_common::AsInner<sys::process::unix::common::Command>>::as_inner"
    ],
    "write": [
      "<process::Command as os::unix::process::CommandExt>::uid",
      "<process::Command as os::unix::process::CommandExt>::gid",
      "<process::Command as os::unix::process::CommandExt>::groups",
      "<process::Command as os::unix::process::CommandExt>::pre_exec",
      "<process::Command as os::unix::process::CommandExt>::exec",
      "<process::Command as os::unix::process::CommandExt>::arg0",
      "<process::Command as os::unix::process::CommandExt>::process_group",
      "<process::Command as os::unix::process::CommandExt>::chroot",
      "<process::Command as os::unix::process::CommandExt>::setsid",
      "<process::Command as os::linux::process::CommandExt>::create_pidfd",
      "process::Command::arg",
      "process::Command::args",
      "process::Command::env",
      "process::Command::envs",
      "process::Command::env_remove",
      "process::Command::env_clear",
      "process::Command::current_dir",
      "process::Command::stdin",
      "process::Command::stdout",
      "process::Command::stderr",
      "process::Command::spawn",
      "process::Command::output",
      "process::Command::status",
      "<process::Command as sys_common::AsInnerMut<sys::process::unix::common::Command>>::as_inner_mut"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "os::unix::process::CommandExt::before_exec"
    ],
    "other": [
      "process::Command::new"
    ]
  },
  "access_field": [
    {
      "read": [
        "process::Command::get_program",
        "process::Command::get_args",
        "process::Command::get_envs",
        "process::Command::get_current_dir",
        "process::Command::get_env_clear",
        "<process::Command as core::fmt::Debug>::fmt",
        "<process::Command as sys_common::AsInner<sys::process::unix::common::Command>>::as_inner"
      ],
      "write": [
        "process::Command::arg",
        "process::Command::env",
        "process::Command::envs",
        "process::Command::env_remove",
        "process::Command::env_clear",
        "process::Command::current_dir",
        "process::Command::stdin",
        "process::Command::stdout",
        "process::Command::stderr",
        "process::Command::spawn",
        "process::Command::output",
        "process::Command::status",
        "<process::Command as sys_common::AsInnerMut<sys::process::unix::common::Command>>::as_inner_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/process.rs:597:1: 597:19",
  "src": "pub struct Command",
  "kind": "Struct",
  "doc_adt": " A process builder, providing fine-grained control\n over how a new process should be spawned.\n\n A default configuration can be\n generated using `Command::new(program)`, where `program` gives a path to the\n program to be executed. Additional builder methods allow the configuration\n to be changed (for example, by adding arguments) prior to spawning:\n\n ```\n # if cfg!(not(all(target_vendor = \"apple\", not(target_os = \"macos\")))) {\n use std::process::Command;\n\n let output = if cfg!(target_os = \"windows\") {\n     Command::new(\"cmd\")\n         .args([\"/C\", \"echo hello\"])\n         .output()\n         .expect(\"failed to execute process\")\n } else {\n     Command::new(\"sh\")\n         .arg(\"-c\")\n         .arg(\"echo hello\")\n         .output()\n         .expect(\"failed to execute process\")\n };\n\n let hello = output.stdout;\n # }\n ```\n\n `Command` can be reused to spawn multiple processes. The builder methods\n change the command without needing to immediately spawn the process.\n\n ```no_run\n use std::process::Command;\n\n let mut echo_hello = Command::new(\"sh\");\n echo_hello.arg(\"-c\").arg(\"echo hello\");\n let hello_1 = echo_hello.output().expect(\"failed to execute process\");\n let hello_2 = echo_hello.output().expect(\"failed to execute process\");\n ```\n\n Similarly, you can call builder methods after spawning a process and then\n spawn a new process with the modified settings.\n\n ```no_run\n use std::process::Command;\n\n let mut list_dir = Command::new(\"ls\");\n\n // Execute `ls` in the current directory of the program.\n list_dir.status().expect(\"process failed to execute\");\n\n println!();\n\n // Change `ls` to execute in the root directory.\n list_dir.current_dir(\"/\");\n\n // And then execute `ls` again but in the root directory.\n list_dir.status().expect(\"process failed to execute\");\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}