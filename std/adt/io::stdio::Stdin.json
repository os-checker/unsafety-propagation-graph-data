{
  "name": "io::stdio::Stdin",
  "constructors": [
    "io::stdio::stdin"
  ],
  "access_self_as_arg": {
    "read": [
      "io::stdio::Stdin::lock",
      "io::stdio::Stdin::read_line",
      "io::stdio::Stdin::lines",
      "<io::stdio::Stdin as core::fmt::Debug>::fmt",
      "<io::stdio::Stdin as io::Read>::read",
      "<io::stdio::Stdin as io::Read>::read_buf",
      "<io::stdio::Stdin as io::Read>::read_vectored",
      "<io::stdio::Stdin as io::Read>::is_read_vectored",
      "<io::stdio::Stdin as io::Read>::read_to_end",
      "<io::stdio::Stdin as io::Read>::read_to_string",
      "<io::stdio::Stdin as io::Read>::read_exact",
      "<io::stdio::Stdin as io::Read>::read_buf_exact",
      "<io::stdio::Stdin as os::fd::raw::AsRawFd>::as_raw_fd",
      "<io::stdio::Stdin as os::fd::owned::AsFd>::as_fd",
      "<io::stdio::Stdin as io::stdio::IsTerminal>::is_terminal"
    ],
    "write": [
      "<io::stdio::Stdin as io::Read>::read",
      "<io::stdio::Stdin as io::Read>::read_buf",
      "<io::stdio::Stdin as io::Read>::read_vectored",
      "<io::stdio::Stdin as io::Read>::read_to_end",
      "<io::stdio::Stdin as io::Read>::read_to_string",
      "<io::stdio::Stdin as io::Read>::read_exact",
      "<io::stdio::Stdin as io::Read>::read_buf_exact",
      "<io::stdio::Stdin as io::Read>::read",
      "<io::stdio::Stdin as io::Read>::read_buf",
      "<io::stdio::Stdin as io::Read>::read_vectored",
      "<io::stdio::Stdin as io::Read>::read_to_end",
      "<io::stdio::Stdin as io::Read>::read_to_string",
      "<io::stdio::Stdin as io::Read>::read_exact",
      "<io::stdio::Stdin as io::Read>::read_buf_exact"
    ],
    "other": [
      "io::stdio::Stdin::lines"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "<&io::stdio::Stdin as io::Read>::read",
      "<&io::stdio::Stdin as io::Read>::read_buf",
      "<&io::stdio::Stdin as io::Read>::read_vectored",
      "<&io::stdio::Stdin as io::Read>::is_read_vectored",
      "<&io::stdio::Stdin as io::Read>::read_to_end",
      "<&io::stdio::Stdin as io::Read>::read_to_string",
      "<&io::stdio::Stdin as io::Read>::read_exact",
      "<&io::stdio::Stdin as io::Read>::read_buf_exact"
    ],
    "write": [],
    "other": [
      "io::stdio::stdin"
    ]
  },
  "access_field": [
    {
      "read": [
        "io::stdio::Stdin::lock"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/std/src/io/stdio.rs:250:1: 250:17",
  "src": "pub struct Stdin",
  "kind": "Struct",
  "doc_adt": " A handle to the standard input stream of a process.\n\n Each handle is a shared reference to a global buffer of input data to this\n process. A handle can be `lock`'d to gain full access to [`BufRead`] methods\n (e.g., `.lines()`). Reads to this handle are otherwise locked with respect\n to other reads.\n\n This handle implements the `Read` trait, but beware that concurrent reads\n of `Stdin` must be executed with care.\n\n Created by the [`io::stdin`] method.\n\n [`io::stdin`]: stdin\n\n ### Note: Windows Portability Considerations\n\n When operating in a console, the Windows implementation of this stream does not support\n non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n an error.\n\n In a process with a detached console, such as one using\n `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n the contained handle will be null. In such cases, the standard library's `Read` and\n `Write` will do nothing and silently succeed. All other I/O operations, via the\n standard library or via raw Windows API calls, will fail.\n\n # Examples\n\n ```no_run\n use std::io;\n\n fn main() -> io::Result<()> {\n     let mut buffer = String::new();\n     let stdin = io::stdin(); // We get `Stdin` here.\n     stdin.read_line(&mut buffer)?;\n     Ok(())\n }\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}