{
  "name": "sync::poison::rwlock::RwLock",
  "constructors": [
    "sync::poison::rwlock::RwLock::<T>::new",
    "<sync::poison::rwlock::RwLock<T> as core::default::Default>::default",
    "<sync::poison::rwlock::RwLock<T> as core::convert::From<T>>::from"
  ],
  "access_self_as_arg": {
    "read": [
      "sync::poison::rwlock::RwLock::<T>::get_cloned",
      "sync::poison::rwlock::RwLock::<T>::set",
      "sync::poison::rwlock::RwLock::<T>::replace",
      "sync::poison::rwlock::RwLock::<T>::read",
      "sync::poison::rwlock::RwLock::<T>::try_read",
      "sync::poison::rwlock::RwLock::<T>::write",
      "sync::poison::rwlock::RwLock::<T>::try_write",
      "sync::poison::rwlock::RwLock::<T>::is_poisoned",
      "sync::poison::rwlock::RwLock::<T>::clear_poison",
      "sync::poison::rwlock::RwLock::<T>::data_ptr",
      "<sync::poison::rwlock::RwLock<T> as core::fmt::Debug>::fmt",
      "sync::poison::rwlock::RwLockReadGuard::<'rwlock, T>::new",
      "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::new"
    ],
    "write": [
      "sync::poison::rwlock::RwLock::<T>::get_mut"
    ],
    "other": [
      "sync::poison::rwlock::RwLock::<T>::into_inner",
      "sync::poison::rwlock::RwLock::<T>::into_inner",
      "sync::poison::rwlock::RwLock::<T>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::downgrade",
      "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
      "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
      "<sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::Drop>::drop",
      "<sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::Deref>::deref",
      "<sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::DerefMut>::deref_mut",
      "sys::env::unix::env_read_lock"
    ],
    "write": [],
    "other": [
      "sync::poison::rwlock::RwLock::<T>::new",
      "<sync::poison::rwlock::RwLock<T> as core::default::Default>::default",
      "<sync::poison::rwlock::RwLock<T> as core::convert::From<T>>::from"
    ]
  },
  "access_field": [
    {
      "read": [
        "sync::poison::rwlock::RwLock::<T>::read",
        "sync::poison::rwlock::RwLock::<T>::try_read",
        "sync::poison::rwlock::RwLock::<T>::write",
        "sync::poison::rwlock::RwLock::<T>::try_write",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::downgrade",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
        "<sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::Drop>::drop"
      ],
      "write": [],
      "other": []
    },
    {
      "read": [
        "sync::poison::rwlock::RwLock::<T>::is_poisoned",
        "sync::poison::rwlock::RwLock::<T>::clear_poison",
        "<sync::poison::rwlock::RwLock<T> as core::fmt::Debug>::fmt",
        "sync::poison::rwlock::RwLockReadGuard::<'rwlock, T>::new",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::new",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
        "<sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::Drop>::drop"
      ],
      "write": [
        "sync::poison::rwlock::RwLock::<T>::get_mut"
      ],
      "other": []
    },
    {
      "read": [
        "sync::poison::rwlock::RwLock::<T>::data_ptr",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::map",
        "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::filter_map",
        "<sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::Deref>::deref",
        "<sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::DerefMut>::deref_mut"
      ],
      "write": [
        "sync::poison::rwlock::RwLock::<T>::get_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/sync/poison/rwlock.rs:82:1: 82:29",
  "src": "pub struct RwLock<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A reader-writer lock\n\n This type of lock allows a number of readers or at most one writer at any\n point in time. The write portion of this lock typically allows modification\n of the underlying data (exclusive access) and the read portion of this lock\n typically allows for read-only access (shared access).\n\n In comparison, a [`Mutex`] does not distinguish between readers or writers\n that acquire the lock, therefore blocking any threads waiting for the lock to\n become available. An `RwLock` will allow any number of readers to acquire the\n lock as long as a writer is not holding the lock.\n\n The priority policy of the lock is dependent on the underlying operating\n system's implementation, and this type does not guarantee that any\n particular policy will be used. In particular, a writer which is waiting to\n acquire the lock in `write` might or might not block concurrent calls to\n `read`, e.g.:\n\n <details><summary>Potential deadlock example</summary>\n\n ```text\n // Thread 1              |  // Thread 2\n let _rg1 = lock.read();  |\n                          |  // will block\n                          |  let _wg = lock.write();\n // may deadlock          |\n let _rg2 = lock.read();  |\n ```\n\n </details>\n\n The type parameter `T` represents the data that this lock protects. It is\n required that `T` satisfies [`Send`] to be shared across threads and\n [`Sync`] to allow concurrent access through readers. The RAII guards\n returned from the locking methods implement [`Deref`] (and [`DerefMut`]\n for the `write` methods) to allow access to the content of the lock.\n\n # Poisoning\n\n An `RwLock`, like [`Mutex`], will [usually] become poisoned on a panic. Note,\n however, that an `RwLock` may only be poisoned if a panic occurs while it is\n locked exclusively (write mode). If a panic occurs in any reader, then the\n lock will not be poisoned.\n\n [usually]: super::Mutex#poisoning\n\n # Examples\n\n ```\n use std::sync::RwLock;\n\n let lock = RwLock::new(5);\n\n // many reader locks can be held at once\n {\n     let r1 = lock.read().unwrap();\n     let r2 = lock.read().unwrap();\n     assert_eq!(*r1, 5);\n     assert_eq!(*r2, 5);\n } // read locks are dropped at this point\n\n // only one write lock may be held, however\n {\n     let mut w = lock.write().unwrap();\n     *w += 1;\n     assert_eq!(*w, 6);\n } // write lock is dropped here\n ```\n\n [`Mutex`]: super::Mutex\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": " The inner [`sys::RwLock`] that synchronizes thread access to the protected data.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "poison",
      "doc": " A flag denoting if this `RwLock` has been poisoned.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "data",
      "doc": " The lock-protected data.\n"
    }
  }
}