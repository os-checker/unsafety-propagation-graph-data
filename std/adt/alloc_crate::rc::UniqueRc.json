{
  "name": "alloc_crate::rc::UniqueRc",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "<alloc_crate::rc::UniqueRc<T> as os::fd::raw::AsRawFd>::as_raw_fd",
      "<alloc_crate::rc::UniqueRc<T> as os::fd::owned::AsFd>::as_fd"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/alloc/src/rc.rs:3896:1: 3899:2",
  "src": "pub struct UniqueRc<\n    T: ?Sized,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n>",
  "kind": "Struct",
  "doc_adt": " A uniquely owned [`Rc`].\n\n This represents an `Rc` that is known to be uniquely owned -- that is, have exactly one strong\n reference. Multiple weak pointers can be created, but attempts to upgrade those to strong\n references will fail unless the `UniqueRc` they point to has been converted into a regular `Rc`.\n\n Because they are uniquely owned, the contents of a `UniqueRc` can be freely mutated. A common\n use case is to have an object be mutable during its initialization phase but then have it become\n immutable and converted to a normal `Rc`.\n\n This can be used as a flexible way to create cyclic data structures, as in the example below.\n\n ```\n #![feature(unique_rc_arc)]\n use std::rc::{Rc, Weak, UniqueRc};\n\n struct Gadget {\n     #[allow(dead_code)]\n     me: Weak<Gadget>,\n }\n\n fn create_gadget() -> Option<Rc<Gadget>> {\n     let mut rc = UniqueRc::new(Gadget {\n         me: Weak::new(),\n     });\n     rc.me = UniqueRc::downgrade(&rc);\n     Some(UniqueRc::into_rc(rc))\n }\n\n create_gadget().unwrap();\n ```\n\n An advantage of using `UniqueRc` over [`Rc::new_cyclic`] to build cyclic data structures is that\n [`Rc::new_cyclic`]'s `data_fn` parameter cannot be async or return a [`Result`]. As shown in the\n previous example, `UniqueRc` allows for more flexibility in the construction of cyclic data,\n including fallible or async constructors.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "ptr",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "_marker2",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(3))": {
      "name": "alloc",
      "doc": ""
    }
  }
}