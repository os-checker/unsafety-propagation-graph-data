{
  "name": "core::convert::Infallible",
  "constructors": [
    "<ffi::os_str::OsString as core::str::FromStr>::from_str",
    "<path::PathBuf as core::str::FromStr>::from_str"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [],
  "span": "$library/core/src/convert/mod.rs:930:1: 930:20",
  "src": "pub enum Infallible",
  "kind": "Enum",
  "doc_adt": " The error type for errors that can never happen.\n\n Since this enum has no variant, a value of this type can never actually exist.\n This can be useful for generic APIs that use [`Result`] and parameterize the error type,\n to indicate that the result is always [`Ok`].\n\n For example, the [`TryFrom`] trait (conversion that returns a [`Result`])\n has a blanket implementation for all types where a reverse [`Into`] implementation exists.\n\n ```ignore (illustrates std code, duplicating the impl in a doctest would be an error)\n impl<T, U> TryFrom<U> for T where U: Into<T> {\n     type Error = Infallible;\n\n     fn try_from(value: U) -> Result<Self, Infallible> {\n         Ok(U::into(value))  // Never returns `Err`\n     }\n }\n ```\n\n # Future compatibility\n\n This enum has the same role as [the `!` “never” type][never],\n which is unstable in this version of Rust.\n When `!` is stabilized, we plan to make `Infallible` a type alias to it:\n\n ```ignore (illustrates future std change)\n pub type Infallible = !;\n ```\n\n … and eventually deprecate `Infallible`.\n\n However there is one case where `!` syntax can be used\n before `!` is stabilized as a full-fledged type: in the position of a function’s return type.\n Specifically, it is possible to have implementations for two different function pointer types:\n\n ```\n trait MyTrait {}\n impl MyTrait for fn() -> ! {}\n impl MyTrait for fn() -> std::convert::Infallible {}\n ```\n\n With `Infallible` being an enum, this code is valid.\n However when `Infallible` becomes an alias for the never type,\n the two `impl`s will start to overlap\n and therefore will be disallowed by the language’s trait coherence rules.\n",
  "variant_fields": {}
}