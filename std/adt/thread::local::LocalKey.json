{
  "name": "thread::local::LocalKey",
  "constructors": [
    "thread::local::LocalKey::<T>::new"
  ],
  "access_self_as_arg": {
    "read": [
      "<thread::local::LocalKey<T> as core::fmt::Debug>::fmt",
      "thread::local::LocalKey::<T>::with",
      "thread::local::LocalKey::<T>::try_with",
      "thread::local::LocalKey::<T>::initialize_with",
      "thread::local::LocalKey::<core::cell::Cell<T>>::set",
      "thread::local::LocalKey::<core::cell::Cell<T>>::get",
      "thread::local::LocalKey::<core::cell::Cell<T>>::take",
      "thread::local::LocalKey::<core::cell::Cell<T>>::replace",
      "thread::local::LocalKey::<core::cell::Cell<T>>::update",
      "thread::local::LocalKey::<core::cell::RefCell<T>>::with_borrow",
      "thread::local::LocalKey::<core::cell::RefCell<T>>::with_borrow_mut",
      "thread::local::LocalKey::<core::cell::RefCell<T>>::set",
      "thread::local::LocalKey::<core::cell::RefCell<T>>::take",
      "thread::local::LocalKey::<core::cell::RefCell<T>>::replace"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "thread::spawnhook::add_spawn_hook",
      "thread::spawnhook::run_spawn_hooks",
      "thread::spawnhook::ChildSpawnHooks::run",
      "hash::random::RandomState::new",
      "io::stdio::try_set_output_capture",
      "io::stdio::print_to_buffer_if_capture_used",
      "sync::mpmc::context::Context::with",
      "sync::mpmc::waker::current_thread_id",
      "panicking::panic_count::increase",
      "panicking::panic_count::finished_panic_hook",
      "panicking::panic_count::decrease",
      "panicking::panic_count::get_count",
      "panicking::panic_count::is_zero_slow_path"
    ],
    "write": [],
    "other": [
      "thread::local::LocalKey::<T>::new"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "thread::local::LocalKey::<T>::try_with",
        "thread::local::LocalKey::<T>::initialize_with"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/thread/local.rs:115:1: 115:32",
  "src": "pub struct LocalKey<T: 'static>",
  "kind": "Struct",
  "doc_adt": " A thread local storage (TLS) key which owns its contents.\n\n This key uses the fastest implementation available on the target platform.\n It is instantiated with the [`thread_local!`] macro and the\n primary method is the [`with`] method, though there are helpers to make\n working with [`Cell`] types easier.\n\n The [`with`] method yields a reference to the contained value which cannot\n outlive the current thread or escape the given closure.\n\n [`thread_local!`]: crate::thread_local\n\n # Initialization and Destruction\n\n Initialization is dynamically performed on the first call to a setter (e.g.\n [`with`]) within a thread, and values that implement [`Drop`] get\n destructed when a thread exits. Some platform-specific caveats apply, which\n are explained below.\n Note that, should the destructor panic, the whole process will be [aborted].\n On platforms where initialization requires memory allocation, this is\n performed directly through [`System`], allowing the [global allocator]\n to make use of thread local storage.\n\n A `LocalKey`'s initializer cannot recursively depend on itself. Using a\n `LocalKey` in this way may cause panics, aborts, or infinite recursion on\n the first call to `with`.\n\n [`System`]: crate::alloc::System\n [global allocator]: crate::alloc\n [aborted]: crate::process::abort\n\n # Single-thread Synchronization\n\n Though there is no potential race with other threads, it is still possible to\n obtain multiple references to the thread-local data in different places on\n the call stack. For this reason, only shared (`&T`) references may be obtained.\n\n To allow obtaining an exclusive mutable reference (`&mut T`), typically a\n [`Cell`] or [`RefCell`] is used (see the [`std::cell`] for more information\n on how exactly this works). To make this easier there are specialized\n implementations for [`LocalKey<Cell<T>>`] and [`LocalKey<RefCell<T>>`].\n\n [`std::cell`]: `crate::cell`\n [`LocalKey<Cell<T>>`]: struct.LocalKey.html#impl-LocalKey<Cell<T>>\n [`LocalKey<RefCell<T>>`]: struct.LocalKey.html#impl-LocalKey<RefCell<T>>\n\n\n # Examples\n\n ```\n use std::cell::Cell;\n use std::thread;\n\n // explicit `const {}` block enables more efficient initialization\n thread_local!(static FOO: Cell<u32> = const { Cell::new(1) });\n\n assert_eq!(FOO.get(), 1);\n FOO.set(2);\n\n // each thread starts out with the initial value of 1\n let t = thread::spawn(move || {\n     assert_eq!(FOO.get(), 1);\n     FOO.set(3);\n });\n\n // wait for the thread to complete and bail out on panic\n t.join().unwrap();\n\n // we retain our original value of 2 despite the child thread\n assert_eq!(FOO.get(), 2);\n ```\n\n # Platform-specific behavior\n\n Note that a \"best effort\" is made to ensure that destructors for types\n stored in thread local storage are run, but not all platforms can guarantee\n that destructors will be run for all types in thread local storage. For\n example, there are a number of known caveats where destructors are not run:\n\n 1. On Unix systems when pthread-based TLS is being used, destructors will\n    not be run for TLS values on the main thread when it exits. Note that the\n    application will exit immediately after the main thread exits as well.\n 2. On all platforms it's possible for TLS to re-initialize other TLS slots\n    during destruction. Some platforms ensure that this cannot happen\n    infinitely by preventing re-initialization of any slot that has been\n    destroyed, but not all platforms have this guard. Those platforms that do\n    not guard typically have a synthetic limit after which point no more\n    destructors are run.\n 3. When the process exits on Windows systems, TLS destructors may only be\n    run on the thread that causes the process to exit. This is because the\n    other threads may be forcibly terminated.\n\n ## Synchronization in thread-local destructors\n\n On Windows, synchronization operations (such as [`JoinHandle::join`]) in\n thread local destructors are prone to deadlocks and so should be avoided.\n This is because the [loader lock] is held while a destructor is run. The\n lock is acquired whenever a thread starts or exits or when a DLL is loaded\n or unloaded. Therefore these events are blocked for as long as a thread\n local destructor is running.\n\n [loader lock]: https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices\n [`JoinHandle::join`]: crate::thread::JoinHandle::join\n [`with`]: LocalKey::with\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}