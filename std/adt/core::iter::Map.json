{
  "name": "core::iter::Map",
  "constructors": [
    "std::sys::pal::unix::os::split_paths",
    "std::backtrace_rs::symbolize::gimli::lru::Lru::<T, N>::iter"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "std::<env::SplitPaths<'a> as core::iter::Iterator>::size_hint"
    ],
    "write": [
      "std::<env::SplitPaths<'a> as core::iter::Iterator>::next",
      "std::backtrace_rs::symbolize::gimli::Cache::mapping_for_lib"
    ],
    "other": [
      "std::thread::spawnhook::run_spawn_hooks",
      "std::<collections::hash::map::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt",
      "std::<collections::hash::map::IntoKeys<K, V> as core::fmt::Debug>::fmt",
      "std::<collections::hash::map::IntoValues<K, V> as core::fmt::Debug>::fmt",
      "std::env::split_paths",
      "std::<io::buffered::bufreader::BufReader<R> as io::Read>::read_vectored",
      "std::<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_vectored",
      "std::io::impls::<impl io::Write for alloc_crate::vec::Vec<u8, A>>::write_vectored",
      "std::io::impls::<impl io::Write for alloc_crate::collections::VecDeque<u8, A>>::write_vectored",
      "std::<io::util::Empty as io::Write>::write_vectored",
      "std::<&io::util::Empty as io::Write>::write_vectored",
      "std::<io::util::Sink as io::Write>::write_vectored",
      "std::<&io::util::Sink as io::Write>::write_vectored",
      "std::sync::mpmc::array::Channel::<T>::with_capacity",
      "std::sys::pal::unix::os::parse_glibc_version",
      "std::sys::pal::unix::os::split_paths",
      "std::backtrace_rs::symbolize::gimli::lru::Lru::<T, N>::iter",
      "std::backtrace_rs::symbolize::gimli::Cache::mapping_for_lib",
      "std::backtrace_rs::symbolize::gimli::elf::Object::<'a>::parse",
      "std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/iter/adapters/map.rs:61:1: 61:21",
  "src": "pub struct Map<I, F>",
  "kind": "Struct",
  "doc_adt": " An iterator that maps the values of `iter` with `f`.\n\n This `struct` is created by the [`map`] method on [`Iterator`]. See its\n documentation for more.\n\n [`map`]: Iterator::map\n [`Iterator`]: trait.Iterator.html\n\n # Notes about side effects\n\n The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n you can also [`map`] backwards:\n\n ```rust\n let v: Vec<i32> = [1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n\n assert_eq!(v, [4, 3, 2]);\n ```\n\n [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n\n But if your closure has state, iterating backwards may act in a way you do\n not expect. Let's go through an example. First, in the forward direction:\n\n ```rust\n let mut c = 0;\n\n for pair in ['a', 'b', 'c'].into_iter()\n                                .map(|letter| { c += 1; (letter, c) }) {\n     println!(\"{pair:?}\");\n }\n ```\n\n This will print `('a', 1), ('b', 2), ('c', 3)`.\n\n Now consider this twist where we add a call to `rev`. This version will\n print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n but the values of the counter still go in order. This is because `map()` is\n still being called lazily on each item, but we are popping items off the\n back of the vector now, instead of shifting them from the front.\n\n ```rust\n let mut c = 0;\n\n for pair in ['a', 'b', 'c'].into_iter()\n                                .map(|letter| { c += 1; (letter, c) })\n                                .rev() {\n     println!(\"{pair:?}\");\n }\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "iter",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "f",
      "doc": ""
    }
  }
}