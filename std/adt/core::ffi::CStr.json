{
  "name": "core::ffi::CStr",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "sys::pal::unix::weak::dlsym::DlsymWeak::<F>::new",
      "sys::fs::unix::File::open_c",
      "sys::fs::unix::unlink",
      "sys::fs::unix::rename",
      "sys::fs::unix::set_perm",
      "sys::fs::unix::rmdir",
      "sys::fs::unix::readlink",
      "sys::fs::unix::symlink",
      "sys::fs::unix::link",
      "sys::fs::unix::stat",
      "sys::fs::unix::lstat",
      "sys::fs::unix::canonicalize",
      "sys::fs::unix::set_times_impl",
      "sys::fs::unix::set_times",
      "sys::fs::unix::set_times_nofollow",
      "sys::fs::unix::remove_dir_impl::openat_nofollow_dironly",
      "sys::fs::unix::remove_dir_impl::remove_dir_all_recursive",
      "sys::fs::unix::remove_dir_impl::remove_dir_all_modern",
      "sys::thread::unix::truncate_cstr",
      "sys::thread::unix::set_name",
      "sys::thread::unsupported::set_name"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "thread::lifecycle::ThreadInit::init",
      "thread::thread::thread_name_string::ThreadNameString::as_cstr",
      "thread::thread::thread_name_string::ThreadNameString::as_str",
      "thread::thread::Thread::cname",
      "sys::pal::common::small_c_string::run_with_cstr_stack",
      "sys::pal::common::small_c_string::run_with_cstr_allocating",
      "sys::pal::unix::os::error_string",
      "sys::pal::unix::os::getcwd",
      "sys::pal::unix::os::home_dir::fallback",
      "sys::pal::unix::os::glibc_version",
      "sys::args::unix::args",
      "sys::env::unix::env",
      "<sys::fs::unix::ReadDir as core::iter::Iterator>::next",
      "sys::fs::unix::DirEntry::metadata",
      "sys::fs::unix::DirEntry::name_bytes",
      "sys::fs::unix::DirEntry::name_cstr",
      "sys::fs::unix::File::file_attr",
      "sys::net::connection::socket::unix::cvt_gai",
      "<sys::process::unix::common::cstring_array::CStringArray as core::ops::Index<usize>>::index",
      "sys::process::unix::common::Command::get_program_cstr",
      "sys::process::unix::common::Command::program_is_path",
      "sys::process::unix::common::Stdio::to_child_stdio",
      "<sys::process::unix::common::Command as core::fmt::Debug>::fmt",
      "sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec",
      "sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn",
      "backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback"
    ],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ffi/c_str.rs:102:1: 102:16",
  "src": "pub struct CStr",
  "kind": "Struct",
  "doc_adt": " A dynamically-sized view of a C string.\n\n The type `&CStr` represents a reference to a borrowed nul-terminated\n array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n slice, or unsafely from a raw `*const c_char`. It can be expressed as a\n literal in the form `c\"Hello world\"`.\n\n The `&CStr` can then be converted to a Rust <code>&[str]</code> by performing\n UTF-8 validation, or into an owned `CString`.\n\n `&CStr` is to `CString` as <code>&[str]</code> is to `String`: the former\n in each pair are borrowing references; the latter are owned\n strings.\n\n Note that this structure does **not** have a guaranteed layout (the `repr(transparent)`\n notwithstanding) and should not be placed in the signatures of FFI functions.\n Instead, safe wrappers of FFI functions may leverage [`CStr::as_ptr`] and the unsafe\n [`CStr::from_ptr`] constructor to provide a safe interface to other consumers.\n\n # Examples\n\n Inspecting a foreign C string:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n # /* Extern functions are awkward in doc comments - fake it instead\n extern \"C\" { fn my_string() -> *const c_char; }\n # */ unsafe extern \"C\" fn my_string() -> *const c_char { c\"hello\".as_ptr() }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n }\n ```\n\n Passing a Rust-originating C string:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n fn work(data: &CStr) {\n     unsafe extern \"C\" fn work_with(s: *const c_char) {}\n     unsafe { work_with(data.as_ptr()) }\n }\n\n let s = c\"Hello world!\";\n work(&s);\n ```\n\n Converting a foreign C string into a Rust `String`:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n # /* Extern functions are awkward in doc comments - fake it instead\n extern \"C\" { fn my_string() -> *const c_char; }\n # */ unsafe extern \"C\" fn my_string() -> *const c_char { c\"hello\".as_ptr() }\n\n fn my_string_safe() -> String {\n     let cstr = unsafe { CStr::from_ptr(my_string()) };\n     // Get a copy-on-write Cow<'_, str>, then extract the\n     // allocated String (or allocate a fresh one if needed).\n     cstr.to_string_lossy().into_owned()\n }\n\n println!(\"string: {}\", my_string_safe());\n ```\n\n [str]: prim@str \"str\"\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}