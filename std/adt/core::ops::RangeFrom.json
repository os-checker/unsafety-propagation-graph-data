{
  "name": "core::ops::RangeFrom",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "<backtrace::Backtrace as core::fmt::Debug>::fmt",
      "<backtrace::Backtrace as core::fmt::Display>::fmt",
      "io::buffered::bufreader::buffer::Buffer::read_more",
      "io::buffered::bufwriter::BufWriter::<W>::flush_buf::BufGuard::<'a>::remaining",
      "<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write",
      "<&[u8] as io::copy::BufferedReaderSpec>::copy_to",
      "io::cursor::slice_write",
      "io::impls::<impl io::Read for &[u8]>::read_exact",
      "io::impls::<impl io::Read for &[u8]>::read_buf_exact",
      "io::impls::<impl io::Read for &[u8]>::read_to_end",
      "io::impls::<impl io::Read for &[u8]>::read_to_string",
      "io::impls::<impl io::BufRead for &[u8]>::consume",
      "io::append_to_string",
      "io::default_read_exact",
      "io::IoSliceMut::<'a>::advance_slices",
      "io::IoSlice::<'a>::advance_slices",
      "io::Write::write_all",
      "os::unix::fs::FileExt::read_exact_at",
      "os::unix::fs::FileExt::write_all_at",
      "<os::unix::net::ancillary::AncillaryDataIter<'a, T> as core::iter::Iterator>::next",
      "path::has_physical_root",
      "path::split_file_at_dot",
      "path::Components::<'a>::include_cur_dir",
      "path::Components::<'a>::parse_next_component_back",
      "path::Components::<'a>::trim_left",
      "<path::Components<'a> as core::iter::Iterator>::next",
      "path::compare_components",
      "path::PathBuf::_set_extension",
      "path::PathBuf::_add_extension",
      "<path::Path as core::hash::Hash>::hash",
      "backtrace_rs::symbolize::format_symbol_name",
      "sys::env::unix::env::parse",
      "sys::os_str::bytes::Slice::check_public_boundary::slow_path",
      "sys::random::linux::getrandom",
      "sys::random::linux::hashmap_random_keys",
      "backtrace_rs::symbolize::gimli::elf::Object::<'a>::section",
      "backtrace_rs::symbolize::gimli::elf::Object::<'a>::gnu_debugaltlink_path",
      "backtrace_rs::symbolize::gimli::elf::locate_build_id"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:197:1: 197:26",
  "src": "pub struct RangeFrom<Idx>",
  "kind": "Struct",
  "doc_adt": " A range only bounded inclusively below (`start..`).\n\n The `RangeFrom` `start..` contains all values with `x >= start`.\n\n *Note*: Overflow in the [`Iterator`] implementation (when the contained\n data type reaches its numerical limit) is allowed to panic, wrap, or\n saturate. This behavior is defined by the implementation of the [`Step`]\n trait. For primitive integers, this follows the normal rules, and respects\n the overflow checks profile (panic in debug, wrap in release). Note also\n that overflow happens earlier than you might assume: the overflow happens\n in the call to `next` that yields the maximum value, as the range must be\n set to a state to yield the next value.\n\n [`Step`]: crate::iter::Step\n\n # Examples\n\n The `start..` syntax is a `RangeFrom`:\n\n ```\n assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n ```\n\n ```\n let arr = [0, 1, 2, 3, 4];\n assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n assert_eq!(arr[1..  ], [   1, 2, 3, 4]); // This is a `RangeFrom`\n assert_eq!(arr[1.. 3], [   1, 2      ]);\n assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "start",
      "doc": " The lower bound of the range (inclusive).\n"
    }
  }
}