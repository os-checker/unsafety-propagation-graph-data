{
  "name": "alloc_crate::ffi::CString",
  "constructors": [
    "sys::process::unix::common::os2c"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "sys::process::unix::common::cstring_array::CStringArray::write",
      "sys::process::unix::common::cstring_array::CStringArray::push"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "thread::thread::thread_name_string::ThreadNameString::as_cstr",
      "thread::thread::thread_name_string::ThreadNameString::as_str",
      "sys::pal::common::small_c_string::run_with_cstr_allocating",
      "sys::fs::unix::DirEntry::name_cstr",
      "sys::process::unix::common::Command::new",
      "sys::process::unix::common::Command::get_program",
      "sys::process::unix::common::Command::get_program_cstr",
      "sys::process::unix::common::Command::program_is_path",
      "<sys::process::unix::common::Command as core::fmt::Debug>::fmt"
    ],
    "write": [],
    "other": [
      "<thread::thread::thread_name_string::ThreadNameString as core::convert::From<alloc_crate::string::String>>::from",
      "sys::pal::common::small_c_string::run_with_cstr_allocating",
      "<sys::fs::unix::ReadDir as core::iter::Iterator>::next",
      "sys::process::unix::common::Command::new",
      "sys::process::unix::common::Command::set_arg_0",
      "sys::process::unix::common::Command::arg",
      "sys::process::unix::common::Command::cwd",
      "sys::process::unix::common::Command::chroot",
      "sys::process::unix::common::os2c",
      "sys::process::unix::common::construct_envp"
    ]
  },
  "access_field": [
    {
      "read": [
        "<sys::process::unix::common::Command as core::fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/ffi/c_str.rs:107:1: 107:19",
  "src": "pub struct CString",
  "kind": "Struct",
  "doc_adt": " A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n middle.\n\n This type serves the purpose of being able to safely generate a\n C-compatible string from a Rust byte slice or vector. An instance of this\n type is a static guarantee that the underlying bytes contain no interior 0\n bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n\n `CString` is to <code>&[CStr]</code> as [`String`] is to <code>&[str]</code>: the former\n in each pair are owned strings; the latter are borrowed\n references.\n\n # Creating a `CString`\n\n A `CString` is created from either a byte slice or a byte vector,\n or anything that implements <code>[Into]<[Vec]<[u8]>></code> (for\n example, you can build a `CString` straight out of a [`String`] or\n a <code>&[str]</code>, since both implement that trait).\n You can create a `CString` from a literal with `CString::from(c\"Text\")`.\n\n The [`CString::new`] method will actually check that the provided <code>&[[u8]]</code>\n does not have 0 bytes in the middle, and return an error if it\n finds one.\n\n # Extracting a raw pointer to the whole C string\n\n `CString` implements an [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n trait. This method will give you a `*const c_char` which you can\n feed directly to extern functions that expect a nul-terminated\n string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n read-only pointer; if the C code writes to it, that causes\n undefined behavior.\n\n # Extracting a slice of the whole C string\n\n Alternatively, you can obtain a <code>&[[u8]]</code> slice from a\n `CString` with the [`CString::as_bytes`] method. Slices produced in this\n way do *not* contain the trailing nul terminator. This is useful\n when you will be calling an extern function that takes a `*const\n u8` argument which is not necessarily nul-terminated, plus another\n argument with the length of the string â€” like C's `strndup()`.\n You can of course get the slice's length with its\n [`len`][slice::len] method.\n\n If you need a <code>&[[u8]]</code> slice *with* the nul terminator, you\n can use [`CString::as_bytes_with_nul`] instead.\n\n Once you have the kind of slice you need (with or without a nul\n terminator), you can call the slice's own\n [`as_ptr`][slice::as_ptr] method to get a read-only raw pointer to pass to\n extern functions. See the documentation for that function for a\n discussion on ensuring the lifetime of the raw pointer.\n\n [str]: prim@str \"str\"\n [`Deref`]: ops::Deref\n\n # Examples\n\n ```ignore (extern-declaration)\n # fn main() {\n use std::ffi::CString;\n use std::os::raw::c_char;\n\n extern \"C\" {\n     fn my_printer(s: *const c_char);\n }\n\n // We are certain that our string doesn't have 0 bytes in the middle,\n // so we can .expect()\n let c_to_print = CString::new(\"Hello, world!\").expect(\"CString::new failed\");\n unsafe {\n     my_printer(c_to_print.as_ptr());\n }\n # }\n ```\n\n # Safety\n\n `CString` is intended for working with traditional C-style strings\n (a sequence of non-nul bytes terminated by a single nul byte); the\n primary use case for these kinds of strings is interoperating with C-like\n code. Often you will need to transfer ownership to/from that external\n code. It is strongly recommended that you thoroughly read through the\n documentation of `CString` before use, as improper ownership management\n of `CString` instances can lead to invalid memory accesses, memory leaks,\n and other memory errors.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}