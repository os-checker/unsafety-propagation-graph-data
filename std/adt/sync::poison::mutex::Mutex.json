{
  "name": "sync::poison::mutex::Mutex",
  "constructors": [
    "io::stdio::set_output_capture",
    "io::stdio::try_set_output_capture",
    "sync::poison::mutex::Mutex::<T>::new",
    "<sync::poison::mutex::Mutex<T> as core::convert::From<T>>::from",
    "<sync::poison::mutex::Mutex<T> as core::default::Default>::default"
  ],
  "access_self_as_arg": {
    "read": [
      "sync::poison::mutex::Mutex::<T>::get_cloned",
      "sync::poison::mutex::Mutex::<T>::set",
      "sync::poison::mutex::Mutex::<T>::replace",
      "sync::poison::mutex::Mutex::<T>::lock",
      "sync::poison::mutex::Mutex::<T>::try_lock",
      "sync::poison::mutex::Mutex::<T>::is_poisoned",
      "sync::poison::mutex::Mutex::<T>::clear_poison",
      "sync::poison::mutex::Mutex::<T>::data_ptr",
      "<sync::poison::mutex::Mutex<T> as core::fmt::Debug>::fmt",
      "sync::poison::mutex::MutexGuard::<'mutex, T>::new"
    ],
    "write": [
      "sync::poison::mutex::Mutex::<T>::get_mut"
    ],
    "other": [
      "sync::poison::mutex::Mutex::<T>::into_inner",
      "sync::poison::mutex::Mutex::<T>::into_inner",
      "sync::poison::mutex::Mutex::<T>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "io::stdio::stdin",
      "io::stdio::Stdin::lock",
      "sync::mpmc::waker::SyncWaker::register",
      "sync::mpmc::waker::SyncWaker::unregister",
      "sync::mpmc::waker::SyncWaker::notify",
      "sync::mpmc::waker::SyncWaker::disconnect",
      "sync::mpmc::zero::Channel::<T>::try_send",
      "sync::mpmc::zero::Channel::<T>::send",
      "sync::mpmc::zero::Channel::<T>::try_recv",
      "sync::mpmc::zero::Channel::<T>::recv",
      "sync::mpmc::zero::Channel::<T>::disconnect",
      "<sync::poison::mutex::MutexGuard<'_, T> as core::ops::Deref>::deref",
      "<sync::poison::mutex::MutexGuard<'_, T> as core::ops::DerefMut>::deref_mut",
      "<sync::poison::mutex::MutexGuard<'_, T> as core::ops::Drop>::drop",
      "sync::poison::mutex::guard_lock",
      "sync::poison::mutex::guard_poison",
      "sync::poison::mutex::MutexGuard::<'a, T>::map",
      "sync::poison::mutex::MutexGuard::<'a, T>::filter_map",
      "sys::backtrace::lock",
      "panicking::default_hook",
      "sys::pal::unix::stack_overflow::thread_info::set_current_info",
      "sys::pal::unix::stack_overflow::thread_info::delete_current_info"
    ],
    "write": [],
    "other": [
      "sync::mpmc::waker::SyncWaker::new",
      "sync::mpmc::zero::Channel::<T>::new",
      "sync::poison::mutex::Mutex::<T>::new",
      "<sync::poison::mutex::Mutex<T> as core::convert::From<T>>::from",
      "<sync::poison::mutex::Mutex<T> as core::default::Default>::default"
    ]
  },
  "access_field": [
    {
      "read": [
        "sync::poison::mutex::Mutex::<T>::lock",
        "sync::poison::mutex::Mutex::<T>::try_lock",
        "<sync::poison::mutex::MutexGuard<'_, T> as core::ops::Drop>::drop",
        "sync::poison::mutex::guard_lock",
        "sync::poison::mutex::MutexGuard::<'a, T>::map",
        "sync::poison::mutex::MutexGuard::<'a, T>::filter_map"
      ],
      "write": [],
      "other": []
    },
    {
      "read": [
        "sync::poison::mutex::Mutex::<T>::is_poisoned",
        "sync::poison::mutex::Mutex::<T>::clear_poison",
        "<sync::poison::mutex::Mutex<T> as core::fmt::Debug>::fmt",
        "sync::poison::mutex::MutexGuard::<'mutex, T>::new",
        "<sync::poison::mutex::MutexGuard<'_, T> as core::ops::Drop>::drop",
        "sync::poison::mutex::guard_poison",
        "sync::poison::mutex::MutexGuard::<'a, T>::map",
        "sync::poison::mutex::MutexGuard::<'a, T>::filter_map"
      ],
      "write": [
        "sync::poison::mutex::Mutex::<T>::get_mut"
      ],
      "other": []
    },
    {
      "read": [
        "sync::poison::mutex::Mutex::<T>::data_ptr",
        "<sync::poison::mutex::MutexGuard<'_, T> as core::ops::Deref>::deref",
        "<sync::poison::mutex::MutexGuard<'_, T> as core::ops::DerefMut>::deref_mut",
        "sync::poison::mutex::MutexGuard::<'a, T>::map",
        "sync::poison::mutex::MutexGuard::<'a, T>::filter_map"
      ],
      "write": [
        "sync::poison::mutex::Mutex::<T>::get_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/sync/poison/mutex.rs:227:1: 227:28",
  "src": "pub struct Mutex<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A mutual exclusion primitive useful for protecting shared data\n\n This mutex will block threads waiting for the lock to become available. The\n mutex can be created via a [`new`] constructor. Each mutex has a type parameter\n which represents the data that it is protecting. The data can only be accessed\n through the RAII guards returned from [`lock`] and [`try_lock`], which\n guarantees that the data is only ever accessed when the mutex is locked.\n\n # Poisoning\n\n The mutexes in this module implement a strategy called \"poisoning\" where a\n mutex becomes poisoned if it recognizes that the thread holding it has\n panicked.\n\n Once a mutex is poisoned, all other threads are unable to access the data by\n default as it is likely tainted (some invariant is not being upheld). For a\n mutex, this means that the [`lock`] and [`try_lock`] methods return a\n [`Result`] which indicates whether a mutex has been poisoned or not. Most\n usage of a mutex will simply [`unwrap()`] these results, propagating panics\n among threads to ensure that a possibly invalid invariant is not witnessed.\n\n Poisoning is only advisory: the [`PoisonError`] type has an [`into_inner`]\n method which will return the guard that would have otherwise been returned\n on a successful lock. This allows access to the data, despite the lock being\n poisoned.\n\n In addition, the panic detection is not ideal, so even unpoisoned mutexes\n need to be handled with care, since certain panics may have been skipped.\n Here is a non-exhaustive list of situations where this might occur:\n\n - If a mutex is locked while a panic is underway, e.g. within a [`Drop`]\n   implementation or a [panic hook], panicking for the second time while the\n   lock is held will leave the mutex unpoisoned. Note that while double panic\n   usually aborts the program, [`catch_unwind`] can prevent this.\n\n - Locking and unlocking the mutex across different panic contexts, e.g. by\n   storing the guard to a [`Cell`] within [`Drop::drop`] and accessing it\n   outside, or vice versa, can affect poisoning status in an unexpected way.\n\n - Foreign exceptions do not currently trigger poisoning even in absence of\n   other panics.\n\n While this rarely happens in realistic code, `unsafe` code cannot rely on\n poisoning for soundness, since the behavior of poisoning can depend on\n outside context. Here's an example of **incorrect** use of poisoning:\n\n ```rust\n use std::sync::Mutex;\n\n struct MutexBox<T> {\n     data: Mutex<*mut T>,\n }\n\n impl<T> MutexBox<T> {\n     pub fn new(value: T) -> Self {\n         Self {\n             data: Mutex::new(Box::into_raw(Box::new(value))),\n         }\n     }\n\n     pub fn replace_with(&self, f: impl FnOnce(T) -> T) {\n         let ptr = self.data.lock().expect(\"poisoned\");\n         // While `f` is running, the data is moved out of `*ptr`. If `f`\n         // panics, `*ptr` keeps pointing at a dropped value. The intention\n         // is that this will poison the mutex, so the following calls to\n         // `replace_with` will panic without reading `*ptr`. But since\n         // poisoning is not guaranteed to occur if this is run from a panic\n         // hook, this can lead to use-after-free.\n         unsafe {\n             (*ptr).write(f((*ptr).read()));\n         }\n     }\n }\n ```\n\n [`new`]: Self::new\n [`lock`]: Self::lock\n [`try_lock`]: Self::try_lock\n [`unwrap()`]: Result::unwrap\n [`PoisonError`]: super::PoisonError\n [`into_inner`]: super::PoisonError::into_inner\n [panic hook]: crate::panic::set_hook\n [`catch_unwind`]: crate::panic::catch_unwind\n [`Cell`]: crate::cell::Cell\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n use std::sync::mpsc::channel;\n\n const N: usize = 10;\n\n // Spawn a few threads to increment a shared variable (non-atomically), and\n // let the main thread know once all increments are done.\n //\n // Here we're using an Arc to share memory among threads, and the data inside\n // the Arc is protected with a mutex.\n let data = Arc::new(Mutex::new(0));\n\n let (tx, rx) = channel();\n for _ in 0..N {\n     let (data, tx) = (Arc::clone(&data), tx.clone());\n     thread::spawn(move || {\n         // The shared state can only be accessed once the lock is held.\n         // Our non-atomic increment is safe because we're the only thread\n         // which can access the shared state when the lock is held.\n         //\n         // We unwrap() the return value to assert that we are not expecting\n         // threads to ever fail while holding the lock.\n         let mut data = data.lock().unwrap();\n         *data += 1;\n         if *data == N {\n             tx.send(()).unwrap();\n         }\n         // the lock is unlocked here when `data` goes out of scope.\n     });\n }\n\n rx.recv().unwrap();\n ```\n\n To recover from a poisoned mutex:\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n\n let lock = Arc::new(Mutex::new(0_u32));\n let lock2 = Arc::clone(&lock);\n\n let _ = thread::spawn(move || -> () {\n     // This thread will acquire the mutex first, unwrapping the result of\n     // `lock` because the lock has not been poisoned.\n     let _guard = lock2.lock().unwrap();\n\n     // This panic while holding the lock (`_guard` is in scope) will poison\n     // the mutex.\n     panic!();\n }).join();\n\n // The lock is poisoned by this point, but the returned result can be\n // pattern matched on to return the underlying guard on both branches.\n let mut guard = match lock.lock() {\n     Ok(guard) => guard,\n     Err(poisoned) => poisoned.into_inner(),\n };\n\n *guard += 1;\n ```\n\n To unlock a mutex guard sooner than the end of the enclosing scope,\n either create an inner scope or drop the guard manually.\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n\n const N: usize = 3;\n\n let data_mutex = Arc::new(Mutex::new(vec![1, 2, 3, 4]));\n let res_mutex = Arc::new(Mutex::new(0));\n\n let mut threads = Vec::with_capacity(N);\n (0..N).for_each(|_| {\n     let data_mutex_clone = Arc::clone(&data_mutex);\n     let res_mutex_clone = Arc::clone(&res_mutex);\n\n     threads.push(thread::spawn(move || {\n         // Here we use a block to limit the lifetime of the lock guard.\n         let result = {\n             let mut data = data_mutex_clone.lock().unwrap();\n             // This is the result of some important and long-ish work.\n             let result = data.iter().fold(0, |acc, x| acc + x * 2);\n             data.push(result);\n             result\n             // The mutex guard gets dropped here, together with any other values\n             // created in the critical section.\n         };\n         // The guard created here is a temporary dropped at the end of the statement, i.e.\n         // the lock would not remain being held even if the thread did some additional work.\n         *res_mutex_clone.lock().unwrap() += result;\n     }));\n });\n\n let mut data = data_mutex.lock().unwrap();\n // This is the result of some important and long-ish work.\n let result = data.iter().fold(0, |acc, x| acc + x * 2);\n data.push(result);\n // We drop the `data` explicitly because it's not necessary anymore and the\n // thread still has work to do. This allows other threads to start working on\n // the data immediately, without waiting for the rest of the unrelated work\n // to be done here.\n //\n // It's even more important here than in the threads because we `.join` the\n // threads after that. If we had not dropped the mutex guard, a thread could\n // be waiting forever for it, causing a deadlock.\n // As in the threads, a block could have been used instead of calling the\n // `drop` function.\n drop(data);\n // Here the mutex guard is not assigned to a variable and so, even if the\n // scope does not end after this line, the mutex is still released: there is\n // no deadlock.\n *res_mutex.lock().unwrap() += result;\n\n threads.into_iter().for_each(|thread| {\n     thread\n         .join()\n         .expect(\"The thread creating or execution failed !\")\n });\n\n assert_eq!(*res_mutex.lock().unwrap(), 800);\n ```\n\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "poison",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "data",
      "doc": ""
    }
  }
}