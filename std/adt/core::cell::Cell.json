{
  "name": "core::cell::Cell",
  "constructors": [
    "sync::mpmc::context::Context::with::CONTEXT::__rust_std_internal_init_fn",
    "hash::random::RandomState::new::KEYS::__rust_std_internal_init_fn"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "sync::mpmc::utils::Backoff::spin_light",
      "sync::mpmc::utils::Backoff::spin_heavy",
      "thread::current::id::get",
      "thread::current::id::set",
      "sys::sync::once::futex::OnceState::poison",
      "sys::sync::once::futex::Once::call",
      "sys::thread_local::native::eager::Storage::<T>::get",
      "sys::thread_local::native::eager::Storage::<T>::initialize",
      "sys::thread_local::native::lazy::Storage::<T, D>::get_or_init",
      "sys::thread_local::native::lazy::Storage::<T, D>::get_or_init_slow",
      "sys::thread_local::native::LocalPointer::get",
      "sys::thread_local::native::LocalPointer::set"
    ],
    "write": [],
    "other": [
      "thread::local::LocalKey::<core::cell::Cell<T>>::set",
      "sync::mpmc::utils::Backoff::new",
      "sys::sync::once::futex::Once::call",
      "sys::thread_local::native::eager::Storage::<T>::new",
      "sys::thread_local::native::lazy::Storage::<T, D>::new",
      "sys::thread_local::native::LocalPointer::__new",
      "sync::mpmc::context::Context::with::CONTEXT::__rust_std_internal_init_fn",
      "hash::random::RandomState::new::KEYS::__rust_std_internal_init_fn"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/cell.rs:313:1: 313:27",
  "src": "pub struct Cell<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A mutable memory location.\n\n # Memory layout\n\n `Cell<T>` has the same [memory layout and caveats as\n `UnsafeCell<T>`](UnsafeCell#memory-layout). In particular, this means that\n `Cell<T>` has the same in-memory representation as its inner type `T`.\n\n # Examples\n\n In this example, you can see that `Cell<T>` enables mutation inside an\n immutable struct. In other words, it enables \"interior mutability\".\n\n ```\n use std::cell::Cell;\n\n struct SomeStruct {\n     regular_field: u8,\n     special_field: Cell<u8>,\n }\n\n let my_struct = SomeStruct {\n     regular_field: 0,\n     special_field: Cell::new(1),\n };\n\n let new_value = 100;\n\n // ERROR: `my_struct` is immutable\n // my_struct.regular_field = new_value;\n\n // WORKS: although `my_struct` is immutable, `special_field` is a `Cell`,\n // which can always be mutated\n my_struct.special_field.set(new_value);\n assert_eq!(my_struct.special_field.get(), new_value);\n ```\n\n See the [module-level documentation](self) for more.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}