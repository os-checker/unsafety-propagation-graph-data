{
  "name": "process::Child",
  "constructors": [
    "<process::Child as sys_common::FromInner<(sys::process::unix::unix::Process, process::StdioPipes)>>::from_inner",
    "process::Command::spawn",
    "sys::process::unix::unix::linux_child_ext::<impl os::linux::process::ChildExt for process::Child>::into_pidfd"
  ],
  "access_self_as_arg": {
    "read": [
      "<process::Child as os::unix::process::ChildExt>::send_signal",
      "<process::Child as sys_common::AsInner<sys::process::unix::unix::Process>>::as_inner",
      "<process::Child as core::fmt::Debug>::fmt",
      "process::Child::id",
      "sys::process::unix::unix::linux_child_ext::<impl os::linux::process::ChildExt for process::Child>::pidfd"
    ],
    "write": [
      "process::Child::kill",
      "process::Child::wait",
      "process::Child::try_wait",
      "process::Child::wait_with_output"
    ],
    "other": [
      "<process::Child as sys_common::IntoInner<sys::process::unix::unix::Process>>::into_inner",
      "process::Child::wait_with_output",
      "sys::process::unix::unix::linux_child_ext::<impl os::linux::process::ChildExt for process::Child>::into_pidfd",
      "<process::Child as sys_common::IntoInner<sys::process::unix::unix::Process>>::into_inner",
      "<process::Child as sys_common::IntoInner<sys::process::unix::unix::Process>>::into_inner",
      "process::Child::wait_with_output",
      "<process::Child as sys_common::IntoInner<sys::process::unix::unix::Process>>::into_inner",
      "process::Child::wait_with_output",
      "<process::Child as sys_common::IntoInner<sys::process::unix::unix::Process>>::into_inner",
      "process::Child::wait_with_output",
      "sys::process::unix::unix::linux_child_ext::<impl os::linux::process::ChildExt for process::Child>::into_pidfd"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "<process::Child as sys_common::FromInner<(sys::process::unix::unix::Process, process::StdioPipes)>>::from_inner"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "<process::Child as os::unix::process::ChildExt>::send_signal",
        "<process::Child as sys_common::AsInner<sys::process::unix::unix::Process>>::as_inner",
        "process::Child::kill",
        "process::Child::id",
        "process::Child::wait",
        "process::Child::try_wait",
        "sys::process::unix::unix::linux_child_ext::<impl os::linux::process::ChildExt for process::Child>::pidfd"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "<process::Child as core::fmt::Debug>::fmt",
        "process::Child::wait"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "<process::Child as core::fmt::Debug>::fmt"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "<process::Child as core::fmt::Debug>::fmt"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/process.rs:220:1: 220:17",
  "src": "pub struct Child",
  "kind": "Struct",
  "doc_adt": " Representation of a running or exited child process.\n\n This structure is used to represent and manage child processes. A child\n process is created via the [`Command`] struct, which configures the\n spawning process and can itself be constructed using a builder-style\n interface.\n\n There is no implementation of [`Drop`] for child processes,\n so if you do not ensure the `Child` has exited then it will continue to\n run, even after the `Child` handle to the child process has gone out of\n scope.\n\n Calling [`wait`] (or other functions that wrap around it) will make\n the parent process wait until the child has actually exited before\n continuing.\n\n # Warning\n\n On some systems, calling [`wait`] or similar is necessary for the OS to\n release resources. A process that terminated but has not been waited on is\n still around as a \"zombie\". Leaving too many zombies around may exhaust\n global resources (for example process IDs).\n\n The standard library does *not* automatically wait on child processes (not\n even if the `Child` is dropped), it is up to the application developer to do\n so. As a consequence, dropping `Child` handles without waiting on them first\n is not recommended in long-running applications.\n\n # Examples\n\n ```should_panic\n use std::process::Command;\n\n let mut child = Command::new(\"/bin/cat\")\n     .arg(\"file.txt\")\n     .spawn()\n     .expect(\"failed to execute child\");\n\n let ecode = child.wait().expect(\"failed to wait on child\");\n\n assert!(ecode.success());\n ```\n\n [`wait`]: Child::wait\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "handle",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "stdin",
      "doc": " The handle for writing to the child's standard input (stdin), if it\n has been captured. You might find it helpful to do\n\n ```ignore (incomplete)\n let stdin = child.stdin.take().expect(\"handle present\");\n ```\n\n to avoid partially moving the `child` and thus blocking yourself from calling\n functions on `child` while using `stdin`.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "stdout",
      "doc": " The handle for reading from the child's standard output (stdout), if it\n has been captured. You might find it helpful to do\n\n ```ignore (incomplete)\n let stdout = child.stdout.take().expect(\"handle present\");\n ```\n\n to avoid partially moving the `child` and thus blocking yourself from calling\n functions on `child` while using `stdout`.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(3))": {
      "name": "stderr",
      "doc": " The handle for reading from the child's standard error (stderr), if it\n has been captured. You might find it helpful to do\n\n ```ignore (incomplete)\n let stderr = child.stderr.take().expect(\"handle present\");\n ```\n\n to avoid partially moving the `child` and thus blocking yourself from calling\n functions on `child` while using `stderr`.\n"
    }
  }
}