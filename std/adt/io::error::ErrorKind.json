{
  "name": "io::error::ErrorKind",
  "constructors": [
    "io::error::repr_bitpacked::kind_from_prim",
    "io::error::Error::kind",
    "<io::error::ErrorKind as core::clone::Clone>::clone",
    "sys::pal::unix::decode_error_kind"
  ],
  "access_self_as_arg": {
    "read": [
      "io::error::repr_bitpacked::Repr::new_simple",
      "io::error::ErrorKind::as_str",
      "<io::error::ErrorKind as core::fmt::Display>::fmt",
      "<io::error::ErrorKind as core::clone::Clone>::clone",
      "<io::error::ErrorKind as core::fmt::Debug>::fmt",
      "<io::error::ErrorKind as core::cmp::Eq>::assert_receiver_is_total_eq",
      "<io::error::ErrorKind as core::hash::Hash>::hash",
      "<io::error::ErrorKind as core::cmp::Ord>::cmp",
      "<io::error::ErrorKind as core::cmp::PartialEq>::eq",
      "<io::error::ErrorKind as core::cmp::PartialOrd>::partial_cmp"
    ],
    "write": [
      "io::error::ErrorKind::as_str",
      "<io::error::ErrorKind as core::clone::Clone>::clone",
      "<io::error::ErrorKind as core::fmt::Debug>::fmt",
      "<io::error::ErrorKind as core::hash::Hash>::hash",
      "<io::error::ErrorKind as core::cmp::Ord>::cmp",
      "<io::error::ErrorKind as core::cmp::PartialEq>::eq",
      "<io::error::ErrorKind as core::cmp::PartialOrd>::partial_cmp"
    ],
    "other": [
      "io::error::repr_bitpacked::Repr::new_simple",
      "<io::error::Error as core::convert::From<io::error::ErrorKind>>::from",
      "io::error::Error::new",
      "io::error::Error::_new",
      "<io::error::ErrorKind as core::clone::Clone>::clone",
      "io::error::repr_bitpacked::Repr::new_simple"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "fs::DirBuilder::create_dir_all",
      "io::error::Error::is_interrupted",
      "io::error::<impl core::fmt::Debug for io::error::repr_bitpacked::Repr>::fmt",
      "<io::error::Error as core::fmt::Display>::fmt",
      "io::skip_until",
      "sys::fs::common::remove_dir_all_recursive",
      "sys::fs::common::exists",
      "sys_common::ignore_notfound",
      "<io::error::SimpleMessage as core::fmt::Debug>::fmt",
      "<io::error::Custom as core::fmt::Debug>::fmt",
      "sys::pal::unix::os::current_exe",
      "sys::fs::unix::File::try_lock",
      "sys::fs::unix::File::try_lock_shared"
    ],
    "write": [],
    "other": [
      "fs::<impl core::convert::From<fs::TryLockError> for io::error::Error>::from",
      "fs::DirBuilder::create_dir_all",
      "io::error::repr_bitpacked::decode_repr",
      "io::error::repr_bitpacked::kind_from_prim",
      "<io::error::Error as core::convert::From<alloc_crate::collections::TryReserveError>>::from",
      "io::error::Error::other",
      "io::error::Error::kind",
      "io::error::Error::is_interrupted",
      "io::error::<impl core::fmt::Debug for io::error::repr_bitpacked::Repr>::fmt",
      "<io::error::Error as core::fmt::Display>::fmt",
      "<io::util::Repeat as io::Read>::read_to_end",
      "<io::util::Repeat as io::Read>::read_to_string",
      "io::skip_until",
      "<io::Take<T> as io::Seek>::seek",
      "<io::Take<T> as io::Seek>::seek_relative",
      "sys::fs::common::remove_dir_all_recursive",
      "sys::fs::common::exists",
      "sys_common::ignore_notfound",
      "sys::pal::unix::os::current_exe",
      "sys::pal::unix::decode_error_kind",
      "sys::fs::unix::OpenOptions::get_access_mode",
      "sys::fs::unix::OpenOptions::get_creation_mode",
      "sys::fs::unix::File::try_lock",
      "sys::fs::unix::File::try_lock_shared",
      "sys::net::connection::socket::unix::cvt_gai",
      "sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn"
    ]
  },
  "access_field": [],
  "span": "$library/std/src/io/error.rs:228:1: 228:19",
  "src": "pub enum ErrorKind",
  "kind": "Enum",
  "doc_adt": " A list specifying general categories of I/O error.\n\n This list is intended to grow over time and it is not recommended to\n exhaustively match against it.\n\n It is used with the [`io::Error`] type.\n\n [`io::Error`]: Error\n\n # Handling errors and matching on `ErrorKind`\n\n In application code, use `match` for the `ErrorKind` values you are\n expecting; use `_` to match \"all other errors\".\n\n In comprehensive and thorough tests that want to verify that a test doesn't\n return any known incorrect error kind, you may want to cut-and-paste the\n current full list of errors from here into your test code, and then match\n `_` as the correct case. This seems counterintuitive, but it will make your\n tests more robust. In particular, if you want to verify that your code does\n produce an unrecognized error kind, the robust solution is to check for all\n the recognized error kinds and fail in those cases.\n",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "NotFound",
      "doc": " An entity was not found, often a file.\n"
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "PermissionDenied",
      "doc": " The operation lacked the necessary privileges to complete.\n"
    },
    "VariantIdx(Some(2))-FieldIdx(None)": {
      "name": "ConnectionRefused",
      "doc": " The connection was refused by the remote server.\n"
    },
    "VariantIdx(Some(3))-FieldIdx(None)": {
      "name": "ConnectionReset",
      "doc": " The connection was reset by the remote server.\n"
    },
    "VariantIdx(Some(4))-FieldIdx(None)": {
      "name": "HostUnreachable",
      "doc": " The remote host is not reachable.\n"
    },
    "VariantIdx(Some(5))-FieldIdx(None)": {
      "name": "NetworkUnreachable",
      "doc": " The network containing the remote host is not reachable.\n"
    },
    "VariantIdx(Some(6))-FieldIdx(None)": {
      "name": "ConnectionAborted",
      "doc": " The connection was aborted (terminated) by the remote server.\n"
    },
    "VariantIdx(Some(7))-FieldIdx(None)": {
      "name": "NotConnected",
      "doc": " The network operation failed because it was not connected yet.\n"
    },
    "VariantIdx(Some(8))-FieldIdx(None)": {
      "name": "AddrInUse",
      "doc": " A socket address could not be bound because the address is already in\n use elsewhere.\n"
    },
    "VariantIdx(Some(9))-FieldIdx(None)": {
      "name": "AddrNotAvailable",
      "doc": " A nonexistent interface was requested or the requested address was not\n local.\n"
    },
    "VariantIdx(Some(10))-FieldIdx(None)": {
      "name": "NetworkDown",
      "doc": " The system's networking is down.\n"
    },
    "VariantIdx(Some(11))-FieldIdx(None)": {
      "name": "BrokenPipe",
      "doc": " The operation failed because a pipe was closed.\n"
    },
    "VariantIdx(Some(12))-FieldIdx(None)": {
      "name": "AlreadyExists",
      "doc": " An entity already exists, often a file.\n"
    },
    "VariantIdx(Some(13))-FieldIdx(None)": {
      "name": "WouldBlock",
      "doc": " The operation needs to block to complete, but the blocking operation was\n requested to not occur.\n"
    },
    "VariantIdx(Some(14))-FieldIdx(None)": {
      "name": "NotADirectory",
      "doc": " A filesystem object is, unexpectedly, not a directory.\n\n For example, a filesystem path was specified where one of the intermediate directory\n components was, in fact, a plain file.\n"
    },
    "VariantIdx(Some(15))-FieldIdx(None)": {
      "name": "IsADirectory",
      "doc": " The filesystem object is, unexpectedly, a directory.\n\n A directory was specified when a non-directory was expected.\n"
    },
    "VariantIdx(Some(16))-FieldIdx(None)": {
      "name": "DirectoryNotEmpty",
      "doc": " A non-empty directory was specified where an empty directory was expected.\n"
    },
    "VariantIdx(Some(17))-FieldIdx(None)": {
      "name": "ReadOnlyFilesystem",
      "doc": " The filesystem or storage medium is read-only, but a write operation was attempted.\n"
    },
    "VariantIdx(Some(18))-FieldIdx(None)": {
      "name": "FilesystemLoop",
      "doc": " Loop in the filesystem or IO subsystem; often, too many levels of symbolic links.\n\n There was a loop (or excessively long chain) resolving a filesystem object\n or file IO object.\n\n On Unix this is usually the result of a symbolic link loop; or, of exceeding the\n system-specific limit on the depth of symlink traversal.\n"
    },
    "VariantIdx(Some(19))-FieldIdx(None)": {
      "name": "StaleNetworkFileHandle",
      "doc": " Stale network file handle.\n\n With some network filesystems, notably NFS, an open file (or directory) can be invalidated\n by problems with the network or server.\n"
    },
    "VariantIdx(Some(20))-FieldIdx(None)": {
      "name": "InvalidInput",
      "doc": " A parameter was incorrect.\n"
    },
    "VariantIdx(Some(21))-FieldIdx(None)": {
      "name": "InvalidData",
      "doc": " Data not valid for the operation were encountered.\n\n Unlike [`InvalidInput`], this typically means that the operation\n parameters were valid, however the error was caused by malformed\n input data.\n\n For example, a function that reads a file into a string will error with\n `InvalidData` if the file's contents are not valid UTF-8.\n\n [`InvalidInput`]: ErrorKind::InvalidInput\n"
    },
    "VariantIdx(Some(22))-FieldIdx(None)": {
      "name": "TimedOut",
      "doc": " The I/O operation's timeout expired, causing it to be canceled.\n"
    },
    "VariantIdx(Some(23))-FieldIdx(None)": {
      "name": "WriteZero",
      "doc": " An error returned when an operation could not be completed because a\n call to [`write`] returned [`Ok(0)`].\n\n This typically means that an operation could only succeed if it wrote a\n particular number of bytes but only a smaller number of bytes could be\n written.\n\n [`write`]: crate::io::Write::write\n [`Ok(0)`]: Ok\n"
    },
    "VariantIdx(Some(24))-FieldIdx(None)": {
      "name": "StorageFull",
      "doc": " The underlying storage (typically, a filesystem) is full.\n\n This does not include out of quota errors.\n"
    },
    "VariantIdx(Some(25))-FieldIdx(None)": {
      "name": "NotSeekable",
      "doc": " Seek on unseekable file.\n\n Seeking was attempted on an open file handle which is not suitable for seeking - for\n example, on Unix, a named pipe opened with `File::open`.\n"
    },
    "VariantIdx(Some(26))-FieldIdx(None)": {
      "name": "QuotaExceeded",
      "doc": " Filesystem quota or some other kind of quota was exceeded.\n"
    },
    "VariantIdx(Some(27))-FieldIdx(None)": {
      "name": "FileTooLarge",
      "doc": " File larger than allowed or supported.\n\n This might arise from a hard limit of the underlying filesystem or file access API, or from\n an administratively imposed resource limitation.  Simple disk full, and out of quota, have\n their own errors.\n"
    },
    "VariantIdx(Some(28))-FieldIdx(None)": {
      "name": "ResourceBusy",
      "doc": " Resource is busy.\n"
    },
    "VariantIdx(Some(29))-FieldIdx(None)": {
      "name": "ExecutableFileBusy",
      "doc": " Executable file is busy.\n\n An attempt was made to write to a file which is also in use as a running program.  (Not all\n operating systems detect this situation.)\n"
    },
    "VariantIdx(Some(30))-FieldIdx(None)": {
      "name": "Deadlock",
      "doc": " Deadlock (avoided).\n\n A file locking operation would result in deadlock.  This situation is typically detected, if\n at all, on a best-effort basis.\n"
    },
    "VariantIdx(Some(31))-FieldIdx(None)": {
      "name": "CrossesDevices",
      "doc": " Cross-device or cross-filesystem (hard) link or rename.\n"
    },
    "VariantIdx(Some(32))-FieldIdx(None)": {
      "name": "TooManyLinks",
      "doc": " Too many (hard) links to the same filesystem object.\n\n The filesystem does not support making so many hardlinks to the same file.\n"
    },
    "VariantIdx(Some(33))-FieldIdx(None)": {
      "name": "InvalidFilename",
      "doc": " A filename was invalid.\n\n This error can also occur if a length limit for a name was exceeded.\n"
    },
    "VariantIdx(Some(34))-FieldIdx(None)": {
      "name": "ArgumentListTooLong",
      "doc": " Program argument list too long.\n\n When trying to run an external program, a system or process limit on the size of the\n arguments would have been exceeded.\n"
    },
    "VariantIdx(Some(35))-FieldIdx(None)": {
      "name": "Interrupted",
      "doc": " This operation was interrupted.\n\n Interrupted operations can typically be retried.\n"
    },
    "VariantIdx(Some(36))-FieldIdx(None)": {
      "name": "Unsupported",
      "doc": " This operation is unsupported on this platform.\n\n This means that the operation can never succeed.\n"
    },
    "VariantIdx(Some(37))-FieldIdx(None)": {
      "name": "UnexpectedEof",
      "doc": " An error returned when an operation could not be completed because an\n \"end of file\" was reached prematurely.\n\n This typically means that an operation could only succeed if it read a\n particular number of bytes but only a smaller number of bytes could be\n read.\n"
    },
    "VariantIdx(Some(38))-FieldIdx(None)": {
      "name": "OutOfMemory",
      "doc": " An operation could not be completed, because it failed\n to allocate enough memory.\n"
    },
    "VariantIdx(Some(39))-FieldIdx(None)": {
      "name": "InProgress",
      "doc": " The operation was partially successful and needs to be checked\n later on due to not blocking.\n"
    },
    "VariantIdx(Some(40))-FieldIdx(None)": {
      "name": "Other",
      "doc": " A custom error that does not fall under any other I/O error kind.\n\n This can be used to construct your own [`Error`]s that do not match any\n [`ErrorKind`].\n\n This [`ErrorKind`] is not used by the standard library.\n\n Errors from the standard library that do not fall under any of the I/O\n error kinds cannot be `match`ed on, and will only match a wildcard (`_`) pattern.\n New [`ErrorKind`]s might be added in the future for some of those.\n"
    },
    "VariantIdx(Some(41))-FieldIdx(None)": {
      "name": "Uncategorized",
      "doc": " Any I/O error from the standard library that's not part of this list.\n\n Errors that are `Uncategorized` now may move to a different or a new\n [`ErrorKind`] variant in the future. It is not recommended to match\n an error against `Uncategorized`; use a wildcard match (`_`) instead.\n"
    }
  }
}