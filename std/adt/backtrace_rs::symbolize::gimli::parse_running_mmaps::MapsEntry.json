{
  "name": "backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry",
  "constructors": [
    "backtrace_rs::symbolize::gimli::parse_running_mmaps::parse_maps",
    "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::FromStr>::from_str"
  ],
  "access_self_as_arg": {
    "read": [
      "backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry::pathname",
      "backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry::ip_matches",
      "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::PartialEq>::eq",
      "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::Eq>::assert_receiver_is_total_eq",
      "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::fmt::Debug>::fmt"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "backtrace_rs::symbolize::gimli::parse_running_mmaps::parse_maps",
      "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::FromStr>::from_str"
    ]
  },
  "access_field": [
    {
      "read": [
        "backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry::ip_matches",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::PartialEq>::eq",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    },
    {
      "read": [
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::PartialEq>::eq",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    },
    {
      "read": [
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::PartialEq>::eq",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    },
    {
      "read": [
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::PartialEq>::eq",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    },
    {
      "read": [
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::PartialEq>::eq",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    },
    {
      "read": [
        "backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry::pathname",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::cmp::PartialEq>::eq",
        "<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:13:1: 13:28",
  "src": "pub(super) struct MapsEntry",
  "kind": "Struct",
  "doc_adt": "",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "address",
      "doc": " start (inclusive) and limit (exclusive) of address range.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "perms",
      "doc": " The perms field are the permissions for the entry\n\n r = read\n w = write\n x = execute\n s = shared\n p = private (copy on write)\n"
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "offset",
      "doc": " Offset into the file (or \"whatever\").\n"
    },
    "VariantIdx(None)-FieldIdx(Some(3))": {
      "name": "dev",
      "doc": " device (major, minor)\n"
    },
    "VariantIdx(None)-FieldIdx(Some(4))": {
      "name": "inode",
      "doc": " inode on the device. 0 indicates that no inode is associated with the memory region (e.g. uninitalized data aka BSS).\n"
    },
    "VariantIdx(None)-FieldIdx(Some(5))": {
      "name": "pathname",
      "doc": " Usually the file backing the mapping.\n\n Note: The man page for proc includes a note about \"coordination\" by\n using readelf to see the Offset field in ELF program headers. pnkfelix\n is not yet sure if that is intended to be a comment on pathname, or what\n form/purpose such coordination is meant to have.\n\n There are also some pseudo-paths:\n \"[stack]\": The initial process's (aka main thread's) stack.\n \"[stack:<tid>]\": a specific thread's stack. (This was only present for a limited range of Linux verisons; it was determined to be too expensive to provide.)\n \"[vdso]\": Virtual dynamically linked shared object\n \"[heap]\": The process's heap\n\n The pathname can be blank, which means it is an anonymous mapping\n obtained via mmap.\n\n Newlines in pathname are replaced with an octal escape sequence.\n\n The pathname may have \"(deleted)\" appended onto it if the file-backed\n path has been deleted.\n\n Note that modifications like the latter two indicated above imply that\n in general the pathname may be ambiguous. (I.e. you cannot tell if the\n denoted filename actually ended with the text \"(deleted)\", or if that\n was added by the maps rendering.\n"
    }
  }
}