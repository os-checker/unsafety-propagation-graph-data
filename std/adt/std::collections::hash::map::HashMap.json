{
  "name": "std::collections::hash::map::HashMap",
  "constructors": [
    "std::collections::hash::map::HashMap::<K, V>::new",
    "std::collections::hash::map::HashMap::<K, V>::with_capacity",
    "std::collections::hash::map::HashMap::<K, V, S>::with_hasher",
    "std::collections::hash::map::HashMap::<K, V, S>::with_capacity_and_hasher",
    "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone",
    "std::<collections::hash::map::HashMap<K, V, S> as core::default::Default>::default",
    "std::<collections::hash::map::HashMap<K, V> as core::convert::From<[(K, V); N]>>::from",
    "std::<collections::hash::map::HashMap<K, V, S> as core::iter::FromIterator<(K, V)>>::from_iter",
    "std::collections::hash::map::assert_covariance::map_key",
    "std::collections::hash::map::assert_covariance::map_val"
  ],
  "access_self_as_arg": {
    "read": [
      "std::collections::hash::map::HashMap::<K, V, S>::capacity",
      "std::collections::hash::map::HashMap::<K, V, S>::keys",
      "std::collections::hash::map::HashMap::<K, V, S>::values",
      "std::collections::hash::map::HashMap::<K, V, S>::iter",
      "std::collections::hash::map::HashMap::<K, V, S>::len",
      "std::collections::hash::map::HashMap::<K, V, S>::is_empty",
      "std::collections::hash::map::HashMap::<K, V, S>::hasher",
      "std::collections::hash::map::HashMap::<K, V, S>::get",
      "std::collections::hash::map::HashMap::<K, V, S>::get_key_value",
      "std::collections::hash::map::HashMap::<K, V, S>::contains_key",
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone",
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone_from",
      "std::<collections::hash::map::HashMap<K, V, S> as core::cmp::PartialEq>::eq",
      "std::<collections::hash::map::HashMap<K, V, S> as core::fmt::Debug>::fmt",
      "std::<collections::hash::map::HashMap<K, V, S> as core::ops::Index<&Q>>::index",
      "std::<&'a collections::hash::map::HashMap<K, V, S> as core::iter::IntoIterator>::into_iter"
    ],
    "write": [
      "std::collections::hash::map::HashMap::<K, V, S>::values_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::iter_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::drain",
      "std::collections::hash::map::HashMap::<K, V, S>::extract_if",
      "std::collections::hash::map::HashMap::<K, V, S>::retain",
      "std::collections::hash::map::HashMap::<K, V, S>::clear",
      "std::collections::hash::map::HashMap::<K, V, S>::reserve",
      "std::collections::hash::map::HashMap::<K, V, S>::try_reserve",
      "std::collections::hash::map::HashMap::<K, V, S>::shrink_to_fit",
      "std::collections::hash::map::HashMap::<K, V, S>::shrink_to",
      "std::collections::hash::map::HashMap::<K, V, S>::entry",
      "std::collections::hash::map::HashMap::<K, V, S>::get_disjoint_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::get_disjoint_unchecked_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::get_mut",
      "std::collections::hash::map::HashMap::<K, V, S>::insert",
      "std::collections::hash::map::HashMap::<K, V, S>::try_insert",
      "std::collections::hash::map::HashMap::<K, V, S>::remove",
      "std::collections::hash::map::HashMap::<K, V, S>::remove_entry",
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone_from",
      "std::<&'a mut collections::hash::map::HashMap<K, V, S> as core::iter::IntoIterator>::into_iter",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend_one",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend_reserve",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend_one",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend_reserve"
    ],
    "other": [
      "std::collections::hash::map::HashMap::<K, V, S>::into_keys",
      "std::collections::hash::map::HashMap::<K, V, S>::into_values",
      "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::IntoIterator>::into_iter",
      "std::collections::hash::map::assert_covariance::map_key",
      "std::collections::hash::map::assert_covariance::map_val",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::IntoIterator>::into_iter"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::FromIterator<(K, V)>>::from_iter"
    ],
    "other": [
      "std::collections::hash::map::HashMap::<K, V>::new",
      "std::collections::hash::map::HashMap::<K, V>::with_capacity",
      "std::collections::hash::map::HashMap::<K, V, S>::with_hasher",
      "std::collections::hash::map::HashMap::<K, V, S>::with_capacity_and_hasher",
      "std::<collections::hash::map::HashMap<K, V, S> as core::default::Default>::default",
      "std::<collections::hash::map::HashMap<K, V> as core::convert::From<[(K, V); N]>>::from",
      "std::<collections::hash::map::HashMap<K, V, S> as core::iter::FromIterator<(K, V)>>::from_iter"
    ]
  },
  "access_field": [
    {
      "read": [
        "std::collections::hash::map::HashMap::<K, V, S>::capacity",
        "std::collections::hash::map::HashMap::<K, V, S>::iter",
        "std::collections::hash::map::HashMap::<K, V, S>::len",
        "std::collections::hash::map::HashMap::<K, V, S>::is_empty",
        "std::collections::hash::map::HashMap::<K, V, S>::hasher",
        "std::collections::hash::map::HashMap::<K, V, S>::get",
        "std::collections::hash::map::HashMap::<K, V, S>::get_key_value",
        "std::collections::hash::map::HashMap::<K, V, S>::contains_key",
        "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone",
        "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone_from"
      ],
      "write": [
        "std::collections::hash::map::HashMap::<K, V, S>::iter_mut",
        "std::collections::hash::map::HashMap::<K, V, S>::drain",
        "std::collections::hash::map::HashMap::<K, V, S>::extract_if",
        "std::collections::hash::map::HashMap::<K, V, S>::retain",
        "std::collections::hash::map::HashMap::<K, V, S>::clear",
        "std::collections::hash::map::HashMap::<K, V, S>::reserve",
        "std::collections::hash::map::HashMap::<K, V, S>::try_reserve",
        "std::collections::hash::map::HashMap::<K, V, S>::shrink_to_fit",
        "std::collections::hash::map::HashMap::<K, V, S>::shrink_to",
        "std::collections::hash::map::HashMap::<K, V, S>::entry",
        "std::collections::hash::map::HashMap::<K, V, S>::get_disjoint_mut",
        "std::collections::hash::map::HashMap::<K, V, S>::get_disjoint_unchecked_mut",
        "std::collections::hash::map::HashMap::<K, V, S>::get_mut",
        "std::collections::hash::map::HashMap::<K, V, S>::insert",
        "std::collections::hash::map::HashMap::<K, V, S>::remove",
        "std::collections::hash::map::HashMap::<K, V, S>::remove_entry",
        "std::<collections::hash::map::HashMap<K, V, S> as core::clone::Clone>::clone_from",
        "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend",
        "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend_one",
        "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(K, V)>>::extend_reserve",
        "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend",
        "std::<collections::hash::map::HashMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend_one"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/collections/hash/map.rs:246:1: 246:42",
  "src": "pub struct HashMap<K, V, S = RandomState>",
  "kind": "Struct",
  "doc_adt": " A [hash map] implemented with quadratic probing and SIMD lookup.\n\n By default, `HashMap` uses a hashing algorithm selected to provide\n resistance against HashDoS attacks. The algorithm is randomly seeded, and a\n reasonable best-effort is made to generate this seed from a high quality,\n secure source of randomness provided by the host without blocking the\n program. Because of this, the randomness of the seed depends on the output\n quality of the system's random number coroutine when the seed is created.\n In particular, seeds generated when the system's entropy pool is abnormally\n low such as during system boot may be of a lower quality.\n\n The default hashing algorithm is currently SipHash 1-3, though this is\n subject to change at any point in the future. While its performance is very\n competitive for medium sized keys, other hashing algorithms will outperform\n it for small keys such as integers as well as large keys such as long\n strings, though those algorithms will typically *not* protect against\n attacks such as HashDoS.\n\n The hashing algorithm can be replaced on a per-`HashMap` basis using the\n [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods.\n There are many alternative [hashing algorithms available on crates.io].\n\n It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n If you implement these yourself, it is important that the following\n property holds:\n\n ```text\n k1 == k2 -> hash(k1) == hash(k2)\n ```\n\n In other words, if two keys are equal, their hashes must be equal.\n Violating this property is a logic error.\n\n It is also a logic error for a key to be modified in such a way that the key's\n hash, as determined by the [`Hash`] trait, or its equality, as determined by\n the [`Eq`] trait, changes while it is in the map. This is normally only\n possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n\n The behavior resulting from either logic error is not specified, but will\n be encapsulated to the `HashMap` that observed the logic error and not\n result in undefined behavior. This could include panics, incorrect results,\n aborts, memory leaks, and non-termination.\n\n The hash table implementation is a Rust port of Google's [SwissTable].\n The original C++ version of SwissTable can be found [here], and this\n [CppCon talk] gives an overview of how the algorithm works.\n\n [hash map]: crate::collections#use-a-hashmap-when\n [hashing algorithms available on crates.io]: https://crates.io/keywords/hasher\n [SwissTable]: https://abseil.io/blog/20180927-swisstables\n [here]: https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h\n [CppCon talk]: https://www.youtube.com/watch?v=ncHmEUmJZf4\n\n # Examples\n\n ```\n use std::collections::HashMap;\n\n // Type inference lets us omit an explicit type signature (which\n // would be `HashMap<String, String>` in this example).\n let mut book_reviews = HashMap::new();\n\n // Review some books.\n book_reviews.insert(\n     \"Adventures of Huckleberry Finn\".to_string(),\n     \"My favorite book.\".to_string(),\n );\n book_reviews.insert(\n     \"Grimms' Fairy Tales\".to_string(),\n     \"Masterpiece.\".to_string(),\n );\n book_reviews.insert(\n     \"Pride and Prejudice\".to_string(),\n     \"Very enjoyable.\".to_string(),\n );\n book_reviews.insert(\n     \"The Adventures of Sherlock Holmes\".to_string(),\n     \"Eye lyked it alot.\".to_string(),\n );\n\n // Check for a specific one.\n // When collections store owned values (String), they can still be\n // queried using references (&str).\n if !book_reviews.contains_key(\"Les Misérables\") {\n     println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n              book_reviews.len());\n }\n\n // oops, this review has a lot of spelling mistakes, let's delete it.\n book_reviews.remove(\"The Adventures of Sherlock Holmes\");\n\n // Look up the values associated with some keys.\n let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n for &book in &to_find {\n     match book_reviews.get(book) {\n         Some(review) => println!(\"{book}: {review}\"),\n         None => println!(\"{book} is unreviewed.\")\n     }\n }\n\n // Look up the value for a key (will panic if the key is not found).\n println!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]);\n\n // Iterate over everything.\n for (book, review) in &book_reviews {\n     println!(\"{book}: \\\"{review}\\\"\");\n }\n ```\n\n A `HashMap` with a known list of items can be initialized from an array:\n\n ```\n use std::collections::HashMap;\n\n let solar_distance = HashMap::from([\n     (\"Mercury\", 0.4),\n     (\"Venus\", 0.7),\n     (\"Earth\", 1.0),\n     (\"Mars\", 1.5),\n ]);\n ```\n\n ## `Entry` API\n\n `HashMap` implements an [`Entry` API](#method.entry), which allows\n for complex methods of getting, setting, updating and removing keys and\n their values:\n\n ```\n use std::collections::HashMap;\n\n // type inference lets us omit an explicit type signature (which\n // would be `HashMap<&str, u8>` in this example).\n let mut player_stats = HashMap::new();\n\n fn random_stat_buff() -> u8 {\n     // could actually return some random value here - let's just return\n     // some fixed value for now\n     42\n }\n\n // insert a key only if it doesn't already exist\n player_stats.entry(\"health\").or_insert(100);\n\n // insert a key using a function that provides a new value only if it\n // doesn't already exist\n player_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n\n // update a key, guarding against the key possibly not being set\n let stat = player_stats.entry(\"attack\").or_insert(100);\n *stat += random_stat_buff();\n\n // modify an entry before an insert with in-place mutation\n player_stats.entry(\"mana\").and_modify(|mana| *mana += 200).or_insert(100);\n ```\n\n ## Usage with custom key types\n\n The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n We must also derive [`PartialEq`].\n\n [`RefCell`]: crate::cell::RefCell\n [`Cell`]: crate::cell::Cell\n [`default`]: Default::default\n [`with_hasher`]: Self::with_hasher\n [`with_capacity_and_hasher`]: Self::with_capacity_and_hasher\n\n ```\n use std::collections::HashMap;\n\n #[derive(Hash, Eq, PartialEq, Debug)]\n struct Viking {\n     name: String,\n     country: String,\n }\n\n impl Viking {\n     /// Creates a new Viking.\n     fn new(name: &str, country: &str) -> Viking {\n         Viking { name: name.to_string(), country: country.to_string() }\n     }\n }\n\n // Use a HashMap to store the vikings' health points.\n let vikings = HashMap::from([\n     (Viking::new(\"Einar\", \"Norway\"), 25),\n     (Viking::new(\"Olaf\", \"Denmark\"), 24),\n     (Viking::new(\"Harald\", \"Iceland\"), 12),\n ]);\n\n // Use derived implementation to print the status of the vikings.\n for (viking, health) in &vikings {\n     println!(\"{viking:?} has {health} hp\");\n }\n ```\n\n # Usage in `const` and `static`\n\n As explained above, `HashMap` is randomly seeded: each `HashMap` instance uses a different seed,\n which means that `HashMap::new` normally cannot be used in a `const` or `static` initializer.\n\n However, if you need to use a `HashMap` in a `const` or `static` initializer while retaining\n random seed generation, you can wrap the `HashMap` in [`LazyLock`].\n\n Alternatively, you can construct a `HashMap` in a `const` or `static` initializer using a different\n hasher that does not rely on a random seed. **Be aware that a `HashMap` created this way is not\n resistant to HashDoS attacks!**\n\n [`LazyLock`]: crate::sync::LazyLock\n ```rust\n use std::collections::HashMap;\n use std::hash::{BuildHasherDefault, DefaultHasher};\n use std::sync::{LazyLock, Mutex};\n\n // HashMaps with a fixed, non-random hasher\n const NONRANDOM_EMPTY_MAP: HashMap<String, Vec<i32>, BuildHasherDefault<DefaultHasher>> =\n     HashMap::with_hasher(BuildHasherDefault::new());\n static NONRANDOM_MAP: Mutex<HashMap<String, Vec<i32>, BuildHasherDefault<DefaultHasher>>> =\n     Mutex::new(HashMap::with_hasher(BuildHasherDefault::new()));\n\n // HashMaps using LazyLock to retain random seeding\n const RANDOM_EMPTY_MAP: LazyLock<HashMap<String, Vec<i32>>> =\n     LazyLock::new(HashMap::new);\n static RANDOM_MAP: LazyLock<Mutex<HashMap<String, Vec<i32>>>> =\n     LazyLock::new(|| Mutex::new(HashMap::new()));\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "base",
      "doc": ""
    }
  }
}