{
  "name": "sync::reentrant_lock::ReentrantLockGuard",
  "constructors": [
    "sync::reentrant_lock::ReentrantLock::<T>::lock",
    "sync::reentrant_lock::ReentrantLock::<T>::try_lock"
  ],
  "access_self_as_arg": {
    "read": [
      "<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::ops::Deref>::deref",
      "<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::fmt::Debug>::fmt",
      "<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::fmt::Display>::fmt"
    ],
    "write": [
      "<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::ops::Drop>::drop"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "io::stdio::cleanup",
      "<io::stdio::StdoutLock<'_> as io::Write>::write",
      "<io::stdio::StdoutLock<'_> as io::Write>::write_vectored",
      "<io::stdio::StdoutLock<'_> as io::Write>::is_write_vectored",
      "<io::stdio::StdoutLock<'_> as io::Write>::flush",
      "<io::stdio::StdoutLock<'_> as io::Write>::write_all",
      "<io::stdio::StdoutLock<'_> as io::Write>::write_all_vectored",
      "<io::stdio::StderrLock<'_> as io::Write>::write",
      "<io::stdio::StderrLock<'_> as io::Write>::write_vectored",
      "<io::stdio::StderrLock<'_> as io::Write>::is_write_vectored",
      "<io::stdio::StderrLock<'_> as io::Write>::flush",
      "<io::stdio::StderrLock<'_> as io::Write>::write_all",
      "<io::stdio::StderrLock<'_> as io::Write>::write_all_vectored",
      "<sync::reentrant_lock::ReentrantLock<T> as core::fmt::Debug>::fmt"
    ],
    "write": [],
    "other": [
      "io::stdio::cleanup",
      "io::stdio::Stdout::lock",
      "io::stdio::Stderr::lock",
      "sync::reentrant_lock::ReentrantLock::<T>::lock",
      "sync::reentrant_lock::ReentrantLock::<T>::try_lock",
      "<sync::reentrant_lock::ReentrantLock<T> as core::fmt::Debug>::fmt"
    ]
  },
  "access_field": [
    {
      "read": [
        "<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::ops::Deref>::deref"
      ],
      "write": [
        "<sync::reentrant_lock::ReentrantLockGuard<'_, T> as core::ops::Drop>::drop"
      ],
      "other": []
    }
  ],
  "span": "$library/std/src/sync/reentrant_lock.rs:210:1: 210:50",
  "src": "pub struct ReentrantLockGuard<'a, T: ?Sized + 'a>",
  "kind": "Struct",
  "doc_adt": " An RAII implementation of a \"scoped lock\" of a re-entrant lock. When this\n structure is dropped (falls out of scope), the lock will be unlocked.\n\n The data protected by the mutex can be accessed through this guard via its\n [`Deref`] implementation.\n\n This structure is created by the [`lock`](ReentrantLock::lock) method on\n [`ReentrantLock`].\n\n # Mutability\n\n Unlike [`MutexGuard`](super::MutexGuard), `ReentrantLockGuard` does not\n implement [`DerefMut`](crate::ops::DerefMut), because implementation of\n the trait would violate Rustâ€™s reference aliasing rules. Use interior\n mutability (usually [`RefCell`](crate::cell::RefCell)) in order to mutate\n the guarded data.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "lock",
      "doc": ""
    }
  }
}