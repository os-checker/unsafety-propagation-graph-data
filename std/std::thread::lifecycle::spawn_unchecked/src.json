{
  "name": "std::thread::lifecycle::spawn_unchecked",
  "span": "$library/std/src/thread/lifecycle.rs:18:1: 28:13",
  "src": "pub(super) unsafe fn spawn_unchecked<'scope, F, T>(\n    name: Option<String>,\n    stack_size: Option<usize>,\n    no_hooks: bool,\n    scope_data: Option<Arc<ScopeData>>,\n    f: F,\n) -> io::Result<JoinInner<'scope, T>>\nwhere\n    F: FnOnce() -> T,\n    F: Send,\n    T: Send,\n{\n    let stack_size = stack_size.unwrap_or_else(|| {\n        static MIN: Atomic<usize> = AtomicUsize::new(0);\n\n        match MIN.load(Ordering::Relaxed) {\n            0 => {}\n            n => return n - 1,\n        }\n\n        let amt = env::var_os(\"RUST_MIN_STACK\")\n            .and_then(|s| s.to_str().and_then(|s| s.parse().ok()))\n            .unwrap_or(imp::DEFAULT_MIN_STACK_SIZE);\n\n        // 0 is our sentinel value, so ensure that we'll never see 0 after\n        // initialization has run\n        MIN.store(amt + 1, Ordering::Relaxed);\n        amt\n    });\n\n    let id = ThreadId::new();\n    let thread = Thread::new(id, name);\n\n    let hooks = if no_hooks {\n        spawnhook::ChildSpawnHooks::default()\n    } else {\n        spawnhook::run_spawn_hooks(&thread)\n    };\n\n    let my_packet: Arc<Packet<'scope, T>> =\n        Arc::new(Packet { scope: scope_data, result: UnsafeCell::new(None), _marker: PhantomData });\n    let their_packet = my_packet.clone();\n\n    // Pass `f` in `MaybeUninit` because actually that closure might *run longer than the lifetime of `F`*.\n    // See <https://github.com/rust-lang/rust/issues/101983> for more details.\n    // To prevent leaks we use a wrapper that drops its contents.\n    #[repr(transparent)]\n    struct MaybeDangling<T>(MaybeUninit<T>);\n    impl<T> MaybeDangling<T> {\n        fn new(x: T) -> Self {\n            MaybeDangling(MaybeUninit::new(x))\n        }\n        fn into_inner(self) -> T {\n            // Make sure we don't drop.\n            let this = ManuallyDrop::new(self);\n            // SAFETY: we are always initialized.\n            unsafe { this.0.assume_init_read() }\n        }\n    }\n    impl<T> Drop for MaybeDangling<T> {\n        fn drop(&mut self) {\n            // SAFETY: we are always initialized.\n            unsafe { self.0.assume_init_drop() };\n        }\n    }\n\n    let f = MaybeDangling::new(f);\n\n    // The entrypoint of the Rust thread, after platform-specific thread\n    // initialization is done.\n    let rust_start = move || {\n        let f = f.into_inner();\n        let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n            crate::sys::backtrace::__rust_begin_short_backtrace(|| hooks.run());\n            crate::sys::backtrace::__rust_begin_short_backtrace(f)\n        }));\n        // SAFETY: `their_packet` as been built just above and moved by the\n        // closure (it is an Arc<...>) and `my_packet` will be stored in the\n        // same `JoinInner` as this closure meaning the mutation will be\n        // safe (not modify it and affect a value far away).\n        unsafe { *their_packet.result.get() = Some(try_result) };\n        // Here `their_packet` gets dropped, and if this is the last `Arc` for that packet that\n        // will call `decrement_num_running_threads` and therefore signal that this thread is\n        // done.\n        drop(their_packet);\n        // Here, the lifetime `'scope` can end. `main` keeps running for a bit\n        // after that before returning itself.\n    };\n\n    if let Some(scope_data) = &my_packet.scope {\n        scope_data.increment_num_running_threads();\n    }\n\n    // SAFETY: dynamic size and alignment of the Box remain the same. See below for why the\n    // lifetime change is justified.\n    let rust_start = unsafe {\n        Box::from_raw(Box::into_raw(Box::new(rust_start)) as *mut (dyn FnOnce() + Send + 'static))\n    };\n\n    let init = Box::new(ThreadInit { handle: thread.clone(), rust_start });\n\n    Ok(JoinInner {\n        // SAFETY:\n        //\n        // `imp::Thread::new` takes a closure with a `'static` lifetime, since it's passed\n        // through FFI or otherwise used with low-level threading primitives that have no\n        // notion of or way to enforce lifetimes.\n        //\n        // As mentioned in the `Safety` section of this function's documentation, the caller of\n        // this function needs to guarantee that the passed-in lifetime is sufficiently long\n        // for the lifetime of the thread.\n        //\n        // Similarly, the `sys` implementation must guarantee that no references to the closure\n        // exist after the thread has terminated, which is signaled by `Thread::join`\n        // returning.\n        native: unsafe { imp::Thread::new(stack_size, init)? },\n        thread,\n        packet: my_packet,\n    })\n}"
}