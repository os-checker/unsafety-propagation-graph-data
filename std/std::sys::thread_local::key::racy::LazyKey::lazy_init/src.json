{
  "name": "std::sys::thread_local::key::racy::LazyKey::lazy_init",
  "span": "$library/std/src/sys/thread_local/key/racy.rs:45:5: 45:33",
  "src": "fn lazy_init(&self) -> usize {\n        // POSIX allows the key created here to be KEY_SENTVAL, but the compare_exchange\n        // below relies on using KEY_SENTVAL as a sentinel value to check who won the\n        // race to set the shared TLS key. As far as I know, there is no\n        // guaranteed value that cannot be returned as a posix_key_create key,\n        // so there is no value we can initialize the inner key with to\n        // prove that it has not yet been set. As such, we'll continue using a\n        // value of KEY_SENTVAL, but with some gyrations to make sure we have a non-KEY_SENTVAL\n        // value returned from the creation routine.\n        // FIXME: this is clearly a hack, and should be cleaned up.\n        let key1 = super::create(self.dtor);\n        let key = if key1 as usize != KEY_SENTVAL {\n            key1\n        } else {\n            let key2 = super::create(self.dtor);\n            unsafe {\n                super::destroy(key1);\n            }\n            key2\n        };\n        rtassert!(key as usize != KEY_SENTVAL);\n        match self.key.compare_exchange(\n            KEY_SENTVAL,\n            key as usize,\n            Ordering::Release,\n            Ordering::Acquire,\n        ) {\n            // The CAS succeeded, so we've created the actual key\n            Ok(_) => key as usize,\n            // If someone beat us to the punch, use their key instead\n            Err(n) => unsafe {\n                super::destroy(key);\n                n\n            },\n        }\n    }"
}