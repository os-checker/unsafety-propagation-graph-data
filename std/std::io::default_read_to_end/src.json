{
  "name": "std::io::default_read_to_end",
  "span": "$library/std/src/io/mod.rs:409:1: 413:19",
  "src": "pub(crate) fn default_read_to_end<R: Read + ?Sized>(\n    r: &mut R,\n    buf: &mut Vec<u8>,\n    size_hint: Option<usize>,\n) -> Result<usize> {\n    let start_len = buf.len();\n    let start_cap = buf.capacity();\n    // Optionally limit the maximum bytes read on each iteration.\n    // This adds an arbitrary fiddle factor to allow for more data than we expect.\n    let mut max_read_size = size_hint\n        .and_then(|s| s.checked_add(1024)?.checked_next_multiple_of(DEFAULT_BUF_SIZE))\n        .unwrap_or(DEFAULT_BUF_SIZE);\n\n    const PROBE_SIZE: usize = 32;\n\n    fn small_probe_read<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n        let mut probe = [0u8; PROBE_SIZE];\n\n        loop {\n            match r.read(&mut probe) {\n                Ok(n) => {\n                    // there is no way to recover from allocation failure here\n                    // because the data has already been read.\n                    buf.extend_from_slice(&probe[..n]);\n                    return Ok(n);\n                }\n                Err(ref e) if e.is_interrupted() => continue,\n                Err(e) => return Err(e),\n            }\n        }\n    }\n\n    // avoid inflating empty/small vecs before we have determined that there's anything to read\n    if (size_hint.is_none() || size_hint == Some(0)) && buf.capacity() - buf.len() < PROBE_SIZE {\n        let read = small_probe_read(r, buf)?;\n\n        if read == 0 {\n            return Ok(0);\n        }\n    }\n\n    loop {\n        if buf.len() == buf.capacity() && buf.capacity() == start_cap {\n            // The buffer might be an exact fit. Let's read into a probe buffer\n            // and see if it returns `Ok(0)`. If so, we've avoided an\n            // unnecessary doubling of the capacity. But if not, append the\n            // probe buffer to the primary buffer and let its capacity grow.\n            let read = small_probe_read(r, buf)?;\n\n            if read == 0 {\n                return Ok(buf.len() - start_len);\n            }\n        }\n\n        if buf.len() == buf.capacity() {\n            // buf is full, need more space\n            buf.try_reserve(PROBE_SIZE)?;\n        }\n\n        let mut spare = buf.spare_capacity_mut();\n        let buf_len = cmp::min(spare.len(), max_read_size);\n        spare = &mut spare[..buf_len];\n        let mut read_buf: BorrowedBuf<'_> = spare.into();\n\n        let mut cursor = read_buf.unfilled();\n        let result = loop {\n            match r.read_buf(cursor.reborrow()) {\n                Err(e) if e.is_interrupted() => continue,\n                // Do not stop now in case of error: we might have received both data\n                // and an error\n                res => break res,\n            }\n        };\n\n        let bytes_read = cursor.written();\n\n        // SAFETY: BorrowedBuf's invariants mean this much memory is initialized.\n        unsafe {\n            let new_len = bytes_read + buf.len();\n            buf.set_len(new_len);\n        }\n\n        // Now that all data is pushed to the vector, we can fail without data loss\n        result?;\n\n        if bytes_read == 0 {\n            return Ok(buf.len() - start_len);\n        }\n\n        // Use heuristics to determine the max read size if no initial size hint was provided\n        if size_hint.is_none() {\n            // we have passed a larger buffer than previously and the\n            // reader still hasn't returned a short read\n            if buf_len >= max_read_size && bytes_read == buf_len {\n                max_read_size = max_read_size.saturating_mul(2);\n            }\n        }\n    }\n}"
}