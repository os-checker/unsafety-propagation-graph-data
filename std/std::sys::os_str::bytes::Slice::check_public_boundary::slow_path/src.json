{
  "name": "std::sys::os_str::bytes::Slice::check_public_boundary::slow_path",
  "span": "$library/std/src/sys/os_str/bytes.rs:276:9: 276:49",
  "src": "fn slow_path(bytes: &[u8], index: usize) {\n            let (before, after) = bytes.split_at(index);\n\n            // UTF-8 takes at most 4 bytes per codepoint, so we don't\n            // need to check more than that.\n            let after = after.get(..4).unwrap_or(after);\n            match str::from_utf8(after) {\n                Ok(_) => return,\n                Err(err) if err.valid_up_to() != 0 => return,\n                Err(_) => (),\n            }\n\n            for len in 2..=4.min(index) {\n                let before = &before[index - len..];\n                if str::from_utf8(before).is_ok() {\n                    return;\n                }\n            }\n\n            panic!(\"byte index {index} is not an OsStr boundary\");\n        }"
}