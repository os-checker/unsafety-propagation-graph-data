{
  "name": "std::sys::fs::unix::File::set_times",
  "span": "$library/std/src/sys/fs/unix.rs:1629:5: 1629:64",
  "src": "pub fn set_times(&self, times: FileTimes) -> io::Result<()> {\n        cfg_select! {\n            any(target_os = \"redox\", target_os = \"espidf\", target_os = \"horizon\", target_os = \"nuttx\") => {\n                // Redox doesn't appear to support `UTIME_OMIT`.\n                // ESP-IDF and HorizonOS do not support `futimens` at all and the behavior for those OS is therefore\n                // the same as for Redox.\n                let _ = times;\n                Err(io::const_error!(\n                    io::ErrorKind::Unsupported,\n                    \"setting file times not supported\",\n                ))\n            }\n            target_vendor = \"apple\" => {\n                let ta = TimesAttrlist::from_times(&times)?;\n                cvt(unsafe { libc::fsetattrlist(\n                    self.as_raw_fd(),\n                    ta.attrlist(),\n                    ta.times_buf(),\n                    ta.times_buf_size(),\n                    0\n                ) })?;\n                Ok(())\n            }\n            target_os = \"android\" => {\n                let times = [file_time_to_timespec(times.accessed)?, file_time_to_timespec(times.modified)?];\n                // futimens requires Android API level 19\n                cvt(unsafe {\n                    weak!(\n                        fn futimens(fd: c_int, times: *const libc::timespec) -> c_int;\n                    );\n                    match futimens.get() {\n                        Some(futimens) => futimens(self.as_raw_fd(), times.as_ptr()),\n                        None => return Err(io::const_error!(\n                            io::ErrorKind::Unsupported,\n                            \"setting file times requires Android API level >= 19\",\n                        )),\n                    }\n                })?;\n                Ok(())\n            }\n            _ => {\n                #[cfg(all(target_os = \"linux\", target_env = \"gnu\", target_pointer_width = \"32\", not(target_arch = \"riscv32\")))]\n                {\n                    use crate::sys::{time::__timespec64, weak::weak};\n\n                    // Added in glibc 2.34\n                    weak!(\n                        fn __futimens64(fd: c_int, times: *const __timespec64) -> c_int;\n                    );\n\n                    if let Some(futimens64) = __futimens64.get() {\n                        let to_timespec = |time: Option<SystemTime>| time.map(|time| time.t.to_timespec64())\n                            .unwrap_or(__timespec64::new(0, libc::UTIME_OMIT as _));\n                        let times = [to_timespec(times.accessed), to_timespec(times.modified)];\n                        cvt(unsafe { futimens64(self.as_raw_fd(), times.as_ptr()) })?;\n                        return Ok(());\n                    }\n                }\n                let times = [file_time_to_timespec(times.accessed)?, file_time_to_timespec(times.modified)?];\n                cvt(unsafe { libc::futimens(self.as_raw_fd(), times.as_ptr()) })?;\n                Ok(())\n            }\n        }\n    }"
}