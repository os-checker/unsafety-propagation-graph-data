{
  "name": "std::io::error::repr_bitpacked::Repr::new_custom",
  "span": "$library/std/src/io/error/repr_bitpacked.rs:136:5: 136:53",
  "src": "pub(super) fn new_custom(b: Box<Custom>) -> Self {\n        let p = Box::into_raw(b).cast::<u8>();\n        // Should only be possible if an allocator handed out a pointer with\n        // wrong alignment.\n        debug_assert_eq!(p.addr() & TAG_MASK, 0);\n        // Note: We know `TAG_CUSTOM <= size_of::<Custom>()` (static_assert at\n        // end of file), and both the start and end of the expression must be\n        // valid without address space wraparound due to `Box`'s semantics.\n        //\n        // This means it would be correct to implement this using `ptr::add`\n        // (rather than `ptr::wrapping_add`), but it's unclear this would give\n        // any benefit, so we just use `wrapping_add` instead.\n        let tagged = p.wrapping_add(TAG_CUSTOM).cast::<()>();\n        // Safety: `TAG_CUSTOM + p` is the same as `TAG_CUSTOM | p`,\n        // because `p`'s alignment means it isn't allowed to have any of the\n        // `TAG_BITS` set (you can verify that addition and bitwise-or are the\n        // same when the operands have no bits in common using a truth table).\n        //\n        // Then, `TAG_CUSTOM | p` is not zero, as that would require\n        // `TAG_CUSTOM` and `p` both be zero, and neither is (as `p` came from a\n        // box, and `TAG_CUSTOM` just... isn't zero -- it's `0b01`). Therefore,\n        // `TAG_CUSTOM + p` isn't zero and so `tagged` can't be, and the\n        // `new_unchecked` is safe.\n        let res = Self(unsafe { NonNull::new_unchecked(tagged) }, PhantomData);\n        // quickly smoke-check we encoded the right thing (This generally will\n        // only run in std's tests, unless the user uses -Zbuild-std)\n        debug_assert!(matches!(res.data(), ErrorData::Custom(_)), \"repr(custom) encoding failed\");\n        res\n    }"
}