{
  "name": "std::thread::functions::park_timeout",
  "span": "$library/std/src/thread/functions.rs:592:1: 592:35",
  "doc": " Blocks unless or until the current thread's token is made available or\n the specified duration has been reached (may wake spuriously).\n\n The semantics of this function are equivalent to [`park`][park] except\n that the thread will be blocked for roughly no longer than `dur`. This\n method should not be used for precise timing due to anomalies such as\n preemption or platform differences that might not cause the maximum\n amount of time waited to be precisely `dur` long.\n\n See the [park documentation][park] for more details.\n\n # Platform-specific behavior\n\n Platforms which do not support nanosecond precision for sleeping will have\n `dur` rounded up to the nearest granularity of time they can sleep for.\n\n # Examples\n\n Waiting for the complete expiration of the timeout:\n\n ```rust,no_run\n use std::thread::park_timeout;\n use std::time::{Instant, Duration};\n\n let timeout = Duration::from_secs(2);\n let beginning_park = Instant::now();\n\n let mut timeout_remaining = timeout;\n loop {\n     park_timeout(timeout_remaining);\n     let elapsed = beginning_park.elapsed();\n     if elapsed >= timeout {\n         break;\n     }\n     println!(\"restarting park_timeout after {elapsed:?}\");\n     timeout_remaining = timeout - elapsed;\n }\n ```\n"
}