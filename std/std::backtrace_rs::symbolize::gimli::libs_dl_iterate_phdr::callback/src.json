{
  "name": "std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback",
  "span": "$library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:55:1: 59:17",
  "src": "unsafe extern \"C\" fn callback(\n    info: *mut libc::dl_phdr_info,\n    _size: libc::size_t,\n    data: *mut libc::c_void,\n) -> libc::c_int {\n    // SAFETY: We are guaranteed these fields:\n    let dlpi_addr = unsafe { (*info).dlpi_addr };\n    let dlpi_name = unsafe { (*info).dlpi_name };\n    let dlpi_phdr = unsafe { (*info).dlpi_phdr };\n    let dlpi_phnum = unsafe { (*info).dlpi_phnum };\n    // SAFETY: We assured this.\n    let CallbackData { libs, maps } = unsafe { &mut *data.cast::<CallbackData>() };\n    // most implementations give us the main program first\n    let is_main = libs.is_empty();\n    // we may be statically linked, which means we are main and mostly one big blob of code\n    let is_static = dlpi_addr == 0;\n    // sometimes we get a null or 0-len CStr, based on libc's whims, but these mean the same thing\n    let no_given_name = dlpi_name.is_null()\n        // SAFETY: we just checked for null\n        || unsafe { *dlpi_name == 0 };\n    let name = if is_static {\n        // don't try to look up our name from /proc/self/maps, it'll get silly\n        env::current_exe().unwrap_or_default().into_os_string()\n    } else if is_main && no_given_name {\n        infer_current_exe(&maps, dlpi_addr as usize)\n    } else {\n        // this fallback works even if we are main, because some platforms give the name anyways\n        if dlpi_name.is_null() {\n            OsString::new()\n        } else {\n            // SAFETY: we just checked for nullness\n            OsStr::from_bytes(unsafe { CStr::from_ptr(dlpi_name) }.to_bytes()).to_owned()\n        }\n    };\n    #[cfg(target_os = \"android\")]\n    let zip_offset: Option<u64> = {\n        // only check for ZIP-embedded file if we have data from /proc/self/maps\n        maps.as_ref().and_then(|maps| {\n            // check if file is embedded within a ZIP archive by searching for `!/`\n            super::extract_zip_path_android(&name).and_then(|_| {\n                // find MapsEntry matching library's base address and get its file offset\n                maps.iter()\n                    .find(|m| m.ip_matches(dlpi_addr as usize))\n                    .map(|m| m.offset())\n            })\n        })\n    };\n    let headers = if dlpi_phdr.is_null() || dlpi_phnum == 0 {\n        &[]\n    } else {\n        // SAFETY: We just checked for nullness or 0-len slices\n        unsafe { slice::from_raw_parts(dlpi_phdr, dlpi_phnum as usize) }\n    };\n    libs.push(Library {\n        name,\n        #[cfg(target_os = \"android\")]\n        zip_offset,\n        segments: headers\n            .iter()\n            .map(|header| LibrarySegment {\n                len: header.p_memsz as usize,\n                stated_virtual_memory_address: header.p_vaddr as usize,\n            })\n            .collect(),\n        bias: dlpi_addr as usize,\n    });\n    0\n}"
}