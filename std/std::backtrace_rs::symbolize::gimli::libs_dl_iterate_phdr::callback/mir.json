{
  "name": "std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback",
  "span": "$library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:55:1: 59:17",
  "mir": "fn std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback(_1: *mut libc::dl_phdr_info, _2: usize, _3: *mut libc::c_void) -> i32 {\n    let mut _0: i32;\n    let  _4: u64;\n    let  _5: *const u8;\n    let  _6: *const libc::Elf64_Phdr;\n    let  _7: u16;\n    let  _8: &mut alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::Library>;\n    let  _9: &mut core::option::Option<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>;\n    let mut _10: &mut backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::CallbackData;\n    let mut _11: *mut backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::CallbackData;\n    let  _12: bool;\n    let mut _13: &alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::Library>;\n    let  _14: bool;\n    let  _15: bool;\n    let mut _16: bool;\n    let mut _17: u8;\n    let  _18: ffi::os_str::OsString;\n    let mut _19: path::PathBuf;\n    let mut _20: core::result::Result<path::PathBuf, io::error::Error>;\n    let mut _21: bool;\n    let mut _22: &core::option::Option<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>;\n    let  _23: &&mut core::option::Option<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>;\n    let mut _24: usize;\n    let mut _25: bool;\n    let  _26: &ffi::os_str::OsStr;\n    let  _27: &[u8];\n    let  _28: &core::ffi::CStr;\n    let  _29: &[libc::Elf64_Phdr];\n    let mut _30: bool;\n    let  _31: &[libc::Elf64_Phdr; 0];\n    let mut _32: usize;\n    let  _33: ();\n    let mut _34: backtrace_rs::symbolize::gimli::Library;\n    let mut _35: ffi::os_str::OsString;\n    let mut _36: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::LibrarySegment>;\n    let mut _37: core::iter::Map<core::slice::Iter<'_, libc::Elf64_Phdr>, {closure@$library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:114:18: 114:26}>;\n    let mut _38: core::slice::Iter<'_, libc::Elf64_Phdr>;\n    let mut _39: &[libc::Elf64_Phdr];\n    let mut _40: usize;\n    let mut _41: &mut core::option::Option<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>;\n    let mut _42: *const ();\n    let mut _43: usize;\n    let mut _44: usize;\n    let mut _45: usize;\n    let mut _46: bool;\n    let mut _47: *const ();\n    let mut _48: usize;\n    let mut _49: usize;\n    let mut _50: usize;\n    let mut _51: bool;\n    let mut _52: *const ();\n    let mut _53: usize;\n    let mut _54: usize;\n    let mut _55: usize;\n    let mut _56: bool;\n    let mut _57: *const ();\n    let mut _58: usize;\n    let mut _59: usize;\n    let mut _60: usize;\n    let mut _61: bool;\n    let mut _62: *const ();\n    let mut _63: usize;\n    let mut _64: usize;\n    let mut _65: usize;\n    let mut _66: bool;\n    let mut _67: *const ();\n    let mut _68: usize;\n    let mut _69: bool;\n    let mut _70: bool;\n    let mut _71: bool;\n    let mut _72: bool;\n    let mut _73: *const ();\n    let mut _74: usize;\n    let mut _75: bool;\n    let mut _76: bool;\n    let mut _77: bool;\n    let mut _78: bool;\n    let mut _79: *const ();\n    let mut _80: usize;\n    let mut _81: bool;\n    let mut _82: bool;\n    let mut _83: bool;\n    let mut _84: bool;\n    let mut _85: *const ();\n    let mut _86: usize;\n    let mut _87: bool;\n    let mut _88: bool;\n    let mut _89: bool;\n    let mut _90: bool;\n    let mut _91: *const ();\n    let mut _92: usize;\n    let mut _93: bool;\n    let mut _94: bool;\n    let mut _95: bool;\n    let mut _96: *const ();\n    let mut _97: usize;\n    let mut _98: bool;\n    let mut _99: bool;\n    let mut _100: bool;\n    let mut _101: bool;\n    debug info => _1;\n    debug _size => _2;\n    debug data => _3;\n    debug dlpi_addr => _4;\n    debug dlpi_name => _5;\n    debug dlpi_phdr => _6;\n    debug dlpi_phnum => _7;\n    debug libs => _8;\n    debug maps => _9;\n    debug is_main => _12;\n    debug is_static => _14;\n    debug no_given_name => _15;\n    debug name => _18;\n    debug headers => _29;\n    bb0: {\n        _62 = _1 as *const ();\n        _63 = _62 as usize;\n        _64 = Sub(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _65 = BitAnd(_63, _64);\n        _66 = Eq(_65, 0_usize);\n        assert(_66, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, _63) -> [success: bb42, unwind unreachable];\n    }\n    bb1: {\n        _42 = _11 as *const ();\n        _43 = _42 as usize;\n        _44 = Sub(<backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::CallbackData as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _45 = BitAnd(_43, _44);\n        _46 = Eq(_45, 0_usize);\n        assert(_46, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::CallbackData as core::mem::SizedTypeProperties>::ALIGN, _43) -> [success: bb38, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_13);\n        _14 = Eq(_4, 0_u64);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = core::ptr::const_ptr::<impl *const u8>::is_null(_5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _16) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        _15 = true;\n        goto -> bb6;\n    }\n    bb5: {\n        StorageLive(_17);\n        _96 = _5 as *const ();\n        _97 = _96 as usize;\n        _98 = Ne(<u8 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _99 = Eq(_97, 0_usize);\n        _100 = BitAnd(_99, _98);\n        _101 = Not(_100);\n        assert(_101, \"null pointer dereference occurred\") -> [success: bb48, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_16);\n        StorageLive(_18);\n        switchInt(_14) -> [0: bb11, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = env::current_exe() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _19 = core::result::Result::<path::PathBuf, io::error::Error>::unwrap_or_default(move _20) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_20);\n        _18 = path::PathBuf::into_os_string(move _19) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        goto -> bb25;\n    }\n    bb11: {\n        switchInt(_12) -> [0: bb15, otherwise: bb12];\n    }\n    bb12: {\n        StorageLive(_21);\n        _21 = _15;\n        switchInt(move _21) -> [0: bb15, otherwise: bb13];\n    }\n    bb13: {\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &_9;\n        _41 = (*_23);\n        _22 = &(*_41);\n        StorageLive(_24);\n        _24 = _4 as usize;\n        _18 = backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::infer_current_exe(move _22, move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb24;\n    }\n    bb15: {\n        StorageLive(_25);\n        _25 = core::ptr::const_ptr::<impl *const u8>::is_null(_5) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        switchInt(move _25) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        _18 = ffi::os_str::OsString::new() -> [return: bb23, unwind unreachable];\n    }\n    bb18: {\n        _28 = core::ffi::CStr::from_ptr::<'_>(_5) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _27 = core::ffi::CStr::to_bytes(_28) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _26 = <ffi::os_str::OsStr as os::unix::ffi::os_str::OsStrExt>::from_bytes(_27) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _18 = <ffi::os_str::OsStr as alloc_crate::borrow::ToOwned>::to_owned(_26) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_25);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_21);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = core::ptr::const_ptr::<impl *const libc::Elf64_Phdr>::is_null(_6) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _30) -> [0: bb28, otherwise: bb27];\n    }\n    bb27: {\n        goto -> bb30;\n    }\n    bb28: {\n        switchInt(_7) -> [0: bb29, otherwise: bb31];\n    }\n    bb29: {\n        goto -> bb30;\n    }\n    bb30: {\n        _31 = backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::callback::promoted[0];\n        _29 = _31 as &[libc::Elf64_Phdr];\n        goto -> bb33;\n    }\n    bb31: {\n        StorageLive(_32);\n        _32 = _7 as usize;\n        _29 = core::slice::from_raw_parts::<'_, libc::Elf64_Phdr>(_6, move _32) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_32);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_30);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = move _18;\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = _29;\n        _38 = core::slice::<impl [libc::Elf64_Phdr]>::iter(move _39) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_39);\n        _37 = <core::slice::Iter<'_, libc::Elf64_Phdr> as core::iter::Iterator>::map::<backtrace_rs::symbolize::gimli::LibrarySegment, {closure@$library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:114:18: 114:26}>(move _38, ZeroSized: {closure@$library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:114:18: 114:26}) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_38);\n        _36 = <core::iter::Map<core::slice::Iter<'_, libc::Elf64_Phdr>, {closure@$library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:114:18: 114:26}> as core::iter::Iterator>::collect::<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::LibrarySegment>>(move _37) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_37);\n        StorageLive(_40);\n        _40 = _4 as usize;\n        _34 = Library(move _35, move _36, move _40);\n        StorageDead(_40);\n        StorageDead(_36);\n        StorageDead(_35);\n        _33 = alloc_crate::vec::Vec::<backtrace_rs::symbolize::gimli::Library>::push(_8, move _34) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_34);\n        _0 = 0_i32;\n        StorageDead(_29);\n        StorageDead(_18);\n        StorageDead(_15);\n        StorageDead(_9);\n        StorageDead(_11);\n        return;\n    }\n    bb38: {\n        _91 = _11 as *const ();\n        _92 = _91 as usize;\n        _93 = Eq(_92, 0_usize);\n        _94 = BitAnd(_93, true);\n        _95 = Not(_94);\n        assert(_95, \"null pointer dereference occurred\") -> [success: bb47, unwind unreachable];\n    }\n    bb39: {\n        _85 = _1 as *const ();\n        _86 = _85 as usize;\n        _87 = Ne(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _88 = Eq(_86, 0_usize);\n        _89 = BitAnd(_88, _87);\n        _90 = Not(_89);\n        assert(_90, \"null pointer dereference occurred\") -> [success: bb46, unwind unreachable];\n    }\n    bb40: {\n        _79 = _1 as *const ();\n        _80 = _79 as usize;\n        _81 = Ne(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _82 = Eq(_80, 0_usize);\n        _83 = BitAnd(_82, _81);\n        _84 = Not(_83);\n        assert(_84, \"null pointer dereference occurred\") -> [success: bb45, unwind unreachable];\n    }\n    bb41: {\n        _73 = _1 as *const ();\n        _74 = _73 as usize;\n        _75 = Ne(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _76 = Eq(_74, 0_usize);\n        _77 = BitAnd(_76, _75);\n        _78 = Not(_77);\n        assert(_78, \"null pointer dereference occurred\") -> [success: bb44, unwind unreachable];\n    }\n    bb42: {\n        _67 = _1 as *const ();\n        _68 = _67 as usize;\n        _69 = Ne(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _70 = Eq(_68, 0_usize);\n        _71 = BitAnd(_70, _69);\n        _72 = Not(_71);\n        assert(_72, \"null pointer dereference occurred\") -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _4 = ((*_1).0: u64);\n        _57 = _1 as *const ();\n        _58 = _57 as usize;\n        _59 = Sub(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _60 = BitAnd(_58, _59);\n        _61 = Eq(_60, 0_usize);\n        assert(_61, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, _58) -> [success: bb41, unwind unreachable];\n    }\n    bb44: {\n        _5 = ((*_1).1: *const u8);\n        _52 = _1 as *const ();\n        _53 = _52 as usize;\n        _54 = Sub(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _55 = BitAnd(_53, _54);\n        _56 = Eq(_55, 0_usize);\n        assert(_56, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, _53) -> [success: bb40, unwind unreachable];\n    }\n    bb45: {\n        _6 = ((*_1).2: *const libc::Elf64_Phdr);\n        _47 = _1 as *const ();\n        _48 = _47 as usize;\n        _49 = Sub(<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _50 = BitAnd(_48, _49);\n        _51 = Eq(_50, 0_usize);\n        assert(_51, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::dl_phdr_info as core::mem::SizedTypeProperties>::ALIGN, _48) -> [success: bb39, unwind unreachable];\n    }\n    bb46: {\n        _7 = ((*_1).3: u16);\n        StorageLive(_11);\n        _11 = core::ptr::mut_ptr::<impl *mut libc::c_void>::cast::<backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::CallbackData>(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb47: {\n        _10 = &mut (*_11);\n        _8 = &mut ((*_10).0: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::Library>);\n        StorageLive(_9);\n        _9 = &mut ((*_10).1: core::option::Option<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>);\n        StorageLive(_13);\n        _13 = &(*_8);\n        _12 = alloc_crate::vec::Vec::<backtrace_rs::symbolize::gimli::Library>::is_empty(move _13) -> [return: bb2, unwind unreachable];\n    }\n    bb48: {\n        _17 = (*_5);\n        _15 = Eq(move _17, 0_u8);\n        StorageDead(_17);\n        goto -> bb6;\n    }\n}\n"
}