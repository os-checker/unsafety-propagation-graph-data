{
  "name": "std::<sys::fs::unix::File as core::fmt::Debug>::fmt",
  "span": "$library/std/src/sys/fs/unix.rs:1837:5: 1837:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        #[cfg(any(target_os = \"linux\", target_os = \"illumos\", target_os = \"solaris\"))]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut p = PathBuf::from(\"/proc/self/fd\");\n            p.push(&fd.to_string());\n            run_path_with_cstr(&p, &readlink).ok()\n        }\n\n        #[cfg(any(target_vendor = \"apple\", target_os = \"netbsd\"))]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n            // is inevitable in this case because Apple targets and NetBSD define `fcntl`\n            // with `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n            // alternatives. If a better method is invented, it should be used\n            // instead.\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n            if n == -1 {\n                cfg_select! {\n                    target_os = \"netbsd\" => {\n                        // fallback to procfs as last resort\n                        let mut p = PathBuf::from(\"/proc/self/fd\");\n                        p.push(&fd.to_string());\n                        return run_path_with_cstr(&p, &readlink).ok()\n                    }\n                    _ => {\n                        return None;\n                    }\n                }\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            buf.shrink_to_fit();\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(target_os = \"freebsd\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let info = Box::<libc::kinfo_file>::new_zeroed();\n            let mut info = unsafe { info.assume_init() };\n            info.kf_structsize = size_of::<libc::kinfo_file>() as libc::c_int;\n            let n = unsafe { libc::fcntl(fd, libc::F_KINFO, &mut *info) };\n            if n == -1 {\n                return None;\n            }\n            let buf = unsafe { CStr::from_ptr(info.kf_path.as_mut_ptr()).to_bytes().to_vec() };\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(target_os = \"vxworks\")]\n        fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut buf = vec![0; libc::PATH_MAX as usize];\n            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n            if n == -1 {\n                return None;\n            }\n            let l = buf.iter().position(|&c| c == 0).unwrap();\n            buf.truncate(l as usize);\n            Some(PathBuf::from(OsString::from_vec(buf)))\n        }\n\n        #[cfg(not(any(\n            target_os = \"linux\",\n            target_os = \"vxworks\",\n            target_os = \"freebsd\",\n            target_os = \"netbsd\",\n            target_os = \"illumos\",\n            target_os = \"solaris\",\n            target_vendor = \"apple\",\n        )))]\n        fn get_path(_fd: c_int) -> Option<PathBuf> {\n            // FIXME(#24570): implement this for other Unix platforms\n            None\n        }\n\n        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n            if mode == -1 {\n                return None;\n            }\n            match mode & libc::O_ACCMODE {\n                libc::O_RDONLY => Some((true, false)),\n                libc::O_RDWR => Some((true, true)),\n                libc::O_WRONLY => Some((false, true)),\n                _ => None,\n            }\n        }\n\n        let fd = self.as_raw_fd();\n        let mut b = f.debug_struct(\"File\");\n        b.field(\"fd\", &fd);\n        if let Some(path) = get_path(fd) {\n            b.field(\"path\", &path);\n        }\n        if let Some((read, write)) = get_mode(fd) {\n            b.field(\"read\", &read).field(\"write\", &write);\n        }\n        b.finish()\n    }"
}