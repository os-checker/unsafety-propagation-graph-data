{
  "name": "std::<io::Take<T> as io::Read>::read_buf",
  "span": "$library/std/src/io/mod.rs:3066:5: 3066:70",
  "src": "fn read_buf(&mut self, mut buf: BorrowedCursor<'_>) -> Result<()> {\n        // Don't call into inner reader at all at EOF because it may still block\n        if self.limit == 0 {\n            return Ok(());\n        }\n\n        if self.limit < buf.capacity() as u64 {\n            // The condition above guarantees that `self.limit` fits in `usize`.\n            let limit = self.limit as usize;\n\n            // SAFETY: no uninit data is written to ibuf\n            let ibuf = unsafe { &mut buf.as_mut()[..limit] };\n\n            let mut sliced_buf: BorrowedBuf<'_> = ibuf.into();\n\n            let mut cursor = sliced_buf.unfilled();\n            let result = self.inner.read_buf(cursor.reborrow());\n\n            let filled = sliced_buf.len();\n\n            // cursor / sliced_buf / ibuf must drop here\n\n            // SAFETY: filled bytes have been filled and therefore initialized\n            unsafe {\n                buf.advance(filled);\n            }\n\n            self.limit -= filled as u64;\n\n            result\n        } else {\n            let written = buf.written();\n            let result = self.inner.read_buf(buf.reborrow());\n            self.limit -= (buf.written() - written) as u64;\n            result\n        }\n    }"
}