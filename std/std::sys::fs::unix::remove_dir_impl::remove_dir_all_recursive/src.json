{
  "name": "std::sys::fs::unix::remove_dir_impl::remove_dir_all_recursive",
  "span": "$library/std/src/sys/fs/unix.rs:2526:5: 2526:89",
  "src": "fn remove_dir_all_recursive(parent_fd: Option<RawFd>, path: &CStr) -> io::Result<()> {\n        // try opening as directory\n        let fd = match openat_nofollow_dironly(parent_fd, &path) {\n            Err(err) if matches!(err.raw_os_error(), Some(libc::ENOTDIR | libc::ELOOP)) => {\n                // not a directory - don't traverse further\n                // (for symlinks, older Linux kernels may return ELOOP instead of ENOTDIR)\n                return match parent_fd {\n                    // unlink...\n                    Some(parent_fd) => {\n                        cvt(unsafe { unlinkat(parent_fd, path.as_ptr(), 0) }).map(drop)\n                    }\n                    // ...unless this was supposed to be the deletion root directory\n                    None => Err(err),\n                };\n            }\n            result => result?,\n        };\n\n        // open the directory passing ownership of the fd\n        let (dir, fd) = fdreaddir(fd)?;\n        for child in dir {\n            let child = child?;\n            let child_name = child.name_cstr();\n            // we need an inner try block, because if one of these\n            // directories has already been deleted, then we need to\n            // continue the loop, not return ok.\n            let result: io::Result<()> = try {\n                match is_dir(&child) {\n                    Some(true) => {\n                        remove_dir_all_recursive(Some(fd), child_name)?;\n                    }\n                    Some(false) => {\n                        cvt(unsafe { unlinkat(fd, child_name.as_ptr(), 0) })?;\n                    }\n                    None => {\n                        // POSIX specifies that calling unlink()/unlinkat(..., 0) on a directory can succeed\n                        // if the process has the appropriate privileges. This however can causing orphaned\n                        // directories requiring an fsck e.g. on Solaris and Illumos. So we try recursing\n                        // into it first instead of trying to unlink() it.\n                        remove_dir_all_recursive(Some(fd), child_name)?;\n                    }\n                }\n            };\n            if result.is_err() && !is_enoent(&result) {\n                return result;\n            }\n        }\n\n        // unlink the directory after removing its contents\n        ignore_notfound(cvt(unsafe {\n            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), path.as_ptr(), libc::AT_REMOVEDIR)\n        }))?;\n        Ok(())\n    }"
}