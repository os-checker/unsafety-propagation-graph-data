{
  "name": "std::io::stdio::Stdin::read_line",
  "span": "$library/std/src/io/stdio.rs:411:5: 411:67",
  "doc": " Locks this handle and reads a line of input, appending it to the specified buffer.\n\n For detailed semantics of this method, see the documentation on\n [`BufRead::read_line`]. In particular:\n * Previous content of the buffer will be preserved. To avoid appending\n   to the buffer, you need to [`clear`] it first.\n * The trailing newline character, if any, is included in the buffer.\n\n [`clear`]: String::clear\n\n # Examples\n\n ```no_run\n use std::io;\n\n let mut input = String::new();\n match io::stdin().read_line(&mut input) {\n     Ok(n) => {\n         println!(\"{n} bytes read\");\n         println!(\"{input}\");\n     }\n     Err(error) => println!(\"error: {error}\"),\n }\n ```\n\n You can run the example one of two ways:\n\n - Pipe some text to it, e.g., `printf foo | path/to/executable`\n - Give it text interactively by running the executable directly,\n   in which case it will wait for the Enter key to be pressed before\n   continuing\n"
}