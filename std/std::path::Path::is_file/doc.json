{
  "name": "std::path::Path::is_file",
  "span": "$library/std/src/path.rs:3475:5: 3475:34",
  "doc": " Returns `true` if the path exists on disk and is pointing at a regular file.\n\n This function will traverse symbolic links to query information about the\n destination file.\n\n If you cannot access the metadata of the file, e.g. because of a\n permission error or broken symbolic links, this will return `false`.\n\n # Examples\n\n ```no_run\n use std::path::Path;\n assert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\n assert_eq!(Path::new(\"a_file.txt\").is_file(), true);\n ```\n\n # See Also\n\n This is a convenience function that coerces errors to false. If you want to\n check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n [`fs::Metadata::is_file`] if it was [`Ok`].\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`fs::File::open`] or\n [`fs::OpenOptions::open`] for more information.\n"
}