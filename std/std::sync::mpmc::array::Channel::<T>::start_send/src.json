{
  "name": "std::sync::mpmc::array::Channel::<T>::start_send",
  "span": "$library/std/src/sync/mpmc/array.rs:124:5: 124:52",
  "src": "fn start_send(&self, token: &mut Token) -> bool {\n        let backoff = Backoff::new();\n        let mut tail = self.tail.load(Ordering::Relaxed);\n\n        loop {\n            // Check if the channel is disconnected.\n            if tail & self.mark_bit != 0 {\n                token.array.slot = ptr::null();\n                token.array.stamp = 0;\n                return true;\n            }\n\n            // Deconstruct the tail.\n            let index = tail & (self.mark_bit - 1);\n            let lap = tail & !(self.one_lap - 1);\n\n            // Inspect the corresponding slot.\n            debug_assert!(index < self.buffer.len());\n            let slot = unsafe { self.buffer.get_unchecked(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the tail and the stamp match, we may attempt to push.\n            if tail == stamp {\n                let new_tail = if index + 1 < self.cap {\n                    // Same lap, incremented index.\n                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n                    tail + 1\n                } else {\n                    // One lap forward, index wraps around to zero.\n                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n                    lap.wrapping_add(self.one_lap)\n                };\n\n                // Try moving the tail.\n                match self.tail.compare_exchange_weak(\n                    tail,\n                    new_tail,\n                    Ordering::SeqCst,\n                    Ordering::Relaxed,\n                ) {\n                    Ok(_) => {\n                        // Prepare the token for the follow-up call to `write`.\n                        token.array.slot = slot as *const Slot<T> as *const u8;\n                        token.array.stamp = tail + 1;\n                        return true;\n                    }\n                    Err(_) => {\n                        backoff.spin_light();\n                        tail = self.tail.load(Ordering::Relaxed);\n                    }\n                }\n            } else if stamp.wrapping_add(self.one_lap) == tail + 1 {\n                atomic::fence(Ordering::SeqCst);\n                let head = self.head.load(Ordering::Relaxed);\n\n                // If the head lags one lap behind the tail as well...\n                if head.wrapping_add(self.one_lap) == tail {\n                    // ...then the channel is full.\n                    return false;\n                }\n\n                backoff.spin_light();\n                tail = self.tail.load(Ordering::Relaxed);\n            } else {\n                // Snooze because we need to wait for the stamp to get updated.\n                backoff.spin_heavy();\n                tail = self.tail.load(Ordering::Relaxed);\n            }\n        }\n    }"
}