{
  "name": "std::thread::scoped::scope",
  "span": "$library/std/src/thread/scoped.rs:138:1: 140:61",
  "src": "pub fn scope<'env, F, T>(f: F) -> T\nwhere\n    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,\n{\n    // We put the `ScopeData` into an `Arc` so that other threads can finish their\n    // `decrement_num_running_threads` even after this function returns.\n    let scope = Scope {\n        data: Arc::new(ScopeData {\n            num_running_threads: AtomicUsize::new(0),\n            main_thread: current_or_unnamed(),\n            a_thread_panicked: AtomicBool::new(false),\n        }),\n        env: PhantomData,\n        scope: PhantomData,\n    };\n\n    // Run `f`, but catch panics so we can make sure to wait for all the threads to join.\n    let result = catch_unwind(AssertUnwindSafe(|| f(&scope)));\n\n    // Wait until all the threads are finished.\n    while scope.data.num_running_threads.load(Ordering::Acquire) != 0 {\n        // SAFETY: this is the main thread, the handle belongs to us.\n        unsafe { scope.data.main_thread.park() };\n    }\n\n    // Throw any panic from `f`, or the return value of `f` if no thread panicked.\n    match result {\n        Err(e) => resume_unwind(e),\n        Ok(_) if scope.data.a_thread_panicked.load(Ordering::Relaxed) => {\n            panic!(\"a scoped thread panicked\")\n        }\n        Ok(result) => result,\n    }\n}"
}