{
  "name": "std::sys::random::linux::getrandom",
  "span": "$library/std/src/sys/random/linux.rs:72:1: 72:51",
  "src": "fn getrandom(mut bytes: &mut [u8], insecure: bool) {\n    // A weak symbol allows interposition, e.g. for perf measurements that want to\n    // disable randomness for consistency. Otherwise, we'll try a raw syscall.\n    // (`getrandom` was added in glibc 2.25, musl 1.1.20, android API level 28)\n    syscall!(\n        fn getrandom(\n            buffer: *mut libc::c_void,\n            length: libc::size_t,\n            flags: libc::c_uint,\n        ) -> libc::ssize_t;\n    );\n\n    static GETRANDOM_AVAILABLE: Atomic<bool> = AtomicBool::new(true);\n    static GRND_INSECURE_AVAILABLE: Atomic<bool> = AtomicBool::new(true);\n    static URANDOM_READY: Atomic<bool> = AtomicBool::new(false);\n    static DEVICE: OnceLock<File> = OnceLock::new();\n\n    if GETRANDOM_AVAILABLE.load(Relaxed) {\n        loop {\n            if bytes.is_empty() {\n                return;\n            }\n\n            let flags = if insecure {\n                if GRND_INSECURE_AVAILABLE.load(Relaxed) {\n                    libc::GRND_INSECURE\n                } else {\n                    libc::GRND_NONBLOCK\n                }\n            } else {\n                0\n            };\n\n            let ret = unsafe { getrandom(bytes.as_mut_ptr().cast(), bytes.len(), flags) };\n            if ret != -1 {\n                bytes = &mut bytes[ret as usize..];\n            } else {\n                match errno() {\n                    libc::EINTR => continue,\n                    // `GRND_INSECURE` is not available, try\n                    // `GRND_NONBLOCK`.\n                    libc::EINVAL if flags == libc::GRND_INSECURE => {\n                        GRND_INSECURE_AVAILABLE.store(false, Relaxed);\n                        continue;\n                    }\n                    // The pool is not initialized yet, fall back to\n                    // /dev/urandom for now.\n                    libc::EAGAIN if flags == libc::GRND_NONBLOCK => break,\n                    // `getrandom` is unavailable or blocked by seccomp.\n                    // Don't try it again and fall back to /dev/urandom.\n                    libc::ENOSYS | libc::EPERM => {\n                        GETRANDOM_AVAILABLE.store(false, Relaxed);\n                        break;\n                    }\n                    _ => panic!(\"failed to generate random data\"),\n                }\n            }\n        }\n    }\n\n    // When we want cryptographic strength, we need to wait for the CPRNG-pool\n    // to become initialized. Do this by polling `/dev/random` until it is ready.\n    if !insecure {\n        if !URANDOM_READY.load(Acquire) {\n            let random = File::open(\"/dev/random\").expect(\"failed to open /dev/random\");\n            let mut fd = libc::pollfd { fd: random.as_raw_fd(), events: libc::POLLIN, revents: 0 };\n\n            while !URANDOM_READY.load(Acquire) {\n                let ret = unsafe { libc::poll(&mut fd, 1, -1) };\n                match ret {\n                    1 => {\n                        assert_eq!(fd.revents, libc::POLLIN);\n                        URANDOM_READY.store(true, Release);\n                        break;\n                    }\n                    -1 if errno() == libc::EINTR => continue,\n                    _ => panic!(\"poll(\\\"/dev/random\\\") failed\"),\n                }\n            }\n        }\n    }\n\n    DEVICE\n        .get_or_try_init(|| File::open(\"/dev/urandom\"))\n        .and_then(|mut dev| dev.read_exact(bytes))\n        .expect(\"failed to generate random data\");\n}"
}