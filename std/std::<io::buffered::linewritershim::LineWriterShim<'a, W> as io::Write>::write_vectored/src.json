{
  "name": "std::<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_vectored",
  "span": "$library/std/src/io/buffered/linewritershim.rs:178:5: 178:76",
  "src": "fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // If there's no specialized behavior for write_vectored, just use\n        // write. This has the benefit of more granular partial-line handling.\n        if !self.is_write_vectored() {\n            return match bufs.iter().find(|buf| !buf.is_empty()) {\n                Some(buf) => self.write(buf),\n                None => Ok(0),\n            };\n        }\n\n        // Find the buffer containing the last newline\n        // FIXME: This is overly slow if there are very many bufs and none contain\n        // newlines. e.g. writev() on Linux only writes up to 1024 slices, so\n        // scanning the rest is wasted effort. This makes write_all_vectored()\n        // quadratic.\n        let last_newline_buf_idx = bufs\n            .iter()\n            .enumerate()\n            .rev()\n            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n\n        // If there are no new newlines (that is, if this write is less than\n        // one line), just do a regular buffered write\n        let last_newline_buf_idx = match last_newline_buf_idx {\n            // No newlines; just do a normal buffered write\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write_vectored(bufs);\n            }\n            Some(i) => i,\n        };\n\n        // Flush existing content to prepare for our write\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.panicked here.\n        let flushed = self.inner_mut().write_vectored(lines)?;\n\n        // If inner returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Don't try to reconstruct the exact amount written; just bail\n        // in the event of a partial write\n        let mut lines_len: usize = 0;\n        for buf in lines {\n            // With overlapping/duplicate slices the total length may in theory\n            // exceed usize::MAX\n            lines_len = lines_len.saturating_add(buf.len());\n            if flushed < lines_len {\n                return Ok(flushed);\n            }\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of the\n        // rest as possible)\n        let buffered: usize = tail\n            .iter()\n            .filter(|buf| !buf.is_empty())\n            .map(|buf| self.buffer.write_to_buf(buf))\n            .take_while(|&n| n > 0)\n            .sum();\n\n        Ok(flushed + buffered)\n    }"
}