{
  "name": "std::sync::mpsc::channel",
  "span": "$library/std/src/sync/mpsc.rs:519:1: 519:48",
  "doc": " Creates a new asynchronous channel, returning the sender/receiver halves.\n\n All data sent on the [`Sender`] will become available on the [`Receiver`] in\n the same order as it was sent, and no [`send`] will block the calling thread\n (this channel has an \"infinite buffer\", unlike [`sync_channel`], which will\n block after its buffer limit is reached). [`recv`] will block until a message\n is available while there is at least one [`Sender`] alive (including clones).\n\n The [`Sender`] can be cloned to [`send`] to the same channel multiple times, but\n only one [`Receiver`] is supported.\n\n If the [`Receiver`] is disconnected while trying to [`send`] with the\n [`Sender`], the [`send`] method will return a [`SendError`]. Similarly, if the\n [`Sender`] is disconnected while trying to [`recv`], the [`recv`] method will\n return a [`RecvError`].\n\n [`send`]: Sender::send\n [`recv`]: Receiver::recv\n\n # Examples\n\n ```\n use std::sync::mpsc::channel;\n use std::thread;\n\n let (sender, receiver) = channel();\n\n // Spawn off an expensive computation\n thread::spawn(move || {\n #   fn expensive_computation() {}\n     sender.send(expensive_computation()).unwrap();\n });\n\n // Do some useful work for a while\n\n // Let's see what that answer was\n println!(\"{:?}\", receiver.recv().unwrap());\n ```\n"
}