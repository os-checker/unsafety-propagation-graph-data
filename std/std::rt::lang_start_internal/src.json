{
  "name": "std::rt::lang_start_internal",
  "span": "$library/std/src/rt.rs:152:1: 157:11",
  "src": "fn lang_start_internal(\n    main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n    argc: isize,\n    argv: *const *const u8,\n    sigpipe: u8,\n) -> isize {\n    // Guard against the code called by this function from unwinding outside of the Rust-controlled\n    // code, which is UB. This is a requirement imposed by a combination of how the\n    // `#[lang=\"start\"]` attribute is implemented as well as by the implementation of the panicking\n    // mechanism itself.\n    //\n    // There are a couple of instances where unwinding can begin. First is inside of the\n    // `rt::init`, `rt::cleanup` and similar functions controlled by std. In those instances a\n    // panic is a std implementation bug. A quite likely one too, as there isn't any way to\n    // prevent std from accidentally introducing a panic to these functions. Another is from\n    // user code from `main` or, more nefariously, as described in e.g. issue #86030.\n    //\n    // We use `catch_unwind` with `handle_rt_panic` instead of `abort_unwind` to make the error in\n    // case of a panic a bit nicer.\n    panic::catch_unwind(move || {\n        // SAFETY: Only called once during runtime initialization.\n        unsafe { init(argc, argv, sigpipe) };\n\n        let ret_code = panic::catch_unwind(main).unwrap_or_else(move |payload| {\n            // Carefully dispose of the panic payload.\n            let payload = panic::AssertUnwindSafe(payload);\n            panic::catch_unwind(move || drop({ payload }.0)).unwrap_or_else(move |e| {\n                mem::forget(e); // do *not* drop the 2nd payload\n                rtabort!(\"drop of the panic payload panicked\");\n            });\n            // Return error code for panicking programs.\n            101\n        });\n        let ret_code = ret_code as isize;\n\n        cleanup();\n        // Guard against multiple threads calling `libc::exit` concurrently.\n        // See the documentation for `unique_thread_exit` for more information.\n        crate::sys::exit_guard::unique_thread_exit();\n\n        ret_code\n    })\n    .unwrap_or_else(handle_rt_panic)\n}"
}