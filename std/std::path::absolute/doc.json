{
  "name": "std::path::absolute",
  "span": "$library/std/src/path.rs:4006:1: 4006:64",
  "doc": " Makes the path absolute without accessing the filesystem.\n\n If the path is relative, the current directory is used as the base directory.\n All intermediate components will be resolved according to platform-specific\n rules, but unlike [`canonicalize`][crate::fs::canonicalize], this does not\n resolve symlinks and may succeed even if the path does not exist.\n\n If the `path` is empty or getting the\n [current directory][crate::env::current_dir] fails, then an error will be\n returned.\n\n # Platform-specific behavior\n\n On POSIX platforms, the path is resolved using [POSIX semantics][posix-semantics],\n except that it stops short of resolving symlinks. This means it will keep `..`\n components and trailing separators.\n\n On Windows, for verbatim paths, this will simply return the path as given. For other\n paths, this is currently equivalent to calling\n [`GetFullPathNameW`][windows-path].\n\n On Cygwin, this is currently equivalent to calling [`cygwin_conv_path`][cygwin-path]\n with mode `CCP_WIN_A_TO_POSIX`, and then being processed like other POSIX platforms.\n If a Windows path is given, it will be converted to an absolute POSIX path without\n keeping `..`.\n\n Note that these [may change in the future][changes].\n\n # Errors\n\n This function may return an error in the following situations:\n\n * If `path` is syntactically invalid; in particular, if it is empty.\n * If getting the [current directory][crate::env::current_dir] fails.\n\n # Examples\n\n ## POSIX paths\n\n ```\n # #[cfg(unix)]\n fn main() -> std::io::Result<()> {\n     use std::path::{self, Path};\n\n     // Relative to absolute\n     let absolute = path::absolute(\"foo/./bar\")?;\n     assert!(absolute.ends_with(\"foo/bar\"));\n\n     // Absolute to absolute\n     let absolute = path::absolute(\"/foo//test/.././bar.rs\")?;\n     assert_eq!(absolute, Path::new(\"/foo/test/../bar.rs\"));\n     Ok(())\n }\n # #[cfg(not(unix))]\n # fn main() {}\n ```\n\n ## Windows paths\n\n ```\n # #[cfg(windows)]\n fn main() -> std::io::Result<()> {\n     use std::path::{self, Path};\n\n     // Relative to absolute\n     let absolute = path::absolute(\"foo/./bar\")?;\n     assert!(absolute.ends_with(r\"foo\\bar\"));\n\n     // Absolute to absolute\n     let absolute = path::absolute(r\"C:\\foo//test\\..\\./bar.rs\")?;\n\n     assert_eq!(absolute, Path::new(r\"C:\\foo\\bar.rs\"));\n     Ok(())\n }\n # #[cfg(not(windows))]\n # fn main() {}\n ```\n\n Note that this [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n [posix-semantics]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n [windows-path]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew\n [cygwin-path]: https://cygwin.com/cygwin-api/func-cygwin-conv-path.html\n"
}