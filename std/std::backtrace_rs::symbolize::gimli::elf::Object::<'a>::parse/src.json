{
  "name": "std::backtrace_rs::symbolize::gimli::elf::Object::<'a>::parse",
  "span": "$library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:165:5: 165:51",
  "src": "fn parse(data: &'a [u8]) -> Option<Object<'a>> {\n        let elf = Elf::parse(data).ok()?;\n        let endian = elf.endian().ok()?;\n        let sections = elf.sections(endian, data).ok()?;\n        let mut syms = sections\n            .symbols(endian, data, object::elf::SHT_SYMTAB)\n            .ok()?;\n        if syms.is_empty() {\n            syms = sections\n                .symbols(endian, data, object::elf::SHT_DYNSYM)\n                .ok()?;\n        }\n        let strings = syms.strings();\n\n        let mut syms = syms\n            .iter()\n            // Only look at function/object symbols. This mirrors what\n            // libbacktrace does and in general we're only symbolicating\n            // function addresses in theory. Object symbols correspond\n            // to data, and maybe someone's crazy enough to have a\n            // function go into static data?\n            .filter(|sym| {\n                let st_type = sym.st_type();\n                st_type == object::elf::STT_FUNC || st_type == object::elf::STT_OBJECT\n            })\n            // skip anything that's in an undefined section header,\n            // since it means it's an imported function and we're only\n            // symbolicating with locally defined functions.\n            .filter(|sym| sym.st_shndx(endian) != object::elf::SHN_UNDEF)\n            .map(|sym| {\n                let address = sym.st_value(endian).into();\n                let size = sym.st_size(endian).into();\n                let name = sym.st_name(endian);\n                ParsedSym {\n                    address,\n                    size,\n                    name,\n                }\n            })\n            .collect::<Vec<_>>();\n        syms.sort_unstable_by_key(|s| s.address);\n        Some(Object {\n            endian,\n            data,\n            sections,\n            strings,\n            syms,\n        })\n    }"
}