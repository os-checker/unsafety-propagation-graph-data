{
  "name": "std::panicking::default_hook",
  "span": "$library/std/src/panicking.rs:240:1: 240:42",
  "src": "fn default_hook(info: &PanicHookInfo<'_>) {\n    // If this is a double panic, make sure that we print a backtrace\n    // for this panic. Otherwise only print it if logging is enabled.\n    let backtrace = if info.force_no_backtrace() {\n        None\n    } else if panic_count::get_count() >= 2 {\n        BacktraceStyle::full()\n    } else {\n        crate::panic::get_backtrace_style()\n    };\n\n    // The current implementation always returns `Some`.\n    let location = info.location().unwrap();\n\n    let msg = payload_as_str(info.payload());\n\n    let write = #[optimize(size)]\n    |err: &mut dyn crate::io::Write| {\n        // Use a lock to prevent mixed output in multithreading context.\n        // Some platforms also require it when printing a backtrace, like `SymFromAddr` on Windows.\n        let mut lock = backtrace::lock();\n\n        thread::with_current_name(|name| {\n            let name = name.unwrap_or(\"<unnamed>\");\n            let tid = thread::current_os_id();\n\n            // Try to write the panic message to a buffer first to prevent other concurrent outputs\n            // interleaving with it.\n            let mut buffer = [0u8; 512];\n            let mut cursor = crate::io::Cursor::new(&mut buffer[..]);\n\n            let write_msg = |dst: &mut dyn crate::io::Write| {\n                // We add a newline to ensure the panic message appears at the start of a line.\n                writeln!(dst, \"\\nthread '{name}' ({tid}) panicked at {location}:\\n{msg}\")\n            };\n\n            if write_msg(&mut cursor).is_ok() {\n                let pos = cursor.position() as usize;\n                let _ = err.write_all(&buffer[0..pos]);\n            } else {\n                // The message did not fit into the buffer, write it directly instead.\n                let _ = write_msg(err);\n            };\n        });\n\n        static FIRST_PANIC: Atomic<bool> = AtomicBool::new(true);\n\n        match backtrace {\n            Some(BacktraceStyle::Short) => {\n                drop(lock.print(err, crate::backtrace_rs::PrintFmt::Short))\n            }\n            Some(BacktraceStyle::Full) => {\n                drop(lock.print(err, crate::backtrace_rs::PrintFmt::Full))\n            }\n            Some(BacktraceStyle::Off) => {\n                if FIRST_PANIC.swap(false, Ordering::Relaxed) {\n                    let _ = writeln!(\n                        err,\n                        \"note: run with `RUST_BACKTRACE=1` environment variable to display a \\\n                             backtrace\"\n                    );\n                    if cfg!(miri) {\n                        let _ = writeln!(\n                            err,\n                            \"note: in Miri, you may have to set `MIRIFLAGS=-Zmiri-env-forward=RUST_BACKTRACE` \\\n                                for the environment variable to have an effect\"\n                        );\n                    }\n                }\n            }\n            // If backtraces aren't supported or are forced-off, do nothing.\n            None => {}\n        }\n    };\n\n    if let Ok(Some(local)) = try_set_output_capture(None) {\n        write(&mut *local.lock().unwrap_or_else(|e| e.into_inner()));\n        try_set_output_capture(Some(local)).ok();\n    } else if let Some(mut out) = panic_output() {\n        write(&mut out);\n    }\n}"
}