{
  "name": "std::<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write",
  "span": "$library/std/src/io/buffered/linewritershim.rs:69:5: 69:57",
  "src": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write(buf);\n            }\n            // Otherwise, arrange for the lines to be written directly to the\n            // inner writer.\n            Some(newline_idx) => newline_idx + 1,\n        };\n\n        // Flush existing content to prepare for our write. We have to do this\n        // before attempting to write `buf` in order to maintain consistency;\n        // if we add `buf` to the buffer then try to flush it all at once,\n        // we're obligated to return Ok(), which would mean suppressing any\n        // errors that occur during flush.\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let lines = &buf[..newline_idx];\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.buffer.panicked here.\n        let flushed = self.inner_mut().write(lines)?;\n\n        // If buffer returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of\n        // the rest as possible). If there were any unwritten newlines, we\n        // only buffer out to the last unwritten newline that fits in the\n        // buffer; this helps prevent flushing partial lines on subsequent\n        // calls to LineWriterShim::write.\n\n        // Handle the cases in order of most-common to least-common, under\n        // the presumption that most writes succeed in totality, and that most\n        // writes are smaller than the buffer.\n        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n        // - If not, does the data out to the last unwritten newline fit in\n        //   the buffer?\n        // - If not, scan for the last newline that *does* fit in the buffer\n        let tail = if flushed >= newline_idx {\n            let tail = &buf[flushed..];\n            // Avoid unnecessary short writes by not splitting the remaining\n            // bytes if they're larger than the buffer.\n            // They can be written in full by the next call to write.\n            if tail.len() >= self.buffer.capacity() {\n                return Ok(flushed);\n            }\n            tail\n        } else if newline_idx - flushed <= self.buffer.capacity() {\n            &buf[flushed..newline_idx]\n        } else {\n            let scan_area = &buf[flushed..];\n            let scan_area = &scan_area[..self.buffer.capacity()];\n            match memchr::memrchr(b'\\n', scan_area) {\n                Some(newline_idx) => &scan_area[..newline_idx + 1],\n                None => scan_area,\n            }\n        };\n\n        let buffered = self.buffer.write_to_buf(tail);\n        Ok(flushed + buffered)\n    }"
}