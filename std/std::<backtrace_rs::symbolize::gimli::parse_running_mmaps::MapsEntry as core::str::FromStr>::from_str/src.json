{
  "name": "std::<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry as core::str::FromStr>::from_str",
  "span": "$library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:98:5: 98:52",
  "src": "fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let (range_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if range_str.is_empty() {\n            return Err(\"Couldn't find address\");\n        }\n\n        let (perms_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if perms_str.is_empty() {\n            return Err(\"Couldn't find permissions\");\n        }\n\n        let (offset_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if offset_str.is_empty() {\n            return Err(\"Couldn't find offset\");\n        }\n\n        let (dev_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if dev_str.is_empty() {\n            return Err(\"Couldn't find dev\");\n        }\n\n        let (inode_str, s) = s.trim_start().split_once(' ').unwrap_or((s, \"\"));\n        if inode_str.is_empty() {\n            return Err(\"Couldn't find inode\");\n        }\n\n        // Pathname may be omitted in which case it will be empty\n        let pathname_str = s.trim_start();\n\n        let hex = |s| usize::from_str_radix(s, 16).map_err(|_| \"Couldn't parse hex number\");\n        let hex64 = |s| u64::from_str_radix(s, 16).map_err(|_| \"Couldn't parse hex number\");\n\n        let address = if let Some((start, limit)) = range_str.split_once('-') {\n            (hex(start)?, hex(limit)?)\n        } else {\n            return Err(\"Couldn't parse address range\");\n        };\n        let perms: [char; 4] = {\n            let mut chars = perms_str.chars();\n            let mut c = || chars.next().ok_or(\"insufficient perms\");\n            let perms = [c()?, c()?, c()?, c()?];\n            if chars.next().is_some() {\n                return Err(\"too many perms\");\n            }\n            perms\n        };\n        let offset = hex64(offset_str)?;\n        let dev = if let Some((major, minor)) = dev_str.split_once(':') {\n            (hex(major)?, hex(minor)?)\n        } else {\n            return Err(\"Couldn't parse dev\");\n        };\n        let inode = hex(inode_str)?;\n        let pathname = pathname_str.into();\n\n        Ok(MapsEntry {\n            address,\n            perms,\n            offset,\n            dev,\n            inode,\n            pathname,\n        })\n    }"
}