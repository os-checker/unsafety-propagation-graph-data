{
  "name": "std::sys::io::kernel_copy::linux::sendfile_splice",
  "span": "$library/std/src/sys/io/kernel_copy/linux.rs:726:1: 726:91",
  "src": "fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) -> CopyResult {\n    static HAS_SENDFILE: Atomic<bool> = AtomicBool::new(true);\n    static HAS_SPLICE: Atomic<bool> = AtomicBool::new(true);\n\n    // Android builds use feature level 14, but the libc wrapper for splice is\n    // gated on feature level 21+, so we have to invoke the syscall directly.\n    #[cfg(target_os = \"android\")]\n    syscall!(\n        fn splice(\n            srcfd: libc::c_int,\n            src_offset: *const i64,\n            dstfd: libc::c_int,\n            dst_offset: *const i64,\n            len: libc::size_t,\n            flags: libc::c_int,\n        ) -> libc::ssize_t;\n    );\n\n    #[cfg(target_os = \"linux\")]\n    use libc::splice;\n\n    match mode {\n        SpliceMode::Sendfile if !HAS_SENDFILE.load(Ordering::Relaxed) => {\n            return CopyResult::Fallback(0);\n        }\n        SpliceMode::Splice if !HAS_SPLICE.load(Ordering::Relaxed) => {\n            return CopyResult::Fallback(0);\n        }\n        _ => (),\n    }\n\n    let mut written = 0u64;\n    while written < len {\n        // according to its manpage that's the maximum size sendfile() will copy per invocation\n        let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n\n        let result = match mode {\n            SpliceMode::Sendfile => {\n                cvt(unsafe { sendfile64(writer, reader, ptr::null_mut(), chunk_size) })\n            }\n            SpliceMode::Splice => cvt(unsafe {\n                splice(reader, ptr::null_mut(), writer, ptr::null_mut(), chunk_size, 0)\n            }),\n        };\n\n        match result {\n            Ok(0) => break, // EOF\n            Ok(ret) => written += ret as u64,\n            Err(err) => {\n                return match err.raw_os_error() {\n                    Some(ENOSYS | EPERM) => {\n                        // syscall not supported (ENOSYS)\n                        // syscall is disallowed, e.g. by seccomp (EPERM)\n                        match mode {\n                            SpliceMode::Sendfile => HAS_SENDFILE.store(false, Ordering::Relaxed),\n                            SpliceMode::Splice => HAS_SPLICE.store(false, Ordering::Relaxed),\n                        }\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    Some(EINVAL) => {\n                        // splice/sendfile do not support this particular file descriptor (EINVAL)\n                        assert_eq!(written, 0);\n                        CopyResult::Fallback(0)\n                    }\n                    Some(os_err) if mode == SpliceMode::Sendfile && os_err == EOVERFLOW => {\n                        CopyResult::Fallback(written)\n                    }\n                    _ => CopyResult::Error(err, written),\n                };\n            }\n        }\n    }\n    CopyResult::Ended(written)\n}"
}