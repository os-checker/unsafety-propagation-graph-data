{
  "name": "std::sync::mpmc::list::Channel::<T>::start_send",
  "span": "$library/std/src/sync/mpmc/list.rs:175:5: 175:52",
  "src": "fn start_send(&self, token: &mut Token) -> bool {\n        let backoff = Backoff::new();\n        let mut tail = self.tail.index.load(Ordering::Acquire);\n        let mut block = self.tail.block.load(Ordering::Acquire);\n        let mut next_block = None;\n\n        loop {\n            // Check if the channel is disconnected.\n            if tail & MARK_BIT != 0 {\n                token.list.block = ptr::null();\n                return true;\n            }\n\n            // Calculate the offset of the index into the block.\n            let offset = (tail >> SHIFT) % LAP;\n\n            // If we reached the end of the block, wait until the next one is installed.\n            if offset == BLOCK_CAP {\n                backoff.spin_heavy();\n                tail = self.tail.index.load(Ordering::Acquire);\n                block = self.tail.block.load(Ordering::Acquire);\n                continue;\n            }\n\n            // If we're going to have to install the next block, allocate it in advance in order to\n            // make the wait for other threads as short as possible.\n            if offset + 1 == BLOCK_CAP && next_block.is_none() {\n                next_block = Some(Block::<T>::new());\n            }\n\n            // If this is the first message to be sent into the channel, we need to allocate the\n            // first block and install it.\n            if block.is_null() {\n                let new = Box::into_raw(Block::<T>::new());\n\n                if self\n                    .tail\n                    .block\n                    .compare_exchange(block, new, Ordering::Release, Ordering::Relaxed)\n                    .is_ok()\n                {\n                    // This yield point leaves the channel in a half-initialized state where the\n                    // tail.block pointer is set but the head.block is not. This is used to\n                    // facilitate the test in src/tools/miri/tests/pass/issues/issue-139553.rs\n                    #[cfg(miri)]\n                    crate::thread::yield_now();\n                    self.head.block.store(new, Ordering::Release);\n                    block = new;\n                } else {\n                    next_block = unsafe { Some(Box::from_raw(new)) };\n                    tail = self.tail.index.load(Ordering::Acquire);\n                    block = self.tail.block.load(Ordering::Acquire);\n                    continue;\n                }\n            }\n\n            let new_tail = tail + (1 << SHIFT);\n\n            // Try advancing the tail forward.\n            match self.tail.index.compare_exchange_weak(\n                tail,\n                new_tail,\n                Ordering::SeqCst,\n                Ordering::Acquire,\n            ) {\n                Ok(_) => unsafe {\n                    // If we've reached the end of the block, install the next one.\n                    if offset + 1 == BLOCK_CAP {\n                        let next_block = Box::into_raw(next_block.unwrap());\n                        self.tail.block.store(next_block, Ordering::Release);\n                        self.tail.index.fetch_add(1 << SHIFT, Ordering::Release);\n                        (*block).next.store(next_block, Ordering::Release);\n                    }\n\n                    token.list.block = block as *const u8;\n                    token.list.offset = offset;\n                    return true;\n                },\n                Err(_) => {\n                    backoff.spin_light();\n                    tail = self.tail.index.load(Ordering::Acquire);\n                    block = self.tail.block.load(Ordering::Acquire);\n                }\n            }\n        }\n    }"
}