{
  "name": "std::<sys::fs::unix::Mode as core::fmt::Debug>::fmt",
  "span": "$library/std/src/sys/fs/unix.rs:1948:5: 1948:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let Self(mode) = *self;\n        write!(f, \"0o{mode:06o}\")?;\n\n        let entry_type = match mode & libc::S_IFMT {\n            libc::S_IFDIR => 'd',\n            libc::S_IFBLK => 'b',\n            libc::S_IFCHR => 'c',\n            libc::S_IFLNK => 'l',\n            libc::S_IFIFO => 'p',\n            libc::S_IFREG => '-',\n            _ => return Ok(()),\n        };\n\n        f.write_str(\" (\")?;\n        f.write_char(entry_type)?;\n\n        // Owner permissions\n        f.write_char(if mode & libc::S_IRUSR != 0 { 'r' } else { '-' })?;\n        f.write_char(if mode & libc::S_IWUSR != 0 { 'w' } else { '-' })?;\n        let owner_executable = mode & libc::S_IXUSR != 0;\n        let setuid = mode as c_int & libc::S_ISUID as c_int != 0;\n        f.write_char(match (owner_executable, setuid) {\n            (true, true) => 's',  // executable and setuid\n            (false, true) => 'S', // setuid\n            (true, false) => 'x', // executable\n            (false, false) => '-',\n        })?;\n\n        // Group permissions\n        f.write_char(if mode & libc::S_IRGRP != 0 { 'r' } else { '-' })?;\n        f.write_char(if mode & libc::S_IWGRP != 0 { 'w' } else { '-' })?;\n        let group_executable = mode & libc::S_IXGRP != 0;\n        let setgid = mode as c_int & libc::S_ISGID as c_int != 0;\n        f.write_char(match (group_executable, setgid) {\n            (true, true) => 's',  // executable and setgid\n            (false, true) => 'S', // setgid\n            (true, false) => 'x', // executable\n            (false, false) => '-',\n        })?;\n\n        // Other permissions\n        f.write_char(if mode & libc::S_IROTH != 0 { 'r' } else { '-' })?;\n        f.write_char(if mode & libc::S_IWOTH != 0 { 'w' } else { '-' })?;\n        let other_executable = mode & libc::S_IXOTH != 0;\n        let sticky = mode as c_int & libc::S_ISVTX as c_int != 0;\n        f.write_char(match (entry_type, other_executable, sticky) {\n            ('d', true, true) => 't',  // searchable and restricted deletion\n            ('d', false, true) => 'T', // restricted deletion\n            (_, true, _) => 'x',       // executable\n            (_, false, _) => '-',\n        })?;\n\n        f.write_char(')')\n    }"
}