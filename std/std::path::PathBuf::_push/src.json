{
  "name": "std::path::PathBuf::_push",
  "span": "$library/std/src/path.rs:1316:5: 1316:37",
  "src": "fn _push(&mut self, path: &Path) {\n        // in general, a separator is needed if the rightmost byte is not a separator\n        let buf = self.inner.as_encoded_bytes();\n        let mut need_sep = buf.last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n\n        // in the special case of `C:` on Windows, do *not* add a separator\n        let comps = self.components();\n\n        if comps.prefix_len() > 0\n            && comps.prefix_len() == comps.path.len()\n            && comps.prefix.unwrap().is_drive()\n        {\n            need_sep = false\n        }\n\n        let need_clear = if cfg!(target_os = \"cygwin\") {\n            // If path is absolute and its prefix is none, it is like `/foo`,\n            // and will be handled below.\n            path.prefix().is_some()\n        } else {\n            // On Unix: prefix is always None.\n            path.is_absolute() || path.prefix().is_some()\n        };\n\n        // absolute `path` replaces `self`\n        if need_clear {\n            self.inner.truncate(0);\n\n        // verbatim paths need . and .. removed\n        } else if comps.prefix_verbatim() && !path.inner.is_empty() {\n            let mut buf: Vec<_> = comps.collect();\n            for c in path.components() {\n                match c {\n                    Component::RootDir => {\n                        buf.truncate(1);\n                        buf.push(c);\n                    }\n                    Component::CurDir => (),\n                    Component::ParentDir => {\n                        if let Some(Component::Normal(_)) = buf.last() {\n                            buf.pop();\n                        }\n                    }\n                    _ => buf.push(c),\n                }\n            }\n\n            let mut res = OsString::new();\n            let mut need_sep = false;\n\n            for c in buf {\n                if need_sep && c != Component::RootDir {\n                    res.push(MAIN_SEP_STR);\n                }\n                res.push(c.as_os_str());\n\n                need_sep = match c {\n                    Component::RootDir => false,\n                    Component::Prefix(prefix) => {\n                        !prefix.parsed.is_drive() && prefix.parsed.len() > 0\n                    }\n                    _ => true,\n                }\n            }\n\n            self.inner = res;\n            return;\n\n        // `path` has a root but no prefix, e.g., `\\windows` (Windows only)\n        } else if path.has_root() {\n            let prefix_len = self.components().prefix_remaining();\n            self.inner.truncate(prefix_len);\n\n        // `path` is a pure relative path\n        } else if need_sep {\n            self.inner.push(MAIN_SEP_STR);\n        }\n\n        self.inner.push(path);\n    }"
}