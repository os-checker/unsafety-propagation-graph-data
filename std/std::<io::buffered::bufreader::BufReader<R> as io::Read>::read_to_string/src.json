{
  "name": "std::<io::buffered::bufreader::BufReader<R> as io::Read>::read_to_string",
  "span": "$library/std/src/io/buffered/bufreader.rs:412:5: 412:72",
  "src": "fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        // In the general `else` case below we must read bytes into a side buffer, check\n        // that they are valid UTF-8, and then append them to `buf`. This requires a\n        // potentially large memcpy.\n        //\n        // If `buf` is empty--the most common case--we can leverage `append_to_string`\n        // to read directly into `buf`'s internal byte buffer, saving an allocation and\n        // a memcpy.\n        if buf.is_empty() {\n            // `append_to_string`'s safety relies on the buffer only being appended to since\n            // it only checks the UTF-8 validity of new data. If there were existing content in\n            // `buf` then an untrustworthy reader (i.e. `self.inner`) could not only append\n            // bytes but also modify existing bytes and render them invalid. On the other hand,\n            // if `buf` is empty then by definition any writes must be appends and\n            // `append_to_string` will validate all of the new bytes.\n            unsafe { crate::io::append_to_string(buf, |b| self.read_to_end(b)) }\n        } else {\n            // We cannot append our byte buffer directly onto the `buf` String as there could\n            // be an incomplete UTF-8 sequence that has only been partially read. We must read\n            // everything into a side buffer first and then call `from_utf8` on the complete\n            // buffer.\n            let mut bytes = Vec::new();\n            self.read_to_end(&mut bytes)?;\n            let string = crate::str::from_utf8(&bytes).map_err(|_| io::Error::INVALID_UTF8)?;\n            *buf += string;\n            Ok(string.len())\n        }\n    }"
}