{
  "name": "std::sys::thread::unix::Thread::new",
  "span": "$library/std/src/sys/thread/unix.rs:46:5: 46:81",
  "src": "pub unsafe fn new(stack: usize, init: Box<ThreadInit>) -> io::Result<Thread> {\n        let data = init;\n        let mut attr: mem::MaybeUninit<libc::pthread_attr_t> = mem::MaybeUninit::uninit();\n        assert_eq!(libc::pthread_attr_init(attr.as_mut_ptr()), 0);\n        let mut attr = DropGuard::new(&mut attr, |attr| {\n            assert_eq!(libc::pthread_attr_destroy(attr.as_mut_ptr()), 0)\n        });\n\n        #[cfg(any(target_os = \"espidf\", target_os = \"nuttx\"))]\n        if stack > 0 {\n            // Only set the stack if a non-zero value is passed\n            // 0 is used as an indication that the default stack size configured in the ESP-IDF/NuttX menuconfig system should be used\n            assert_eq!(\n                libc::pthread_attr_setstacksize(\n                    attr.as_mut_ptr(),\n                    cmp::max(stack, min_stack_size(attr.as_ptr()))\n                ),\n                0\n            );\n        }\n\n        #[cfg(not(any(target_os = \"espidf\", target_os = \"nuttx\")))]\n        {\n            let stack_size = cmp::max(stack, min_stack_size(attr.as_ptr()));\n\n            match libc::pthread_attr_setstacksize(attr.as_mut_ptr(), stack_size) {\n                0 => {}\n                n => {\n                    assert_eq!(n, libc::EINVAL);\n                    // EINVAL means |stack_size| is either too small or not a\n                    // multiple of the system page size. Because it's definitely\n                    // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                    // Round up to the nearest page and try again.\n                    let page_size = os::page_size();\n                    let stack_size =\n                        (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n\n                    // Some libc implementations, e.g. musl, place an upper bound\n                    // on the stack size, in which case we can only gracefully return\n                    // an error here.\n                    if libc::pthread_attr_setstacksize(attr.as_mut_ptr(), stack_size) != 0 {\n                        return Err(io::const_error!(\n                            io::ErrorKind::InvalidInput,\n                            \"invalid stack size\"\n                        ));\n                    }\n                }\n            };\n        }\n\n        let data = Box::into_raw(data);\n        let mut native: libc::pthread_t = mem::zeroed();\n        let ret = libc::pthread_create(&mut native, attr.as_ptr(), thread_start, data as *mut _);\n        return if ret == 0 {\n            Ok(Thread { id: native })\n        } else {\n            // The thread failed to start and as a result `data` was not consumed.\n            // Therefore, it is safe to reconstruct the box so that it gets deallocated.\n            drop(Box::from_raw(data));\n            Err(io::Error::from_raw_os_error(ret))\n        };\n\n        extern \"C\" fn thread_start(data: *mut libc::c_void) -> *mut libc::c_void {\n            unsafe {\n                // SAFETY: we are simply recreating the box that was leaked earlier.\n                let init = Box::from_raw(data as *mut ThreadInit);\n                let rust_start = init.init();\n\n                // Now that the thread information is set, set up our stack\n                // overflow handler.\n                let _handler = stack_overflow::Handler::new();\n\n                rust_start();\n            }\n            ptr::null_mut()\n        }\n    }"
}