{
  "name": "std::process::ExitCode::exit_process",
  "span": "$library/std/src/process.rs:2165:5: 2165:35",
  "doc": " Exit the current process with the given `ExitCode`.\n\n Note that this has the same caveats as [`process::exit()`][exit], namely that this function\n terminates the process immediately, so no destructors on the current stack or any other\n thread's stack will be run. Also see those docs for some important notes on interop with C\n code. If a clean shutdown is needed, it is recommended to simply return this ExitCode from\n the `main` function, as demonstrated in the [type documentation](#examples).\n\n # Differences from `process::exit()`\n\n `process::exit()` accepts any `i32` value as the exit code for the process; however, there\n are platforms that only use a subset of that value (see [`process::exit` platform-specific\n behavior][exit#platform-specific-behavior]). `ExitCode` exists because of this; only\n `ExitCode`s that are supported by a majority of our platforms can be created, so those\n problems don't exist (as much) with this method.\n\n # Examples\n\n ```\n #![feature(exitcode_exit_method)]\n # use std::process::ExitCode;\n # use std::fmt;\n # enum UhOhError { GenericProblem, Specific, WithCode { exit_code: ExitCode, _x: () } }\n # impl fmt::Display for UhOhError {\n #     fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result { unimplemented!() }\n # }\n // there's no way to gracefully recover from an UhOhError, so we just\n // print a message and exit\n fn handle_unrecoverable_error(err: UhOhError) -> ! {\n     eprintln!(\"UH OH! {err}\");\n     let code = match err {\n         UhOhError::GenericProblem => ExitCode::FAILURE,\n         UhOhError::Specific => ExitCode::from(3),\n         UhOhError::WithCode { exit_code, .. } => exit_code,\n     };\n     code.exit_process()\n }\n ```\n"
}