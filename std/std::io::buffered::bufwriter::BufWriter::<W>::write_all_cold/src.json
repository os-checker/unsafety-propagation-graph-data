{
  "name": "std::io::buffered::bufwriter::BufWriter::<W>::write_all_cold",
  "span": "$library/std/src/io/buffered/bufwriter.rs:401:5: 401:63",
  "src": "fn write_all_cold(&mut self, buf: &[u8]) -> io::Result<()> {\n        // Normally, `write_all` just calls `write` in a loop. We can do better\n        // by calling `self.get_mut().write_all()` directly, which avoids\n        // round trips through the buffer in the event of a series of partial\n        // writes in some circumstances.\n\n        if buf.len() > self.spare_capacity() {\n            self.flush_buf()?;\n        }\n\n        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n        if buf.len() >= self.buf.capacity() {\n            self.panicked = true;\n            let r = self.get_mut().write_all(buf);\n            self.panicked = false;\n            r\n        } else {\n            // Write to the buffer. In this case, we write to the buffer even if it fills it\n            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n            // input to the inner writer, which in many cases would be a worse strategy.\n\n            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n            // flushed the buffer to ensure that there is. In the latter case, we know that there\n            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n            // this block because the input buffer length is less than that capacity. In either\n            // case, it's safe to write the input buffer to our buffer.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(())\n        }\n    }"
}