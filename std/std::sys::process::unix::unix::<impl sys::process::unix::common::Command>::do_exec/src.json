{
  "name": "std::sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec",
  "span": "$library/std/src/sys/process/unix/unix.rs:278:5: 282:30",
  "src": "unsafe fn do_exec(\n        &mut self,\n        stdio: ChildPipes,\n        maybe_envp: Option<&CStringArray>,\n    ) -> Result<!, io::Error> {\n        use crate::sys::{self, cvt_r};\n\n        if let Some(fd) = stdio.stdin.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n        }\n        if let Some(fd) = stdio.stdout.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n        }\n        if let Some(fd) = stdio.stderr.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n        }\n\n        #[cfg(not(target_os = \"l4re\"))]\n        {\n            if let Some(_g) = self.get_groups() {\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                cvt(libc::setgroups(_g.len().try_into().unwrap(), _g.as_ptr()))?;\n            }\n            if let Some(u) = self.get_gid() {\n                cvt(libc::setgid(u as gid_t))?;\n            }\n            if let Some(u) = self.get_uid() {\n                // When dropping privileges from root, the `setgroups` call\n                // will remove any extraneous groups. We only drop groups\n                // if we have CAP_SETGID and we weren't given an explicit\n                // set of groups. If we don't call this, then even though our\n                // uid has dropped, we may still have groups that enable us to\n                // do super-user things.\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                if self.get_groups().is_none() {\n                    let res = cvt(libc::setgroups(0, crate::ptr::null()));\n                    if let Err(e) = res {\n                        // Here we ignore the case of not having CAP_SETGID.\n                        // An alternative would be to require CAP_SETGID (in\n                        // addition to CAP_SETUID) for setting the UID.\n                        if e.raw_os_error() != Some(libc::EPERM) {\n                            return Err(e.into());\n                        }\n                    }\n                }\n                cvt(libc::setuid(u as uid_t))?;\n            }\n        }\n        if let Some(chroot) = self.get_chroot() {\n            #[cfg(not(target_os = \"fuchsia\"))]\n            cvt(libc::chroot(chroot.as_ptr()))?;\n            #[cfg(target_os = \"fuchsia\")]\n            return Err(io::const_error!(\n                io::ErrorKind::Unsupported,\n                \"chroot not supported by fuchsia\"\n            ));\n        }\n        if let Some(cwd) = self.get_cwd() {\n            cvt(libc::chdir(cwd.as_ptr()))?;\n        }\n\n        if let Some(pgroup) = self.get_pgroup() {\n            cvt(libc::setpgid(0, pgroup))?;\n        }\n\n        if self.get_setsid() {\n            cvt(libc::setsid())?;\n        }\n\n        // emscripten has no signal support.\n        #[cfg(not(target_os = \"emscripten\"))]\n        {\n            // Inherit the signal mask from the parent rather than resetting it (i.e. do not call\n            // pthread_sigmask).\n\n            // If -Zon-broken-pipe is used, don't reset SIGPIPE to SIG_DFL.\n            // If -Zon-broken-pipe is not used, reset SIGPIPE to SIG_DFL for backward compatibility.\n            //\n            // -Zon-broken-pipe is an opportunity to change the default here.\n            if !crate::sys::pal::on_broken_pipe_flag_used() {\n                #[cfg(target_os = \"android\")] // see issue #88585\n                {\n                    let mut action: libc::sigaction = mem::zeroed();\n                    action.sa_sigaction = libc::SIG_DFL;\n                    cvt(libc::sigaction(libc::SIGPIPE, &action, crate::ptr::null_mut()))?;\n                }\n                #[cfg(not(target_os = \"android\"))]\n                {\n                    let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n                    if ret == libc::SIG_ERR {\n                        return Err(io::Error::last_os_error());\n                    }\n                }\n                #[cfg(target_os = \"hurd\")]\n                {\n                    let ret = sys::signal(libc::SIGLOST, libc::SIG_DFL);\n                    if ret == libc::SIG_ERR {\n                        return Err(io::Error::last_os_error());\n                    }\n                }\n            }\n        }\n\n        for callback in self.get_closures().iter_mut() {\n            callback()?;\n        }\n\n        // Although we're performing an exec here we may also return with an\n        // error from this function (without actually exec'ing) in which case we\n        // want to be sure to restore the global environment back to what it\n        // once was, ensuring that our temporary override, when free'd, doesn't\n        // corrupt our process's environment.\n        let mut _reset = None;\n        if let Some(envp) = maybe_envp {\n            struct Reset(*const *const libc::c_char);\n\n            impl Drop for Reset {\n                fn drop(&mut self) {\n                    unsafe {\n                        *sys::env::environ() = self.0;\n                    }\n                }\n            }\n\n            _reset = Some(Reset(*sys::env::environ()));\n            *sys::env::environ() = envp.as_ptr();\n        }\n\n        libc::execvp(self.get_program_cstr().as_ptr(), self.get_argv().as_ptr());\n        Err(io::Error::last_os_error())\n    }"
}