{
  "name": "std::sys::sync::once::futex::Once::call",
  "span": "$library/std/src/sys/sync/once/futex.rs:141:5: 141:86",
  "src": "pub fn call(&self, ignore_poisoning: bool, f: &mut dyn FnMut(&public::OnceState)) {\n        let mut state_and_queued = self.state_and_queued.load(Acquire);\n        loop {\n            let state = state_and_queued & STATE_MASK;\n            let queued = state_and_queued & QUEUED != 0;\n            match state {\n                COMPLETE => return,\n                POISONED if !ignore_poisoning => {\n                    // Panic to propagate the poison.\n                    panic!(\"Once instance has previously been poisoned\");\n                }\n                INCOMPLETE | POISONED => {\n                    // Try to register the current thread as the one running.\n                    let next = RUNNING + if queued { QUEUED } else { 0 };\n                    if let Err(new) = self.state_and_queued.compare_exchange_weak(\n                        state_and_queued,\n                        next,\n                        Acquire,\n                        Acquire,\n                    ) {\n                        state_and_queued = new;\n                        continue;\n                    }\n\n                    // `waiter_queue` will manage other waiting threads, and\n                    // wake them up on drop.\n                    let mut waiter_queue = CompletionGuard {\n                        state_and_queued: &self.state_and_queued,\n                        set_state_on_drop_to: POISONED,\n                    };\n                    // Run the function, letting it know if we're poisoned or not.\n                    let f_state = public::OnceState {\n                        inner: OnceState {\n                            poisoned: state == POISONED,\n                            set_state_to: Cell::new(COMPLETE),\n                        },\n                    };\n                    f(&f_state);\n                    waiter_queue.set_state_on_drop_to = f_state.inner.set_state_to.get();\n                    return;\n                }\n                _ => {\n                    // All other values must be RUNNING.\n                    assert!(state == RUNNING);\n\n                    // Set the QUEUED bit if it is not already set.\n                    if !queued {\n                        state_and_queued += QUEUED;\n                        if let Err(new) = self.state_and_queued.compare_exchange_weak(\n                            state,\n                            state_and_queued,\n                            Relaxed,\n                            Acquire,\n                        ) {\n                            state_and_queued = new;\n                            continue;\n                        }\n                    }\n\n                    futex_wait(&self.state_and_queued, state_and_queued, None);\n                    state_and_queued = self.state_and_queued.load(Acquire);\n                }\n            }\n        }\n    }"
}