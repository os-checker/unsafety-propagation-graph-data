{
  "name": "std::process::Command::new",
  "span": "$library/std/src/process.rs:666:5: 666:55",
  "doc": " Constructs a new `Command` for launching the program at\n path `program`, with the following default configuration:\n\n * No arguments to the program\n * Inherit the current process's environment\n * Inherit the current process's working directory\n * Inherit stdin/stdout/stderr for [`spawn`] or [`status`], but create pipes for [`output`]\n\n [`spawn`]: Self::spawn\n [`status`]: Self::status\n [`output`]: Self::output\n\n Builder methods are provided to change these defaults and\n otherwise configure the process.\n\n If `program` is not an absolute path, the `PATH` will be searched in\n an OS-defined way.\n\n The search path to be used may be controlled by setting the\n `PATH` environment variable on the Command,\n but this has some implementation limitations on Windows\n (see issue #37519).\n\n # Platform-specific behavior\n\n Note on Windows: For executable files with the .exe extension,\n it can be omitted when specifying the program for this Command.\n However, if the file has a different extension,\n a filename including the extension needs to be provided,\n otherwise the file won't be found.\n\n # Examples\n\n ```no_run\n use std::process::Command;\n\n Command::new(\"sh\")\n     .spawn()\n     .expect(\"sh command failed to start\");\n ```\n\n # Caveats\n\n [`Command::new`] is only intended to accept the path of the program. If you pass a program\n path along with arguments like `Command::new(\"ls -l\").spawn()`, it will try to search for\n `ls -l` literally. The arguments need to be passed separately, such as via [`arg`] or\n [`args`].\n\n ```no_run\n use std::process::Command;\n\n Command::new(\"ls\")\n     .arg(\"-l\") // arg passed separately\n     .spawn()\n     .expect(\"ls command failed to start\");\n ```\n\n [`arg`]: Self::arg\n [`args`]: Self::args\n"
}