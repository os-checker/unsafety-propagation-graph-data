{
  "name": "std::sys::pal::unix::stack_overflow::imp::install_main_guard_default",
  "span": "$library/std/src/sys/pal/unix/stack_overflow.rs:505:5: 505:83",
  "src": "unsafe fn install_main_guard_default(page_size: usize) -> Option<Range<usize>> {\n        // Reallocate the last page of the stack.\n        // This ensures SIGBUS will be raised on\n        // stack overflow.\n        // Systems which enforce strict PAX MPROTECT do not allow\n        // to mprotect() a mapping with less restrictive permissions\n        // than the initial mmap() used, so we mmap() here with\n        // read/write permissions and only then mprotect() it to\n        // no permissions at all. See issue #50313.\n        let stackptr = stack_start_aligned(page_size)?;\n        let result = unsafe {\n            mmap64(\n                stackptr,\n                page_size,\n                PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                -1,\n                0,\n            )\n        };\n        if result != stackptr || result == MAP_FAILED {\n            panic!(\"failed to allocate a guard page: {}\", io::Error::last_os_error());\n        }\n\n        let result = unsafe { mprotect(stackptr, page_size, PROT_NONE) };\n        if result != 0 {\n            panic!(\"failed to protect the guard page: {}\", io::Error::last_os_error());\n        }\n\n        let guardaddr = stackptr.addr();\n\n        Some(guardaddr..guardaddr + page_size)\n    }"
}