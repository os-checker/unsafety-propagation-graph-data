{
  "name": "std::sys::pal::unix::stack_overflow::imp::current_guard",
  "span": "$library/std/src/sys/pal/unix/stack_overflow.rs:561:5: 561:54",
  "src": "unsafe fn current_guard() -> Option<Range<usize>> {\n        let mut ret = None;\n\n        let mut attr: mem::MaybeUninit<libc::pthread_attr_t> = mem::MaybeUninit::uninit();\n        if !cfg!(target_os = \"freebsd\") {\n            attr = mem::MaybeUninit::zeroed();\n        }\n        #[cfg(target_os = \"freebsd\")]\n        assert_eq!(libc::pthread_attr_init(attr.as_mut_ptr()), 0);\n        #[cfg(target_os = \"freebsd\")]\n        let e = libc::pthread_attr_get_np(libc::pthread_self(), attr.as_mut_ptr());\n        #[cfg(not(target_os = \"freebsd\"))]\n        let e = libc::pthread_getattr_np(libc::pthread_self(), attr.as_mut_ptr());\n        if e == 0 {\n            let mut guardsize = 0;\n            assert_eq!(libc::pthread_attr_getguardsize(attr.as_ptr(), &mut guardsize), 0);\n            if guardsize == 0 {\n                if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n                    // musl versions before 1.1.19 always reported guard\n                    // size obtained from pthread_attr_get_np as zero.\n                    // Use page size as a fallback.\n                    guardsize = PAGE_SIZE.load(Ordering::Relaxed);\n                } else {\n                    panic!(\"there is no guard page\");\n                }\n            }\n            let mut stackptr = crate::ptr::null_mut::<libc::c_void>();\n            let mut size = 0;\n            assert_eq!(libc::pthread_attr_getstack(attr.as_ptr(), &mut stackptr, &mut size), 0);\n\n            let stackaddr = stackptr.addr();\n            ret = if cfg!(any(target_os = \"freebsd\", target_os = \"netbsd\", target_os = \"hurd\")) {\n                Some(stackaddr - guardsize..stackaddr)\n            } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n                Some(stackaddr - guardsize..stackaddr)\n            } else if cfg!(all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")))\n            {\n                // glibc used to include the guard area within the stack, as noted in the BUGS\n                // section of `man pthread_attr_getguardsize`. This has been corrected starting\n                // with glibc 2.27, and in some distro backports, so the guard is now placed at the\n                // end (below) the stack. There's no easy way for us to know which we have at\n                // runtime, so we'll just match any fault in the range right above or below the\n                // stack base to call that fault a stack overflow.\n                Some(stackaddr - guardsize..stackaddr + guardsize)\n            } else {\n                Some(stackaddr..stackaddr + guardsize)\n            };\n        }\n        if e == 0 || cfg!(target_os = \"freebsd\") {\n            assert_eq!(libc::pthread_attr_destroy(attr.as_mut_ptr()), 0);\n        }\n        ret\n    }"
}