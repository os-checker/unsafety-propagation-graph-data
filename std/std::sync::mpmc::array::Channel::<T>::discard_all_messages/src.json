{
  "name": "std::sync::mpmc::array::Channel::<T>::discard_all_messages",
  "span": "$library/std/src/sync/mpmc/array.rs:495:5: 495:55",
  "src": "unsafe fn discard_all_messages(&self, tail: usize) {\n        debug_assert!(self.is_disconnected());\n\n        // Only receivers modify `head`, so since we are the last one,\n        // this value will not change and will not be observed (since\n        // no new messages can be sent after disconnection).\n        let mut head = self.head.load(Ordering::Relaxed);\n        let tail = tail & !self.mark_bit;\n\n        let backoff = Backoff::new();\n        loop {\n            // Deconstruct the head.\n            let index = head & (self.mark_bit - 1);\n            let lap = head & !(self.one_lap - 1);\n\n            // Inspect the corresponding slot.\n            debug_assert!(index < self.buffer.len());\n            let slot = unsafe { self.buffer.get_unchecked(index) };\n            let stamp = slot.stamp.load(Ordering::Acquire);\n\n            // If the stamp is ahead of the head by 1, we may drop the message.\n            if head + 1 == stamp {\n                head = if index + 1 < self.cap {\n                    // Same lap, incremented index.\n                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n                    head + 1\n                } else {\n                    // One lap forward, index wraps around to zero.\n                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n                    lap.wrapping_add(self.one_lap)\n                };\n\n                unsafe {\n                    (*slot.msg.get()).assume_init_drop();\n                }\n            // If the tail equals the head, that means the channel is empty.\n            } else if tail == head {\n                return;\n            // Otherwise, a sender is about to write into the slot, so we need\n            // to wait for it to update the stamp.\n            } else {\n                backoff.spin_heavy();\n            }\n        }\n    }"
}