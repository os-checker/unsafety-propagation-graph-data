{
  "name": "std::sys::pal::unix::weak::dlsym::DlsymWeak::<F>::get",
  "span": "$library/std/src/sys/pal/unix/weak/dlsym.rs:51:5: 51:35",
  "src": "pub fn get(&self) -> Option<F> {\n        // The caller is presumably going to read through this value\n        // (by calling the function we've dlsymed). This means we'd\n        // need to have loaded it with at least C11's consume\n        // ordering in order to be guaranteed that the data we read\n        // from the pointer isn't from before the pointer was\n        // stored. Rust has no equivalent to memory_order_consume,\n        // so we use an acquire load (sorry, ARM).\n        //\n        // Now, in practice this likely isn't needed even on CPUs\n        // where relaxed and consume mean different things. The\n        // symbols we're loading are probably present (or not) at\n        // init, and even if they aren't the runtime dynamic loader\n        // is extremely likely have sufficient barriers internally\n        // (possibly implicitly, for example the ones provided by\n        // invoking `mprotect`).\n        //\n        // That said, none of that's *guaranteed*, so we use acquire.\n        match self.func.load(Ordering::Acquire) {\n            func if func.addr() == 1 => self.initialize(),\n            func if func.is_null() => None,\n            // SAFETY:\n            // `func` is not null and `F` implements `FnPtr`, thus this\n            // transmutation is well-defined. It is the responsibility of the\n            // creator of this `DlsymWeak` to ensure that calling the resulting\n            // function pointer does not result in undefined behaviour (though\n            // the `weak!` macro delegates this responsibility to the caller\n            // of the function by using `unsafe` function pointers).\n            // FIXME: use `transmute` once it stops complaining about generics.\n            func => Some(unsafe { mem::transmute_copy::<*mut c_void, F>(&func) }),\n        }\n    }"
}