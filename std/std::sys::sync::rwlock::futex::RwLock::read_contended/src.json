{
  "name": "std::sys::sync::rwlock::futex::RwLock::read_contended",
  "span": "$library/std/src/sys/sync/rwlock/futex.rs:124:5: 124:29",
  "src": "fn read_contended(&self) {\n        let mut has_slept = false;\n        let mut state = self.spin_read();\n\n        loop {\n            // If we have just been woken up, first check for a `downgrade` call.\n            // Otherwise, if we can read-lock it, lock it.\n            if (has_slept && is_read_lockable_after_wakeup(state)) || is_read_lockable(state) {\n                match self.state.compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)\n                {\n                    Ok(_) => return, // Locked!\n                    Err(s) => {\n                        state = s;\n                        continue;\n                    }\n                }\n            }\n\n            // Check for overflow.\n            assert!(!has_reached_max_readers(state), \"too many active read locks on RwLock\");\n\n            // Make sure the readers waiting bit is set before we go to sleep.\n            if !has_readers_waiting(state) {\n                if let Err(s) =\n                    self.state.compare_exchange(state, state | READERS_WAITING, Relaxed, Relaxed)\n                {\n                    state = s;\n                    continue;\n                }\n            }\n\n            // Wait for the state to change.\n            futex_wait(&self.state, state | READERS_WAITING, None);\n            has_slept = true;\n\n            // Spin again after waking up.\n            state = self.spin_read();\n        }\n    }"
}